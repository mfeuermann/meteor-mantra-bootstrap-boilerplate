/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	mocha.setup("bdd");
	__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"!!/Users/chemzqm/component-dev/stack-source-map/test/test.babel.js\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	__webpack_require__(10);
	if(false) {
		module.hot.accept();
		module.hot.dispose(function() {
			mocha.suite.suites.length = 0;
			var stats = document.getElementById('mocha-stats');
			var report = document.getElementById('mocha-report');
			stats.parentNode.removeChild(stats);
			report.parentNode.removeChild(report);
		});
	}

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	if (! document.getElementById("mocha")) { document.write("<div id=\"mocha\"></div>"); }
	
	__webpack_require__(2);
	__webpack_require__(6);


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(3);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		module.hot.accept("!!/Users/chemzqm/component-dev/stack-source-map/node_modules/css-loader/index.js!/Users/chemzqm/component-dev/stack-source-map/node_modules/mocha/mocha.css", function() {
			var newContent = require("!!/Users/chemzqm/component-dev/stack-source-map/node_modules/css-loader/index.js!/Users/chemzqm/component-dev/stack-source-map/node_modules/mocha/mocha.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	exports.push([module.id, "@charset \"utf-8\";\n\nbody {\n  margin:0;\n}\n\n#mocha {\n  font: 20px/1.5 \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n  margin: 60px 50px;\n}\n\n#mocha ul,\n#mocha li {\n  margin: 0;\n  padding: 0;\n}\n\n#mocha ul {\n  list-style: none;\n}\n\n#mocha h1,\n#mocha h2 {\n  margin: 0;\n}\n\n#mocha h1 {\n  margin-top: 15px;\n  font-size: 1em;\n  font-weight: 200;\n}\n\n#mocha h1 a {\n  text-decoration: none;\n  color: inherit;\n}\n\n#mocha h1 a:hover {\n  text-decoration: underline;\n}\n\n#mocha .suite .suite h1 {\n  margin-top: 0;\n  font-size: .8em;\n}\n\n#mocha .hidden {\n  display: none;\n}\n\n#mocha h2 {\n  font-size: 12px;\n  font-weight: normal;\n  cursor: pointer;\n}\n\n#mocha .suite {\n  margin-left: 15px;\n}\n\n#mocha .test {\n  margin-left: 15px;\n  overflow: hidden;\n}\n\n#mocha .test.pending:hover h2::after {\n  content: '(pending)';\n  font-family: arial, sans-serif;\n}\n\n#mocha .test.pass.medium .duration {\n  background: #c09853;\n}\n\n#mocha .test.pass.slow .duration {\n  background: #b94a48;\n}\n\n#mocha .test.pass::before {\n  content: '✓';\n  font-size: 12px;\n  display: block;\n  float: left;\n  margin-right: 5px;\n  color: #00d6b2;\n}\n\n#mocha .test.pass .duration {\n  font-size: 9px;\n  margin-left: 5px;\n  padding: 2px 5px;\n  color: #fff;\n  -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.2);\n  -moz-box-shadow: inset 0 1px 1px rgba(0,0,0,.2);\n  box-shadow: inset 0 1px 1px rgba(0,0,0,.2);\n  -webkit-border-radius: 5px;\n  -moz-border-radius: 5px;\n  -ms-border-radius: 5px;\n  -o-border-radius: 5px;\n  border-radius: 5px;\n}\n\n#mocha .test.pass.fast .duration {\n  display: none;\n}\n\n#mocha .test.pending {\n  color: #0b97c4;\n}\n\n#mocha .test.pending::before {\n  content: '◦';\n  color: #0b97c4;\n}\n\n#mocha .test.fail {\n  color: #c00;\n}\n\n#mocha .test.fail pre {\n  color: black;\n}\n\n#mocha .test.fail::before {\n  content: '✖';\n  font-size: 12px;\n  display: block;\n  float: left;\n  margin-right: 5px;\n  color: #c00;\n}\n\n#mocha .test pre.error {\n  color: #c00;\n  max-height: 300px;\n  overflow: auto;\n}\n\n#mocha .test .html-error {\n  overflow: auto;\n  color: black;\n  line-height: 1.5;\n  display: block;\n  float: left;\n  clear: left;\n  font: 12px/1.5 monaco, monospace;\n  margin: 5px;\n  padding: 15px;\n  border: 1px solid #eee;\n  max-width: 85%; /*(1)*/\n  max-width: calc(100% - 42px); /*(2)*/\n  max-height: 300px;\n  word-wrap: break-word;\n  border-bottom-color: #ddd;\n  -webkit-border-radius: 3px;\n  -webkit-box-shadow: 0 1px 3px #eee;\n  -moz-border-radius: 3px;\n  -moz-box-shadow: 0 1px 3px #eee;\n  border-radius: 3px;\n}\n\n#mocha .test .html-error pre.error {\n  border: none;\n  -webkit-border-radius: none;\n  -webkit-box-shadow: none;\n  -moz-border-radius: none;\n  -moz-box-shadow: none;\n  padding: 0;\n  margin: 0;\n  margin-top: 18px;\n  max-height: none;\n}\n\n/**\n * (1): approximate for browsers not supporting calc\n * (2): 42 = 2*15 + 2*10 + 2*1 (padding + margin + border)\n *      ^^ seriously\n */\n#mocha .test pre {\n  display: block;\n  float: left;\n  clear: left;\n  font: 12px/1.5 monaco, monospace;\n  margin: 5px;\n  padding: 15px;\n  border: 1px solid #eee;\n  max-width: 85%; /*(1)*/\n  max-width: calc(100% - 42px); /*(2)*/\n  word-wrap: break-word;\n  border-bottom-color: #ddd;\n  -webkit-border-radius: 3px;\n  -webkit-box-shadow: 0 1px 3px #eee;\n  -moz-border-radius: 3px;\n  -moz-box-shadow: 0 1px 3px #eee;\n  border-radius: 3px;\n}\n\n#mocha .test h2 {\n  position: relative;\n}\n\n#mocha .test a.replay {\n  position: absolute;\n  top: 3px;\n  right: 0;\n  text-decoration: none;\n  vertical-align: middle;\n  display: block;\n  width: 15px;\n  height: 15px;\n  line-height: 15px;\n  text-align: center;\n  background: #eee;\n  font-size: 15px;\n  -moz-border-radius: 15px;\n  border-radius: 15px;\n  -webkit-transition: opacity 200ms;\n  -moz-transition: opacity 200ms;\n  transition: opacity 200ms;\n  opacity: 0.3;\n  color: #888;\n}\n\n#mocha .test:hover a.replay {\n  opacity: 1;\n}\n\n#mocha-report.pass .test.fail {\n  display: none;\n}\n\n#mocha-report.fail .test.pass {\n  display: none;\n}\n\n#mocha-report.pending .test.pass,\n#mocha-report.pending .test.fail {\n  display: none;\n}\n#mocha-report.pending .test.pass.pending {\n  display: block;\n}\n\n#mocha-error {\n  color: #c00;\n  font-size: 1.5em;\n  font-weight: 100;\n  letter-spacing: 1px;\n}\n\n#mocha-stats {\n  position: fixed;\n  top: 15px;\n  right: 10px;\n  font-size: 12px;\n  margin: 0;\n  color: #888;\n  z-index: 1;\n}\n\n#mocha-stats .progress {\n  float: right;\n  padding-top: 0;\n}\n\n#mocha-stats em {\n  color: black;\n}\n\n#mocha-stats a {\n  text-decoration: none;\n  color: inherit;\n}\n\n#mocha-stats a:hover {\n  border-bottom: 1px solid #eee;\n}\n\n#mocha-stats li {\n  display: inline-block;\n  margin: 0 5px;\n  list-style: none;\n  padding-top: 11px;\n}\n\n#mocha-stats canvas {\n  width: 40px;\n  height: 40px;\n}\n\n#mocha code .comment { color: #ddd; }\n#mocha code .init { color: #2f6fad; }\n#mocha code .string { color: #5890ad; }\n#mocha code .keyword { color: #8a6343; }\n#mocha code .number { color: #2f6fad; }\n\n@media screen and (max-device-width: 480px) {\n  #mocha {\n    margin: 60px 0px;\n  }\n\n  #mocha #stats {\n    position: absolute;\n  }\n}\n", ""]);

/***/ },
/* 4 */
/***/ function(module, exports) {

	module.exports = function() {
		var list = [];
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
		return list;
	}

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isIE9 = memoize(function() {
			return /msie 9\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0;
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isIE9();
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function createStyleElement() {
		var styleElement = document.createElement("style");
		var head = getHeadElement();
		styleElement.type = "text/css";
		head.appendChild(styleElement);
		return styleElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement());
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else {
			styleElement = createStyleElement();
			update = applyToTag.bind(null, styleElement);
			remove = function () {
				styleElement.parentNode.removeChild(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	function replaceText(source, id, replacement) {
		var boundaries = ["/** >>" + id + " **/", "/** " + id + "<< **/"];
		var start = source.lastIndexOf(boundaries[0]);
		var wrappedReplacement = replacement
			? (boundaries[0] + replacement + boundaries[1])
			: "";
		if (source.lastIndexOf(boundaries[0]) >= 0) {
			var end = source.lastIndexOf(boundaries[1]) + boundaries[1].length;
			return source.slice(0, start) + wrappedReplacement + source.slice(end);
		} else {
			return source + wrappedReplacement;
		}
	}
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(styleElement.styleSheet.cssText, index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap && typeof btoa === "function") {
			try {
				css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(JSON.stringify(sourceMap)) + " */";
				css = "@import url(\"data:text/css;base64," + btoa(css) + "\")";
			} catch(e) {}
		}
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(7)(__webpack_require__(8))

/***/ },
/* 7 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = function(src) {
		if (typeof execScript === "function")
			execScript(src);
		else
			eval.call(null, src);
	}

/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function (process){\nmodule.exports = process.env.COV\n  ? require('./lib-cov/mocha')\n  : require('./lib/mocha');\n\n}).call(this,require('_process'))\n},{\"./lib-cov/mocha\":undefined,\"./lib/mocha\":14,\"_process\":51}],2:[function(require,module,exports){\n/* eslint-disable no-unused-vars */\nmodule.exports = function(type) {\n  return function() {};\n};\n\n},{}],3:[function(require,module,exports){\n/**\n * Module exports.\n */\n\nexports.EventEmitter = EventEmitter;\n\n/**\n * Object#hasOwnProperty reference.\n */\nvar objToString = Object.prototype.toString;\n\n/**\n * Check if a value is an array.\n *\n * @api private\n * @param {*} val The value to test.\n * @return {boolean} true if the value is a boolean, otherwise false.\n */\nfunction isArray(val) {\n  return objToString.call(val) === '[object Array]';\n}\n\n/**\n * Event emitter constructor.\n *\n * @api public\n */\nfunction EventEmitter() {}\n\n/**\n * Add a listener.\n *\n * @api public\n * @param {string} name Event name.\n * @param {Function} fn Event handler.\n * @return {EventEmitter} Emitter instance.\n */\nEventEmitter.prototype.on = function(name, fn) {\n  if (!this.$events) {\n    this.$events = {};\n  }\n\n  if (!this.$events[name]) {\n    this.$events[name] = fn;\n  } else if (isArray(this.$events[name])) {\n    this.$events[name].push(fn);\n  } else {\n    this.$events[name] = [this.$events[name], fn];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n/**\n * Adds a volatile listener.\n *\n * @api public\n * @param {string} name Event name.\n * @param {Function} fn Event handler.\n * @return {EventEmitter} Emitter instance.\n */\nEventEmitter.prototype.once = function(name, fn) {\n  var self = this;\n\n  function on() {\n    self.removeListener(name, on);\n    fn.apply(this, arguments);\n  }\n\n  on.listener = fn;\n  this.on(name, on);\n\n  return this;\n};\n\n/**\n * Remove a listener.\n *\n * @api public\n * @param {string} name Event name.\n * @param {Function} fn Event handler.\n * @return {EventEmitter} Emitter instance.\n */\nEventEmitter.prototype.removeListener = function(name, fn) {\n  if (this.$events && this.$events[name]) {\n    var list = this.$events[name];\n\n    if (isArray(list)) {\n      var pos = -1;\n\n      for (var i = 0, l = list.length; i < l; i++) {\n        if (list[i] === fn || (list[i].listener && list[i].listener === fn)) {\n          pos = i;\n          break;\n        }\n      }\n\n      if (pos < 0) {\n        return this;\n      }\n\n      list.splice(pos, 1);\n\n      if (!list.length) {\n        delete this.$events[name];\n      }\n    } else if (list === fn || (list.listener && list.listener === fn)) {\n      delete this.$events[name];\n    }\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners for an event.\n *\n * @api public\n * @param {string} name Event name.\n * @return {EventEmitter} Emitter instance.\n */\nEventEmitter.prototype.removeAllListeners = function(name) {\n  if (name === undefined) {\n    this.$events = {};\n    return this;\n  }\n\n  if (this.$events && this.$events[name]) {\n    this.$events[name] = null;\n  }\n\n  return this;\n};\n\n/**\n * Get all listeners for a given event.\n *\n * @api public\n * @param {string} name Event name.\n * @return {EventEmitter} Emitter instance.\n */\nEventEmitter.prototype.listeners = function(name) {\n  if (!this.$events) {\n    this.$events = {};\n  }\n\n  if (!this.$events[name]) {\n    this.$events[name] = [];\n  }\n\n  if (!isArray(this.$events[name])) {\n    this.$events[name] = [this.$events[name]];\n  }\n\n  return this.$events[name];\n};\n\n/**\n * Emit an event.\n *\n * @api public\n * @param {string} name Event name.\n * @return {boolean} true if at least one handler was invoked, else false.\n */\nEventEmitter.prototype.emit = function(name) {\n  if (!this.$events) {\n    return false;\n  }\n\n  var handler = this.$events[name];\n\n  if (!handler) {\n    return false;\n  }\n\n  var args = Array.prototype.slice.call(arguments, 1);\n\n  if (typeof handler === 'function') {\n    handler.apply(this, args);\n  } else if (isArray(handler)) {\n    var listeners = handler.slice();\n\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n  } else {\n    return false;\n  }\n\n  return true;\n};\n\n},{}],4:[function(require,module,exports){\n/**\n * Expose `Progress`.\n */\n\nmodule.exports = Progress;\n\n/**\n * Initialize a new `Progress` indicator.\n */\nfunction Progress() {\n  this.percent = 0;\n  this.size(0);\n  this.fontSize(11);\n  this.font('helvetica, arial, sans-serif');\n}\n\n/**\n * Set progress size to `size`.\n *\n * @api public\n * @param {number} size\n * @return {Progress} Progress instance.\n */\nProgress.prototype.size = function(size) {\n  this._size = size;\n  return this;\n};\n\n/**\n * Set text to `text`.\n *\n * @api public\n * @param {string} text\n * @return {Progress} Progress instance.\n */\nProgress.prototype.text = function(text) {\n  this._text = text;\n  return this;\n};\n\n/**\n * Set font size to `size`.\n *\n * @api public\n * @param {number} size\n * @return {Progress} Progress instance.\n */\nProgress.prototype.fontSize = function(size) {\n  this._fontSize = size;\n  return this;\n};\n\n/**\n * Set font to `family`.\n *\n * @param {string} family\n * @return {Progress} Progress instance.\n */\nProgress.prototype.font = function(family) {\n  this._font = family;\n  return this;\n};\n\n/**\n * Update percentage to `n`.\n *\n * @param {number} n\n * @return {Progress} Progress instance.\n */\nProgress.prototype.update = function(n) {\n  this.percent = n;\n  return this;\n};\n\n/**\n * Draw on `ctx`.\n *\n * @param {CanvasRenderingContext2d} ctx\n * @return {Progress} Progress instance.\n */\nProgress.prototype.draw = function(ctx) {\n  try {\n    var percent = Math.min(this.percent, 100);\n    var size = this._size;\n    var half = size / 2;\n    var x = half;\n    var y = half;\n    var rad = half - 1;\n    var fontSize = this._fontSize;\n\n    ctx.font = fontSize + 'px ' + this._font;\n\n    var angle = Math.PI * 2 * (percent / 100);\n    ctx.clearRect(0, 0, size, size);\n\n    // outer circle\n    ctx.strokeStyle = '#9f9f9f';\n    ctx.beginPath();\n    ctx.arc(x, y, rad, 0, angle, false);\n    ctx.stroke();\n\n    // inner circle\n    ctx.strokeStyle = '#eee';\n    ctx.beginPath();\n    ctx.arc(x, y, rad - 1, 0, angle, true);\n    ctx.stroke();\n\n    // text\n    var text = this._text || (percent | 0) + '%';\n    var w = ctx.measureText(text).width;\n\n    ctx.fillText(text, x - w / 2 + 1, y + fontSize / 2 - 1);\n  } catch (err) {\n    // don't fail if we can't render progress\n  }\n  return this;\n};\n\n},{}],5:[function(require,module,exports){\n(function (global){\nexports.isatty = function isatty() {\n  return true;\n};\n\nexports.getWindowSize = function getWindowSize() {\n  if ('innerHeight' in global) {\n    return [global.innerHeight, global.innerWidth];\n  }\n  // In a Web Worker, the DOM Window is not available.\n  return [640, 480];\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],6:[function(require,module,exports){\n/**\n * Expose `Context`.\n */\n\nmodule.exports = Context;\n\n/**\n * Initialize a new `Context`.\n *\n * @api private\n */\nfunction Context() {}\n\n/**\n * Set or get the context `Runnable` to `runnable`.\n *\n * @api private\n * @param {Runnable} runnable\n * @return {Context}\n */\nContext.prototype.runnable = function(runnable) {\n  if (!arguments.length) {\n    return this._runnable;\n  }\n  this.test = this._runnable = runnable;\n  return this;\n};\n\n/**\n * Set test timeout `ms`.\n *\n * @api private\n * @param {number} ms\n * @return {Context} self\n */\nContext.prototype.timeout = function(ms) {\n  if (!arguments.length) {\n    return this.runnable().timeout();\n  }\n  this.runnable().timeout(ms);\n  return this;\n};\n\n/**\n * Set test timeout `enabled`.\n *\n * @api private\n * @param {boolean} enabled\n * @return {Context} self\n */\nContext.prototype.enableTimeouts = function(enabled) {\n  this.runnable().enableTimeouts(enabled);\n  return this;\n};\n\n/**\n * Set test slowness threshold `ms`.\n *\n * @api private\n * @param {number} ms\n * @return {Context} self\n */\nContext.prototype.slow = function(ms) {\n  this.runnable().slow(ms);\n  return this;\n};\n\n/**\n * Mark a test as skipped.\n *\n * @api private\n * @return {Context} self\n */\nContext.prototype.skip = function() {\n  this.runnable().skip();\n  return this;\n};\n\n/**\n * Allow a number of retries on failed tests\n *\n * @api private\n * @param {number} n\n * @return {Context} self\n */\nContext.prototype.retries = function(n) {\n  if (!arguments.length) {\n    return this.runnable().retries();\n  }\n  this.runnable().retries(n);\n  return this;\n};\n\n/**\n * Inspect the context void of `._runnable`.\n *\n * @api private\n * @return {string}\n */\nContext.prototype.inspect = function() {\n  return JSON.stringify(this, function(key, val) {\n    return key === 'runnable' || key === 'test' ? undefined : val;\n  }, 2);\n};\n\n},{}],7:[function(require,module,exports){\n/**\n * Module dependencies.\n */\n\nvar Runnable = require('./runnable');\nvar inherits = require('./utils').inherits;\n\n/**\n * Expose `Hook`.\n */\n\nmodule.exports = Hook;\n\n/**\n * Initialize a new `Hook` with the given `title` and callback `fn`.\n *\n * @param {String} title\n * @param {Function} fn\n * @api private\n */\nfunction Hook(title, fn) {\n  Runnable.call(this, title, fn);\n  this.type = 'hook';\n}\n\n/**\n * Inherit from `Runnable.prototype`.\n */\ninherits(Hook, Runnable);\n\n/**\n * Get or set the test `err`.\n *\n * @param {Error} err\n * @return {Error}\n * @api public\n */\nHook.prototype.error = function(err) {\n  if (!arguments.length) {\n    err = this._error;\n    this._error = null;\n    return err;\n  }\n\n  this._error = err;\n};\n\n},{\"./runnable\":35,\"./utils\":39}],8:[function(require,module,exports){\n/**\n * Module dependencies.\n */\n\nvar Suite = require('../suite');\nvar Test = require('../test');\nvar escapeRe = require('escape-string-regexp');\n\n/**\n * BDD-style interface:\n *\n *      describe('Array', function() {\n *        describe('#indexOf()', function() {\n *          it('should return -1 when not present', function() {\n *            // ...\n *          });\n *\n *          it('should return the index when present', function() {\n *            // ...\n *          });\n *        });\n *      });\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function(suite) {\n  var suites = [suite];\n\n  suite.on('pre-require', function(context, file, mocha) {\n    var common = require('./common')(suites, context);\n\n    context.before = common.before;\n    context.after = common.after;\n    context.beforeEach = common.beforeEach;\n    context.afterEach = common.afterEach;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n    /**\n     * Describe a \"suite\" with the given `title`\n     * and callback `fn` containing nested suites\n     * and/or tests.\n     */\n\n    context.describe = context.context = function(title, fn) {\n      var suite = Suite.create(suites[0], title);\n      suite.file = file;\n      suites.unshift(suite);\n      fn.call(suite);\n      suites.shift();\n      return suite;\n    };\n\n    /**\n     * Pending describe.\n     */\n\n    context.xdescribe = context.xcontext = context.describe.skip = function(title, fn) {\n      var suite = Suite.create(suites[0], title);\n      suite.pending = true;\n      suites.unshift(suite);\n      fn.call(suite);\n      suites.shift();\n    };\n\n    /**\n     * Exclusive suite.\n     */\n\n    context.describe.only = function(title, fn) {\n      var suite = context.describe(title, fn);\n      mocha.grep(suite.fullTitle());\n      return suite;\n    };\n\n    /**\n     * Describe a specification or test-case\n     * with the given `title` and callback `fn`\n     * acting as a thunk.\n     */\n\n    var it = context.it = context.specify = function(title, fn) {\n      var suite = suites[0];\n      if (suite.pending) {\n        fn = null;\n      }\n      var test = new Test(title, fn);\n      test.file = file;\n      suite.addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.it.only = function(title, fn) {\n      var test = it(title, fn);\n      var reString = '^' + escapeRe(test.fullTitle()) + '$';\n      mocha.grep(new RegExp(reString));\n      return test;\n    };\n\n    /**\n     * Pending test case.\n     */\n\n    context.xit = context.xspecify = context.it.skip = function(title) {\n      context.it(title);\n    };\n\n    /**\n     * Number of attempts to retry.\n     */\n    context.it.retries = function(n) {\n      context.retries(n);\n    };\n  });\n};\n\n},{\"../suite\":37,\"../test\":38,\"./common\":9,\"escape-string-regexp\":68}],9:[function(require,module,exports){\n'use strict';\n\n/**\n * Functions common to more than one interface.\n *\n * @param {Suite[]} suites\n * @param {Context} context\n * @return {Object} An object containing common functions.\n */\nmodule.exports = function(suites, context) {\n  return {\n    /**\n     * This is only present if flag --delay is passed into Mocha. It triggers\n     * root suite execution.\n     *\n     * @param {Suite} suite The root wuite.\n     * @return {Function} A function which runs the root suite\n     */\n    runWithSuite: function runWithSuite(suite) {\n      return function run() {\n        suite.run();\n      };\n    },\n\n    /**\n     * Execute before running tests.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    before: function(name, fn) {\n      suites[0].beforeAll(name, fn);\n    },\n\n    /**\n     * Execute after running tests.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    after: function(name, fn) {\n      suites[0].afterAll(name, fn);\n    },\n\n    /**\n     * Execute before each test case.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    beforeEach: function(name, fn) {\n      suites[0].beforeEach(name, fn);\n    },\n\n    /**\n     * Execute after each test case.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    afterEach: function(name, fn) {\n      suites[0].afterEach(name, fn);\n    },\n\n    test: {\n      /**\n       * Pending test case.\n       *\n       * @param {string} title\n       */\n      skip: function(title) {\n        context.test(title);\n      },\n\n      /**\n       * Number of retry attempts\n       *\n       * @param {string} n\n       */\n      retries: function(n) {\n        context.retries(n);\n      }\n    }\n  };\n};\n\n},{}],10:[function(require,module,exports){\n/**\n * Module dependencies.\n */\n\nvar Suite = require('../suite');\nvar Test = require('../test');\n\n/**\n * TDD-style interface:\n *\n *     exports.Array = {\n *       '#indexOf()': {\n *         'should return -1 when the value is not present': function() {\n *\n *         },\n *\n *         'should return the correct index when the value is present': function() {\n *\n *         }\n *       }\n *     };\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function(suite) {\n  var suites = [suite];\n\n  suite.on('require', visit);\n\n  function visit(obj, file) {\n    var suite;\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        var fn = obj[key];\n        switch (key) {\n          case 'before':\n            suites[0].beforeAll(fn);\n            break;\n          case 'after':\n            suites[0].afterAll(fn);\n            break;\n          case 'beforeEach':\n            suites[0].beforeEach(fn);\n            break;\n          case 'afterEach':\n            suites[0].afterEach(fn);\n            break;\n          default:\n            var test = new Test(key, fn);\n            test.file = file;\n            suites[0].addTest(test);\n        }\n      } else {\n        suite = Suite.create(suites[0], key);\n        suites.unshift(suite);\n        visit(obj[key], file);\n        suites.shift();\n      }\n    }\n  }\n};\n\n},{\"../suite\":37,\"../test\":38}],11:[function(require,module,exports){\nexports.bdd = require('./bdd');\nexports.tdd = require('./tdd');\nexports.qunit = require('./qunit');\nexports.exports = require('./exports');\n\n},{\"./bdd\":8,\"./exports\":10,\"./qunit\":12,\"./tdd\":13}],12:[function(require,module,exports){\n/**\n * Module dependencies.\n */\n\nvar Suite = require('../suite');\nvar Test = require('../test');\nvar escapeRe = require('escape-string-regexp');\n\n/**\n * QUnit-style interface:\n *\n *     suite('Array');\n *\n *     test('#length', function() {\n *       var arr = [1,2,3];\n *       ok(arr.length == 3);\n *     });\n *\n *     test('#indexOf()', function() {\n *       var arr = [1,2,3];\n *       ok(arr.indexOf(1) == 0);\n *       ok(arr.indexOf(2) == 1);\n *       ok(arr.indexOf(3) == 2);\n *     });\n *\n *     suite('String');\n *\n *     test('#length', function() {\n *       ok('foo'.length == 3);\n *     });\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function(suite) {\n  var suites = [suite];\n\n  suite.on('pre-require', function(context, file, mocha) {\n    var common = require('./common')(suites, context);\n\n    context.before = common.before;\n    context.after = common.after;\n    context.beforeEach = common.beforeEach;\n    context.afterEach = common.afterEach;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n    /**\n     * Describe a \"suite\" with the given `title`.\n     */\n\n    context.suite = function(title) {\n      if (suites.length > 1) {\n        suites.shift();\n      }\n      var suite = Suite.create(suites[0], title);\n      suite.file = file;\n      suites.unshift(suite);\n      return suite;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.suite.only = function(title, fn) {\n      var suite = context.suite(title, fn);\n      mocha.grep(suite.fullTitle());\n    };\n\n    /**\n     * Describe a specification or test-case\n     * with the given `title` and callback `fn`\n     * acting as a thunk.\n     */\n\n    context.test = function(title, fn) {\n      var test = new Test(title, fn);\n      test.file = file;\n      suites[0].addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.test.only = function(title, fn) {\n      var test = context.test(title, fn);\n      var reString = '^' + escapeRe(test.fullTitle()) + '$';\n      mocha.grep(new RegExp(reString));\n    };\n\n    context.test.skip = common.test.skip;\n    context.test.retries = common.test.retries;\n  });\n};\n\n},{\"../suite\":37,\"../test\":38,\"./common\":9,\"escape-string-regexp\":68}],13:[function(require,module,exports){\n/**\n * Module dependencies.\n */\n\nvar Suite = require('../suite');\nvar Test = require('../test');\nvar escapeRe = require('escape-string-regexp');\n\n/**\n * TDD-style interface:\n *\n *      suite('Array', function() {\n *        suite('#indexOf()', function() {\n *          suiteSetup(function() {\n *\n *          });\n *\n *          test('should return -1 when not present', function() {\n *\n *          });\n *\n *          test('should return the index when present', function() {\n *\n *          });\n *\n *          suiteTeardown(function() {\n *\n *          });\n *        });\n *      });\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function(suite) {\n  var suites = [suite];\n\n  suite.on('pre-require', function(context, file, mocha) {\n    var common = require('./common')(suites, context);\n\n    context.setup = common.beforeEach;\n    context.teardown = common.afterEach;\n    context.suiteSetup = common.before;\n    context.suiteTeardown = common.after;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n\n    /**\n     * Describe a \"suite\" with the given `title` and callback `fn` containing\n     * nested suites and/or tests.\n     */\n    context.suite = function(title, fn) {\n      var suite = Suite.create(suites[0], title);\n      suite.file = file;\n      suites.unshift(suite);\n      fn.call(suite);\n      suites.shift();\n      return suite;\n    };\n\n    /**\n     * Pending suite.\n     */\n    context.suite.skip = function(title, fn) {\n      var suite = Suite.create(suites[0], title);\n      suite.pending = true;\n      suites.unshift(suite);\n      fn.call(suite);\n      suites.shift();\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n    context.suite.only = function(title, fn) {\n      var suite = context.suite(title, fn);\n      mocha.grep(suite.fullTitle());\n    };\n\n    /**\n     * Describe a specification or test-case with the given `title` and\n     * callback `fn` acting as a thunk.\n     */\n    context.test = function(title, fn) {\n      var suite = suites[0];\n      if (suite.pending) {\n        fn = null;\n      }\n      var test = new Test(title, fn);\n      test.file = file;\n      suite.addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.test.only = function(title, fn) {\n      var test = context.test(title, fn);\n      var reString = '^' + escapeRe(test.fullTitle()) + '$';\n      mocha.grep(new RegExp(reString));\n    };\n\n    context.test.skip = common.test.skip;\n    context.test.retries = common.test.retries;\n  });\n};\n\n},{\"../suite\":37,\"../test\":38,\"./common\":9,\"escape-string-regexp\":68}],14:[function(require,module,exports){\n(function (process,global,__dirname){\n/*!\n * mocha\n * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar escapeRe = require('escape-string-regexp');\nvar path = require('path');\nvar reporters = require('./reporters');\nvar utils = require('./utils');\n\n/**\n * Expose `Mocha`.\n */\n\nexports = module.exports = Mocha;\n\n/**\n * To require local UIs and reporters when running in node.\n */\n\nif (!process.browser) {\n  var cwd = process.cwd();\n  module.paths.push(cwd, path.join(cwd, 'node_modules'));\n}\n\n/**\n * Expose internals.\n */\n\nexports.utils = utils;\nexports.interfaces = require('./interfaces');\nexports.reporters = reporters;\nexports.Runnable = require('./runnable');\nexports.Context = require('./context');\nexports.Runner = require('./runner');\nexports.Suite = require('./suite');\nexports.Hook = require('./hook');\nexports.Test = require('./test');\n\n/**\n * Return image `name` path.\n *\n * @api private\n * @param {string} name\n * @return {string}\n */\nfunction image(name) {\n  return path.join(__dirname, '../images', name + '.png');\n}\n\n/**\n * Set up mocha with `options`.\n *\n * Options:\n *\n *   - `ui` name \"bdd\", \"tdd\", \"exports\" etc\n *   - `reporter` reporter instance, defaults to `mocha.reporters.spec`\n *   - `globals` array of accepted globals\n *   - `timeout` timeout in milliseconds\n *   - `retries` number of times to retry failed tests\n *   - `bail` bail on the first test failure\n *   - `slow` milliseconds to wait before considering a test slow\n *   - `ignoreLeaks` ignore global leaks\n *   - `fullTrace` display the full stack-trace on failing\n *   - `grep` string or regexp to filter tests with\n *\n * @param {Object} options\n * @api public\n */\nfunction Mocha(options) {\n  options = options || {};\n  this.files = [];\n  this.options = options;\n  if (options.grep) {\n    this.grep(new RegExp(options.grep));\n  }\n  if (options.fgrep) {\n    this.grep(options.fgrep);\n  }\n  this.suite = new exports.Suite('', new exports.Context());\n  this.ui(options.ui);\n  this.bail(options.bail);\n  this.reporter(options.reporter, options.reporterOptions);\n  if (typeof options.timeout !== 'undefined' && options.timeout !== null) {\n    this.timeout(options.timeout);\n  }\n  if (typeof options.retries !== 'undefined' && options.retries !== null) {\n    this.retries(options.retries);\n  }\n  this.useColors(options.useColors);\n  if (options.enableTimeouts !== null) {\n    this.enableTimeouts(options.enableTimeouts);\n  }\n  if (options.slow) {\n    this.slow(options.slow);\n  }\n\n  this.suite.on('pre-require', function(context) {\n    exports.afterEach = context.afterEach || context.teardown;\n    exports.after = context.after || context.suiteTeardown;\n    exports.beforeEach = context.beforeEach || context.setup;\n    exports.before = context.before || context.suiteSetup;\n    exports.describe = context.describe || context.suite;\n    exports.it = context.it || context.test;\n    exports.setup = context.setup || context.beforeEach;\n    exports.suiteSetup = context.suiteSetup || context.before;\n    exports.suiteTeardown = context.suiteTeardown || context.after;\n    exports.suite = context.suite || context.describe;\n    exports.teardown = context.teardown || context.afterEach;\n    exports.test = context.test || context.it;\n    exports.run = context.run;\n  });\n}\n\n/**\n * Enable or disable bailing on the first failure.\n *\n * @api public\n * @param {boolean} [bail]\n */\nMocha.prototype.bail = function(bail) {\n  if (!arguments.length) {\n    bail = true;\n  }\n  this.suite.bail(bail);\n  return this;\n};\n\n/**\n * Add test `file`.\n *\n * @api public\n * @param {string} file\n */\nMocha.prototype.addFile = function(file) {\n  this.files.push(file);\n  return this;\n};\n\n/**\n * Set reporter to `reporter`, defaults to \"spec\".\n *\n * @param {String|Function} reporter name or constructor\n * @param {Object} reporterOptions optional options\n * @api public\n * @param {string|Function} reporter name or constructor\n * @param {Object} reporterOptions optional options\n */\nMocha.prototype.reporter = function(reporter, reporterOptions) {\n  if (typeof reporter === 'function') {\n    this._reporter = reporter;\n  } else {\n    reporter = reporter || 'spec';\n    var _reporter;\n    // Try to load a built-in reporter.\n    if (reporters[reporter]) {\n      _reporter = reporters[reporter];\n    }\n    // Try to load reporters from process.cwd() and node_modules\n    if (!_reporter) {\n      try {\n        _reporter = require(reporter);\n      } catch (err) {\n        err.message.indexOf('Cannot find module') !== -1\n          ? console.warn('\"' + reporter + '\" reporter not found')\n          : console.warn('\"' + reporter + '\" reporter blew up with error:\\n' + err.stack);\n      }\n    }\n    if (!_reporter && reporter === 'teamcity') {\n      console.warn('The Teamcity reporter was moved to a package named '\n        + 'mocha-teamcity-reporter '\n        + '(https://npmjs.org/package/mocha-teamcity-reporter).');\n    }\n    if (!_reporter) {\n      throw new Error('invalid reporter \"' + reporter + '\"');\n    }\n    this._reporter = _reporter;\n  }\n  this.options.reporterOptions = reporterOptions;\n  return this;\n};\n\n/**\n * Set test UI `name`, defaults to \"bdd\".\n *\n * @api public\n * @param {string} bdd\n */\nMocha.prototype.ui = function(name) {\n  name = name || 'bdd';\n  this._ui = exports.interfaces[name];\n  if (!this._ui) {\n    try {\n      this._ui = require(name);\n    } catch (err) {\n      throw new Error('invalid interface \"' + name + '\"');\n    }\n  }\n  this._ui = this._ui(this.suite);\n  return this;\n};\n\n/**\n * Load registered files.\n *\n * @api private\n */\nMocha.prototype.loadFiles = function(fn) {\n  var self = this;\n  var suite = this.suite;\n  this.files.forEach(function(file) {\n    file = path.resolve(file);\n    suite.emit('pre-require', global, file, self);\n    suite.emit('require', require(file), file, self);\n    suite.emit('post-require', global, file, self);\n  });\n  fn && fn();\n};\n\n/**\n * Enable growl support.\n *\n * @api private\n */\nMocha.prototype._growl = function(runner, reporter) {\n  var notify = require('growl');\n\n  runner.on('end', function() {\n    var stats = reporter.stats;\n    if (stats.failures) {\n      var msg = stats.failures + ' of ' + runner.total + ' tests failed';\n      notify(msg, { name: 'mocha', title: 'Failed', image: image('error') });\n    } else {\n      notify(stats.passes + ' tests passed in ' + stats.duration + 'ms', {\n        name: 'mocha',\n        title: 'Passed',\n        image: image('ok')\n      });\n    }\n  });\n};\n\n/**\n * Add regexp to grep, if `re` is a string it is escaped.\n *\n * @param {RegExp|String} re\n * @return {Mocha}\n * @api public\n * @param {RegExp|string} re\n * @return {Mocha}\n */\nMocha.prototype.grep = function(re) {\n  this.options.grep = typeof re === 'string' ? new RegExp(escapeRe(re)) : re;\n  return this;\n};\n\n/**\n * Invert `.grep()` matches.\n *\n * @return {Mocha}\n * @api public\n */\nMocha.prototype.invert = function() {\n  this.options.invert = true;\n  return this;\n};\n\n/**\n * Ignore global leaks.\n *\n * @param {Boolean} ignore\n * @return {Mocha}\n * @api public\n * @param {boolean} ignore\n * @return {Mocha}\n */\nMocha.prototype.ignoreLeaks = function(ignore) {\n  this.options.ignoreLeaks = Boolean(ignore);\n  return this;\n};\n\n/**\n * Enable global leak checking.\n *\n * @return {Mocha}\n * @api public\n */\nMocha.prototype.checkLeaks = function() {\n  this.options.ignoreLeaks = false;\n  return this;\n};\n\n/**\n * Display long stack-trace on failing\n *\n * @return {Mocha}\n * @api public\n */\nMocha.prototype.fullTrace = function() {\n  this.options.fullStackTrace = true;\n  return this;\n};\n\n/**\n * Enable growl support.\n *\n * @return {Mocha}\n * @api public\n */\nMocha.prototype.growl = function() {\n  this.options.growl = true;\n  return this;\n};\n\n/**\n * Ignore `globals` array or string.\n *\n * @param {Array|String} globals\n * @return {Mocha}\n * @api public\n * @param {Array|string} globals\n * @return {Mocha}\n */\nMocha.prototype.globals = function(globals) {\n  this.options.globals = (this.options.globals || []).concat(globals);\n  return this;\n};\n\n/**\n * Emit color output.\n *\n * @param {Boolean} colors\n * @return {Mocha}\n * @api public\n * @param {boolean} colors\n * @return {Mocha}\n */\nMocha.prototype.useColors = function(colors) {\n  if (colors !== undefined) {\n    this.options.useColors = colors;\n  }\n  return this;\n};\n\n/**\n * Use inline diffs rather than +/-.\n *\n * @param {Boolean} inlineDiffs\n * @return {Mocha}\n * @api public\n * @param {boolean} inlineDiffs\n * @return {Mocha}\n */\nMocha.prototype.useInlineDiffs = function(inlineDiffs) {\n  this.options.useInlineDiffs = inlineDiffs !== undefined && inlineDiffs;\n  return this;\n};\n\n/**\n * Set the timeout in milliseconds.\n *\n * @param {Number} timeout\n * @return {Mocha}\n * @api public\n * @param {number} timeout\n * @return {Mocha}\n */\nMocha.prototype.timeout = function(timeout) {\n  this.suite.timeout(timeout);\n  return this;\n};\n\n/**\n * Set the number of times to retry failed tests.\n *\n * @param {Number} retry times\n * @return {Mocha}\n * @api public\n */\nMocha.prototype.retries = function(n) {\n  this.suite.retries(n);\n  return this;\n};\n\n/**\n * Set slowness threshold in milliseconds.\n *\n * @param {Number} slow\n * @return {Mocha}\n * @api public\n * @param {number} slow\n * @return {Mocha}\n */\nMocha.prototype.slow = function(slow) {\n  this.suite.slow(slow);\n  return this;\n};\n\n/**\n * Enable timeouts.\n *\n * @param {Boolean} enabled\n * @return {Mocha}\n * @api public\n * @param {boolean} enabled\n * @return {Mocha}\n */\nMocha.prototype.enableTimeouts = function(enabled) {\n  this.suite.enableTimeouts(arguments.length && enabled !== undefined ? enabled : true);\n  return this;\n};\n\n/**\n * Makes all tests async (accepting a callback)\n *\n * @return {Mocha}\n * @api public\n */\nMocha.prototype.asyncOnly = function() {\n  this.options.asyncOnly = true;\n  return this;\n};\n\n/**\n * Disable syntax highlighting (in browser).\n *\n * @api public\n */\nMocha.prototype.noHighlighting = function() {\n  this.options.noHighlighting = true;\n  return this;\n};\n\n/**\n * Enable uncaught errors to propagate (in browser).\n *\n * @return {Mocha}\n * @api public\n */\nMocha.prototype.allowUncaught = function() {\n  this.options.allowUncaught = true;\n  return this;\n};\n\n/**\n * Delay root suite execution.\n * @returns {Mocha}\n */\nMocha.prototype.delay = function delay() {\n  this.options.delay = true;\n  return this;\n};\n\n/**\n * Run tests and invoke `fn()` when complete.\n *\n * @api public\n * @param {Function} fn\n * @return {Runner}\n */\nMocha.prototype.run = function(fn) {\n  if (this.files.length) {\n    this.loadFiles();\n  }\n  var suite = this.suite;\n  var options = this.options;\n  options.files = this.files;\n  var runner = new exports.Runner(suite, options.delay);\n  var reporter = new this._reporter(runner, options);\n  runner.ignoreLeaks = options.ignoreLeaks !== false;\n  runner.fullStackTrace = options.fullStackTrace;\n  runner.asyncOnly = options.asyncOnly;\n  runner.allowUncaught = options.allowUncaught;\n  if (options.grep) {\n    runner.grep(options.grep, options.invert);\n  }\n  if (options.globals) {\n    runner.globals(options.globals);\n  }\n  if (options.growl) {\n    this._growl(runner, reporter);\n  }\n  if (options.useColors !== undefined) {\n    exports.reporters.Base.useColors = options.useColors;\n  }\n  exports.reporters.Base.inlineDiffs = options.useInlineDiffs;\n\n  function done(failures) {\n    if (reporter.done) {\n      reporter.done(failures, fn);\n    } else {\n      fn && fn(failures);\n    }\n  }\n\n  return runner.run(done);\n};\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},\"/lib\")\n},{\"./context\":6,\"./hook\":7,\"./interfaces\":11,\"./reporters\":22,\"./runnable\":35,\"./runner\":36,\"./suite\":37,\"./test\":38,\"./utils\":39,\"_process\":51,\"escape-string-regexp\":68,\"growl\":69,\"path\":41}],15:[function(require,module,exports){\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @api public\n * @param {string|number} val\n * @param {Object} options\n * @return {string|number}\n */\nmodule.exports = function(val, options) {\n  options = options || {};\n  if (typeof val === 'string') {\n    return parse(val);\n  }\n  // https://github.com/mochajs/mocha/pull/1035\n  return options['long'] ? longFormat(val) : shortFormat(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @api private\n * @param {string} str\n * @return {number}\n */\nfunction parse(str) {\n  var match = (/^((?:\\d+)?\\.?\\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i).exec(str);\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 's':\n      return n * s;\n    case 'ms':\n      return n;\n    default:\n      // No default case\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @api private\n * @param {number} ms\n * @return {string}\n */\nfunction shortFormat(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @api private\n * @param {number} ms\n * @return {string}\n */\nfunction longFormat(ms) {\n  return plural(ms, d, 'day')\n    || plural(ms, h, 'hour')\n    || plural(ms, m, 'minute')\n    || plural(ms, s, 'second')\n    || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n *\n * @api private\n * @param {number} ms\n * @param {number} n\n * @param {string} name\n */\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n},{}],16:[function(require,module,exports){\n\n/**\n * Expose `Pending`.\n */\n\nmodule.exports = Pending;\n\n/**\n * Initialize a new `Pending` error with the given message.\n *\n * @param {string} message\n */\nfunction Pending(message) {\n  this.message = message;\n}\n\n},{}],17:[function(require,module,exports){\n(function (process,global){\n/**\n * Module dependencies.\n */\n\nvar tty = require('tty');\nvar diff = require('diff');\nvar ms = require('../ms');\nvar utils = require('../utils');\nvar supportsColor = process.browser ? null : require('supports-color');\n\n/**\n * Expose `Base`.\n */\n\nexports = module.exports = Base;\n\n/**\n * Save timer references to avoid Sinon interfering.\n * See: https://github.com/mochajs/mocha/issues/237\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\n/**\n * Check if both stdio streams are associated with a tty.\n */\n\nvar isatty = tty.isatty(1) && tty.isatty(2);\n\n/**\n * Enable coloring by default, except in the browser interface.\n */\n\nexports.useColors = !process.browser && (supportsColor || (process.env.MOCHA_COLORS !== undefined));\n\n/**\n * Inline diffs instead of +/-\n */\n\nexports.inlineDiffs = false;\n\n/**\n * Default color map.\n */\n\nexports.colors = {\n  pass: 90,\n  fail: 31,\n  'bright pass': 92,\n  'bright fail': 91,\n  'bright yellow': 93,\n  pending: 36,\n  suite: 0,\n  'error title': 0,\n  'error message': 31,\n  'error stack': 90,\n  checkmark: 32,\n  fast: 90,\n  medium: 33,\n  slow: 31,\n  green: 32,\n  light: 90,\n  'diff gutter': 90,\n  'diff added': 32,\n  'diff removed': 31\n};\n\n/**\n * Default symbol map.\n */\n\nexports.symbols = {\n  ok: '✓',\n  err: '✖',\n  dot: '․'\n};\n\n// With node.js on Windows: use symbols available in terminal default fonts\nif (process.platform === 'win32') {\n  exports.symbols.ok = '\\u221A';\n  exports.symbols.err = '\\u00D7';\n  exports.symbols.dot = '.';\n}\n\n/**\n * Color `str` with the given `type`,\n * allowing colors to be disabled,\n * as well as user-defined color\n * schemes.\n *\n * @param {string} type\n * @param {string} str\n * @return {string}\n * @api private\n */\nvar color = exports.color = function(type, str) {\n  if (!exports.useColors) {\n    return String(str);\n  }\n  return '\\u001b[' + exports.colors[type] + 'm' + str + '\\u001b[0m';\n};\n\n/**\n * Expose term window size, with some defaults for when stderr is not a tty.\n */\n\nexports.window = {\n  width: 75\n};\n\nif (isatty) {\n  exports.window.width = process.stdout.getWindowSize\n      ? process.stdout.getWindowSize(1)[0]\n      : tty.getWindowSize()[1];\n}\n\n/**\n * Expose some basic cursor interactions that are common among reporters.\n */\n\nexports.cursor = {\n  hide: function() {\n    isatty && process.stdout.write('\\u001b[?25l');\n  },\n\n  show: function() {\n    isatty && process.stdout.write('\\u001b[?25h');\n  },\n\n  deleteLine: function() {\n    isatty && process.stdout.write('\\u001b[2K');\n  },\n\n  beginningOfLine: function() {\n    isatty && process.stdout.write('\\u001b[0G');\n  },\n\n  CR: function() {\n    if (isatty) {\n      exports.cursor.deleteLine();\n      exports.cursor.beginningOfLine();\n    } else {\n      process.stdout.write('\\r');\n    }\n  }\n};\n\n/**\n * Outut the given `failures` as a list.\n *\n * @param {Array} failures\n * @api public\n */\n\nexports.list = function(failures) {\n  console.log();\n  failures.forEach(function(test, i) {\n    // format\n    var fmt = color('error title', '  %s) %s:\\n')\n      + color('error message', '     %s')\n      + color('error stack', '\\n%s\\n');\n\n    // msg\n    var msg;\n    var err = test.err;\n    var message;\n    if (err.message) {\n      message = err.message;\n    } else if (typeof err.inspect === 'function') {\n      message = err.inspect() + '';\n    } else {\n      message = '';\n    }\n    var stack = err.stack || message;\n    var index = stack.indexOf(message);\n    var actual = err.actual;\n    var expected = err.expected;\n    var escape = true;\n\n    if (index === -1) {\n      msg = message;\n    } else {\n      index += message.length;\n      msg = stack.slice(0, index);\n      // remove msg from stack\n      stack = stack.slice(index + 1);\n    }\n\n    // uncaught\n    if (err.uncaught) {\n      msg = 'Uncaught ' + msg;\n    }\n    // explicitly show diff\n    if (err.showDiff !== false && sameType(actual, expected) && expected !== undefined) {\n      escape = false;\n      if (!(utils.isString(actual) && utils.isString(expected))) {\n        err.actual = actual = utils.stringify(actual);\n        err.expected = expected = utils.stringify(expected);\n      }\n\n      fmt = color('error title', '  %s) %s:\\n%s') + color('error stack', '\\n%s\\n');\n      var match = message.match(/^([^:]+): expected/);\n      msg = '\\n      ' + color('error message', match ? match[1] : msg);\n\n      if (exports.inlineDiffs) {\n        msg += inlineDiff(err, escape);\n      } else {\n        msg += unifiedDiff(err, escape);\n      }\n    }\n\n    // indent stack trace\n    stack = stack.replace(/^/gm, '  ');\n\n    console.log(fmt, (i + 1), test.fullTitle(), msg, stack);\n  });\n};\n\n/**\n * Initialize a new `Base` reporter.\n *\n * All other reporters generally\n * inherit from this reporter, providing\n * stats such as test duration, number\n * of tests passed / failed etc.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction Base(runner) {\n  var stats = this.stats = { suites: 0, tests: 0, passes: 0, pending: 0, failures: 0 };\n  var failures = this.failures = [];\n\n  if (!runner) {\n    return;\n  }\n  this.runner = runner;\n\n  runner.stats = stats;\n\n  runner.on('start', function() {\n    stats.start = new Date();\n  });\n\n  runner.on('suite', function(suite) {\n    stats.suites = stats.suites || 0;\n    suite.root || stats.suites++;\n  });\n\n  runner.on('test end', function() {\n    stats.tests = stats.tests || 0;\n    stats.tests++;\n  });\n\n  runner.on('pass', function(test) {\n    stats.passes = stats.passes || 0;\n\n    if (test.duration > test.slow()) {\n      test.speed = 'slow';\n    } else if (test.duration > test.slow() / 2) {\n      test.speed = 'medium';\n    } else {\n      test.speed = 'fast';\n    }\n\n    stats.passes++;\n  });\n\n  runner.on('fail', function(test, err) {\n    stats.failures = stats.failures || 0;\n    stats.failures++;\n    test.err = err;\n    failures.push(test);\n  });\n\n  runner.on('end', function() {\n    stats.end = new Date();\n    stats.duration = new Date() - stats.start;\n  });\n\n  runner.on('pending', function() {\n    stats.pending++;\n  });\n}\n\n/**\n * Output common epilogue used by many of\n * the bundled reporters.\n *\n * @api public\n */\nBase.prototype.epilogue = function() {\n  var stats = this.stats;\n  var fmt;\n\n  console.log();\n\n  // passes\n  fmt = color('bright pass', ' ')\n    + color('green', ' %d passing')\n    + color('light', ' (%s)');\n\n  console.log(fmt,\n    stats.passes || 0,\n    ms(stats.duration));\n\n  // pending\n  if (stats.pending) {\n    fmt = color('pending', ' ')\n      + color('pending', ' %d pending');\n\n    console.log(fmt, stats.pending);\n  }\n\n  // failures\n  if (stats.failures) {\n    fmt = color('fail', '  %d failing');\n\n    console.log(fmt, stats.failures);\n\n    Base.list(this.failures);\n    console.log();\n  }\n\n  console.log();\n};\n\n/**\n * Pad the given `str` to `len`.\n *\n * @api private\n * @param {string} str\n * @param {string} len\n * @return {string}\n */\nfunction pad(str, len) {\n  str = String(str);\n  return Array(len - str.length + 1).join(' ') + str;\n}\n\n/**\n * Returns an inline diff between 2 strings with coloured ANSI output\n *\n * @api private\n * @param {Error} err with actual/expected\n * @param {boolean} escape\n * @return {string} Diff\n */\nfunction inlineDiff(err, escape) {\n  var msg = errorDiff(err, 'WordsWithSpace', escape);\n\n  // linenos\n  var lines = msg.split('\\n');\n  if (lines.length > 4) {\n    var width = String(lines.length).length;\n    msg = lines.map(function(str, i) {\n      return pad(++i, width) + ' |' + ' ' + str;\n    }).join('\\n');\n  }\n\n  // legend\n  msg = '\\n'\n    + color('diff removed', 'actual')\n    + ' '\n    + color('diff added', 'expected')\n    + '\\n\\n'\n    + msg\n    + '\\n';\n\n  // indent\n  msg = msg.replace(/^/gm, '      ');\n  return msg;\n}\n\n/**\n * Returns a unified diff between two strings.\n *\n * @api private\n * @param {Error} err with actual/expected\n * @param {boolean} escape\n * @return {string} The diff.\n */\nfunction unifiedDiff(err, escape) {\n  var indent = '      ';\n  function cleanUp(line) {\n    if (escape) {\n      line = escapeInvisibles(line);\n    }\n    if (line[0] === '+') {\n      return indent + colorLines('diff added', line);\n    }\n    if (line[0] === '-') {\n      return indent + colorLines('diff removed', line);\n    }\n    if (line.match(/\\@\\@/)) {\n      return null;\n    }\n    if (line.match(/\\\\ No newline/)) {\n      return null;\n    }\n    return indent + line;\n  }\n  function notBlank(line) {\n    return typeof line !== 'undefined' && line !== null;\n  }\n  var msg = diff.createPatch('string', err.actual, err.expected);\n  var lines = msg.split('\\n').splice(4);\n  return '\\n      '\n    + colorLines('diff added', '+ expected') + ' '\n    + colorLines('diff removed', '- actual')\n    + '\\n\\n'\n    + lines.map(cleanUp).filter(notBlank).join('\\n');\n}\n\n/**\n * Return a character diff for `err`.\n *\n * @api private\n * @param {Error} err\n * @param {string} type\n * @param {boolean} escape\n * @return {string}\n */\nfunction errorDiff(err, type, escape) {\n  var actual = escape ? escapeInvisibles(err.actual) : err.actual;\n  var expected = escape ? escapeInvisibles(err.expected) : err.expected;\n  return diff['diff' + type](actual, expected).map(function(str) {\n    if (str.added) {\n      return colorLines('diff added', str.value);\n    }\n    if (str.removed) {\n      return colorLines('diff removed', str.value);\n    }\n    return str.value;\n  }).join('');\n}\n\n/**\n * Returns a string with all invisible characters in plain text\n *\n * @api private\n * @param {string} line\n * @return {string}\n */\nfunction escapeInvisibles(line) {\n  return line.replace(/\\t/g, '<tab>')\n    .replace(/\\r/g, '<CR>')\n    .replace(/\\n/g, '<LF>\\n');\n}\n\n/**\n * Color lines for `str`, using the color `name`.\n *\n * @api private\n * @param {string} name\n * @param {string} str\n * @return {string}\n */\nfunction colorLines(name, str) {\n  return str.split('\\n').map(function(str) {\n    return color(name, str);\n  }).join('\\n');\n}\n\n/**\n * Object#toString reference.\n */\nvar objToString = Object.prototype.toString;\n\n/**\n * Check that a / b have the same type.\n *\n * @api private\n * @param {Object} a\n * @param {Object} b\n * @return {boolean}\n */\nfunction sameType(a, b) {\n  return objToString.call(a) === objToString.call(b);\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../ms\":15,\"../utils\":39,\"_process\":51,\"diff\":67,\"supports-color\":41,\"tty\":5}],18:[function(require,module,exports){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar utils = require('../utils');\n\n/**\n * Expose `Doc`.\n */\n\nexports = module.exports = Doc;\n\n/**\n * Initialize a new `Doc` reporter.\n *\n * @param {Runner} runner\n * @api public\n */\nfunction Doc(runner) {\n  Base.call(this, runner);\n\n  var indents = 2;\n\n  function indent() {\n    return Array(indents).join('  ');\n  }\n\n  runner.on('suite', function(suite) {\n    if (suite.root) {\n      return;\n    }\n    ++indents;\n    console.log('%s<section class=\"suite\">', indent());\n    ++indents;\n    console.log('%s<h1>%s</h1>', indent(), utils.escape(suite.title));\n    console.log('%s<dl>', indent());\n  });\n\n  runner.on('suite end', function(suite) {\n    if (suite.root) {\n      return;\n    }\n    console.log('%s</dl>', indent());\n    --indents;\n    console.log('%s</section>', indent());\n    --indents;\n  });\n\n  runner.on('pass', function(test) {\n    console.log('%s  <dt>%s</dt>', indent(), utils.escape(test.title));\n    var code = utils.escape(utils.clean(test.body));\n    console.log('%s  <dd><pre><code>%s</code></pre></dd>', indent(), code);\n  });\n\n  runner.on('fail', function(test, err) {\n    console.log('%s  <dt class=\"error\">%s</dt>', indent(), utils.escape(test.title));\n    var code = utils.escape(utils.clean(test.fn.body));\n    console.log('%s  <dd class=\"error\"><pre><code>%s</code></pre></dd>', indent(), code);\n    console.log('%s  <dd class=\"error\">%s</dd>', indent(), utils.escape(err));\n  });\n}\n\n},{\"../utils\":39,\"./base\":17}],19:[function(require,module,exports){\n(function (process){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar color = Base.color;\n\n/**\n * Expose `Dot`.\n */\n\nexports = module.exports = Dot;\n\n/**\n * Initialize a new `Dot` matrix test reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction Dot(runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var width = Base.window.width * .75 | 0;\n  var n = -1;\n\n  runner.on('start', function() {\n    process.stdout.write('\\n');\n  });\n\n  runner.on('pending', function() {\n    if (++n % width === 0) {\n      process.stdout.write('\\n  ');\n    }\n    process.stdout.write(color('pending', Base.symbols.dot));\n  });\n\n  runner.on('pass', function(test) {\n    if (++n % width === 0) {\n      process.stdout.write('\\n  ');\n    }\n    if (test.speed === 'slow') {\n      process.stdout.write(color('bright yellow', Base.symbols.dot));\n    } else {\n      process.stdout.write(color(test.speed, Base.symbols.dot));\n    }\n  });\n\n  runner.on('fail', function() {\n    if (++n % width === 0) {\n      process.stdout.write('\\n  ');\n    }\n    process.stdout.write(color('fail', Base.symbols.dot));\n  });\n\n  runner.on('end', function() {\n    console.log();\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Dot, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":39,\"./base\":17,\"_process\":51}],20:[function(require,module,exports){\n(function (process,__dirname){\n/**\n * Module dependencies.\n */\n\nvar JSONCov = require('./json-cov');\nvar readFileSync = require('fs').readFileSync;\nvar join = require('path').join;\n\n/**\n * Expose `HTMLCov`.\n */\n\nexports = module.exports = HTMLCov;\n\n/**\n * Initialize a new `JsCoverage` reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction HTMLCov(runner) {\n  var jade = require('jade');\n  var file = join(__dirname, '/templates/coverage.jade');\n  var str = readFileSync(file, 'utf8');\n  var fn = jade.compile(str, { filename: file });\n  var self = this;\n\n  JSONCov.call(this, runner, false);\n\n  runner.on('end', function() {\n    process.stdout.write(fn({\n      cov: self.cov,\n      coverageClass: coverageClass\n    }));\n  });\n}\n\n/**\n * Return coverage class for a given coverage percentage.\n *\n * @api private\n * @param {number} coveragePctg\n * @return {string}\n */\nfunction coverageClass(coveragePctg) {\n  if (coveragePctg >= 75) {\n    return 'high';\n  }\n  if (coveragePctg >= 50) {\n    return 'medium';\n  }\n  if (coveragePctg >= 25) {\n    return 'low';\n  }\n  return 'terrible';\n}\n\n}).call(this,require('_process'),\"/lib/reporters\")\n},{\"./json-cov\":23,\"_process\":51,\"fs\":41,\"jade\":41,\"path\":41}],21:[function(require,module,exports){\n(function (global){\n/* eslint-env browser */\n\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar utils = require('../utils');\nvar Progress = require('../browser/progress');\nvar escapeRe = require('escape-string-regexp');\nvar escape = utils.escape;\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\n/**\n * Expose `HTML`.\n */\n\nexports = module.exports = HTML;\n\n/**\n * Stats template.\n */\n\nvar statsTemplate = '<ul id=\"mocha-stats\">'\n  + '<li class=\"progress\"><canvas width=\"40\" height=\"40\"></canvas></li>'\n  + '<li class=\"passes\"><a href=\"javascript:void(0);\">passes:</a> <em>0</em></li>'\n  + '<li class=\"failures\"><a href=\"javascript:void(0);\">failures:</a> <em>0</em></li>'\n  + '<li class=\"duration\">duration: <em>0</em>s</li>'\n  + '</ul>';\n\n/**\n * Initialize a new `HTML` reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction HTML(runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var stats = this.stats;\n  var stat = fragment(statsTemplate);\n  var items = stat.getElementsByTagName('li');\n  var passes = items[1].getElementsByTagName('em')[0];\n  var passesLink = items[1].getElementsByTagName('a')[0];\n  var failures = items[2].getElementsByTagName('em')[0];\n  var failuresLink = items[2].getElementsByTagName('a')[0];\n  var duration = items[3].getElementsByTagName('em')[0];\n  var canvas = stat.getElementsByTagName('canvas')[0];\n  var report = fragment('<ul id=\"mocha-report\"></ul>');\n  var stack = [report];\n  var progress;\n  var ctx;\n  var root = document.getElementById('mocha');\n\n  if (canvas.getContext) {\n    var ratio = window.devicePixelRatio || 1;\n    canvas.style.width = canvas.width;\n    canvas.style.height = canvas.height;\n    canvas.width *= ratio;\n    canvas.height *= ratio;\n    ctx = canvas.getContext('2d');\n    ctx.scale(ratio, ratio);\n    progress = new Progress();\n  }\n\n  if (!root) {\n    return error('#mocha div missing, add it to your document');\n  }\n\n  // pass toggle\n  on(passesLink, 'click', function() {\n    unhide();\n    var name = (/pass/).test(report.className) ? '' : ' pass';\n    report.className = report.className.replace(/fail|pass/g, '') + name;\n    if (report.className.trim()) {\n      hideSuitesWithout('test pass');\n    }\n  });\n\n  // failure toggle\n  on(failuresLink, 'click', function() {\n    unhide();\n    var name = (/fail/).test(report.className) ? '' : ' fail';\n    report.className = report.className.replace(/fail|pass/g, '') + name;\n    if (report.className.trim()) {\n      hideSuitesWithout('test fail');\n    }\n  });\n\n  root.appendChild(stat);\n  root.appendChild(report);\n\n  if (progress) {\n    progress.size(40);\n  }\n\n  runner.on('suite', function(suite) {\n    if (suite.root) {\n      return;\n    }\n\n    // suite\n    var url = self.suiteURL(suite);\n    var el = fragment('<li class=\"suite\"><h1><a href=\"%s\">%s</a></h1></li>', url, escape(suite.title));\n\n    // container\n    stack[0].appendChild(el);\n    stack.unshift(document.createElement('ul'));\n    el.appendChild(stack[0]);\n  });\n\n  runner.on('suite end', function(suite) {\n    if (suite.root) {\n      return;\n    }\n    stack.shift();\n  });\n\n  runner.on('fail', function(test) {\n    // For type = 'test' its possible that the test failed due to multiple\n    // done() calls. So report the issue here.\n    if (test.type === 'hook'\n      || test.type === 'test') {\n      runner.emit('test end', test);\n    }\n  });\n\n  runner.on('test end', function(test) {\n    // TODO: add to stats\n    var percent = stats.tests / this.total * 100 | 0;\n    if (progress) {\n      progress.update(percent).draw(ctx);\n    }\n\n    // update stats\n    var ms = new Date() - stats.start;\n    text(passes, stats.passes);\n    text(failures, stats.failures);\n    text(duration, (ms / 1000).toFixed(2));\n\n    // test\n    var el;\n    if (test.state === 'passed') {\n      var url = self.testURL(test);\n      el = fragment('<li class=\"test pass %e\"><h2>%e<span class=\"duration\">%ems</span> <a href=\"%s\" class=\"replay\">‣</a></h2></li>', test.speed, test.title, test.duration, url);\n    } else if (test.pending) {\n      el = fragment('<li class=\"test pass pending\"><h2>%e</h2></li>', test.title);\n    } else {\n      el = fragment('<li class=\"test fail\"><h2>%e <a href=\"%e\" class=\"replay\">‣</a></h2></li>', test.title, self.testURL(test));\n      var stackString; // Note: Includes leading newline\n      var message = test.err.toString();\n\n      // <=IE7 stringifies to [Object Error]. Since it can be overloaded, we\n      // check for the result of the stringifying.\n      if (message === '[object Error]') {\n        message = test.err.message;\n      }\n\n      if (test.err.stack) {\n        var indexOfMessage = test.err.stack.indexOf(test.err.message);\n        if (indexOfMessage === -1) {\n          stackString = test.err.stack;\n        } else {\n          stackString = test.err.stack.substr(test.err.message.length + indexOfMessage);\n        }\n      } else if (test.err.sourceURL && test.err.line !== undefined) {\n        // Safari doesn't give you a stack. Let's at least provide a source line.\n        stackString = '\\n(' + test.err.sourceURL + ':' + test.err.line + ')';\n      }\n\n      stackString = stackString || '';\n\n      if (test.err.htmlMessage && stackString) {\n        el.appendChild(fragment('<div class=\"html-error\">%s\\n<pre class=\"error\">%e</pre></div>', test.err.htmlMessage, stackString));\n      } else if (test.err.htmlMessage) {\n        el.appendChild(fragment('<div class=\"html-error\">%s</div>', test.err.htmlMessage));\n      } else {\n        el.appendChild(fragment('<pre class=\"error\">%e%e</pre>', message, stackString));\n      }\n    }\n\n    // toggle code\n    // TODO: defer\n    if (!test.pending) {\n      var h2 = el.getElementsByTagName('h2')[0];\n\n      on(h2, 'click', function() {\n        pre.style.display = pre.style.display === 'none' ? 'block' : 'none';\n      });\n\n      var pre = fragment('<pre><code>%e</code></pre>', utils.clean(test.body));\n      el.appendChild(pre);\n      pre.style.display = 'none';\n    }\n\n    // Don't call .appendChild if #mocha-report was already .shift()'ed off the stack.\n    if (stack[0]) {\n      stack[0].appendChild(el);\n    }\n  });\n}\n\n/**\n * Makes a URL, preserving querystring (\"search\") parameters.\n *\n * @param {string} s\n * @return {string} A new URL.\n */\nfunction makeUrl(s) {\n  var search = window.location.search;\n\n  // Remove previous grep query parameter if present\n  if (search) {\n    search = search.replace(/[?&]grep=[^&\\s]*/g, '').replace(/^&/, '?');\n  }\n\n  return window.location.pathname + (search ? search + '&' : '?') + 'grep=' + encodeURIComponent(escapeRe(s));\n}\n\n/**\n * Provide suite URL.\n *\n * @param {Object} [suite]\n */\nHTML.prototype.suiteURL = function(suite) {\n  return makeUrl(suite.fullTitle());\n};\n\n/**\n * Provide test URL.\n *\n * @param {Object} [test]\n */\nHTML.prototype.testURL = function(test) {\n  return makeUrl(test.fullTitle());\n};\n\n/**\n * Display error `msg`.\n *\n * @param {string} msg\n */\nfunction error(msg) {\n  document.body.appendChild(fragment('<div id=\"mocha-error\">%s</div>', msg));\n}\n\n/**\n * Return a DOM fragment from `html`.\n *\n * @param {string} html\n */\nfunction fragment(html) {\n  var args = arguments;\n  var div = document.createElement('div');\n  var i = 1;\n\n  div.innerHTML = html.replace(/%([se])/g, function(_, type) {\n    switch (type) {\n      case 's': return String(args[i++]);\n      case 'e': return escape(args[i++]);\n      // no default\n    }\n  });\n\n  return div.firstChild;\n}\n\n/**\n * Check for suites that do not have elements\n * with `classname`, and hide them.\n *\n * @param {text} classname\n */\nfunction hideSuitesWithout(classname) {\n  var suites = document.getElementsByClassName('suite');\n  for (var i = 0; i < suites.length; i++) {\n    var els = suites[i].getElementsByClassName(classname);\n    if (!els.length) {\n      suites[i].className += ' hidden';\n    }\n  }\n}\n\n/**\n * Unhide .hidden suites.\n */\nfunction unhide() {\n  var els = document.getElementsByClassName('suite hidden');\n  for (var i = 0; i < els.length; ++i) {\n    els[i].className = els[i].className.replace('suite hidden', 'suite');\n  }\n}\n\n/**\n * Set an element's text contents.\n *\n * @param {HTMLElement} el\n * @param {string} contents\n */\nfunction text(el, contents) {\n  if (el.textContent) {\n    el.textContent = contents;\n  } else {\n    el.innerText = contents;\n  }\n}\n\n/**\n * Listen on `event` with callback `fn`.\n */\nfunction on(el, event, fn) {\n  if (el.addEventListener) {\n    el.addEventListener(event, fn, false);\n  } else {\n    el.attachEvent('on' + event, fn);\n  }\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../browser/progress\":4,\"../utils\":39,\"./base\":17,\"escape-string-regexp\":68}],22:[function(require,module,exports){\n// Alias exports to a their normalized format Mocha#reporter to prevent a need\n// for dynamic (try/catch) requires, which Browserify doesn't handle.\nexports.Base = exports.base = require('./base');\nexports.Dot = exports.dot = require('./dot');\nexports.Doc = exports.doc = require('./doc');\nexports.TAP = exports.tap = require('./tap');\nexports.JSON = exports.json = require('./json');\nexports.HTML = exports.html = require('./html');\nexports.List = exports.list = require('./list');\nexports.Min = exports.min = require('./min');\nexports.Spec = exports.spec = require('./spec');\nexports.Nyan = exports.nyan = require('./nyan');\nexports.XUnit = exports.xunit = require('./xunit');\nexports.Markdown = exports.markdown = require('./markdown');\nexports.Progress = exports.progress = require('./progress');\nexports.Landing = exports.landing = require('./landing');\nexports.JSONCov = exports['json-cov'] = require('./json-cov');\nexports.HTMLCov = exports['html-cov'] = require('./html-cov');\nexports.JSONStream = exports['json-stream'] = require('./json-stream');\n\n},{\"./base\":17,\"./doc\":18,\"./dot\":19,\"./html\":21,\"./html-cov\":20,\"./json\":25,\"./json-cov\":23,\"./json-stream\":24,\"./landing\":26,\"./list\":27,\"./markdown\":28,\"./min\":29,\"./nyan\":30,\"./progress\":31,\"./spec\":32,\"./tap\":33,\"./xunit\":34}],23:[function(require,module,exports){\n(function (process,global){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\n\n/**\n * Expose `JSONCov`.\n */\n\nexports = module.exports = JSONCov;\n\n/**\n * Initialize a new `JsCoverage` reporter.\n *\n * @api public\n * @param {Runner} runner\n * @param {boolean} output\n */\nfunction JSONCov(runner, output) {\n  Base.call(this, runner);\n\n  output = arguments.length === 1 || output;\n  var self = this;\n  var tests = [];\n  var failures = [];\n  var passes = [];\n\n  runner.on('test end', function(test) {\n    tests.push(test);\n  });\n\n  runner.on('pass', function(test) {\n    passes.push(test);\n  });\n\n  runner.on('fail', function(test) {\n    failures.push(test);\n  });\n\n  runner.on('end', function() {\n    var cov = global._$jscoverage || {};\n    var result = self.cov = map(cov);\n    result.stats = self.stats;\n    result.tests = tests.map(clean);\n    result.failures = failures.map(clean);\n    result.passes = passes.map(clean);\n    if (!output) {\n      return;\n    }\n    process.stdout.write(JSON.stringify(result, null, 2));\n  });\n}\n\n/**\n * Map jscoverage data to a JSON structure\n * suitable for reporting.\n *\n * @api private\n * @param {Object} cov\n * @return {Object}\n */\n\nfunction map(cov) {\n  var ret = {\n    instrumentation: 'node-jscoverage',\n    sloc: 0,\n    hits: 0,\n    misses: 0,\n    coverage: 0,\n    files: []\n  };\n\n  for (var filename in cov) {\n    if (Object.prototype.hasOwnProperty.call(cov, filename)) {\n      var data = coverage(filename, cov[filename]);\n      ret.files.push(data);\n      ret.hits += data.hits;\n      ret.misses += data.misses;\n      ret.sloc += data.sloc;\n    }\n  }\n\n  ret.files.sort(function(a, b) {\n    return a.filename.localeCompare(b.filename);\n  });\n\n  if (ret.sloc > 0) {\n    ret.coverage = (ret.hits / ret.sloc) * 100;\n  }\n\n  return ret;\n}\n\n/**\n * Map jscoverage data for a single source file\n * to a JSON structure suitable for reporting.\n *\n * @api private\n * @param {string} filename name of the source file\n * @param {Object} data jscoverage coverage data\n * @return {Object}\n */\nfunction coverage(filename, data) {\n  var ret = {\n    filename: filename,\n    coverage: 0,\n    hits: 0,\n    misses: 0,\n    sloc: 0,\n    source: {}\n  };\n\n  data.source.forEach(function(line, num) {\n    num++;\n\n    if (data[num] === 0) {\n      ret.misses++;\n      ret.sloc++;\n    } else if (data[num] !== undefined) {\n      ret.hits++;\n      ret.sloc++;\n    }\n\n    ret.source[num] = {\n      source: line,\n      coverage: data[num] === undefined ? '' : data[num]\n    };\n  });\n\n  ret.coverage = ret.hits / ret.sloc * 100;\n\n  return ret;\n}\n\n/**\n * Return a plain-object representation of `test`\n * free of cyclic properties etc.\n *\n * @api private\n * @param {Object} test\n * @return {Object}\n */\nfunction clean(test) {\n  return {\n    duration: test.duration,\n    currentRetry: test.currentRetry(),\n    fullTitle: test.fullTitle(),\n    title: test.title\n  };\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./base\":17,\"_process\":51}],24:[function(require,module,exports){\n(function (process){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\n\n/**\n * Expose `List`.\n */\n\nexports = module.exports = List;\n\n/**\n * Initialize a new `List` test reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction List(runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var total = runner.total;\n\n  runner.on('start', function() {\n    console.log(JSON.stringify(['start', { total: total }]));\n  });\n\n  runner.on('pass', function(test) {\n    console.log(JSON.stringify(['pass', clean(test)]));\n  });\n\n  runner.on('fail', function(test, err) {\n    test = clean(test);\n    test.err = err.message;\n    test.stack = err.stack || null;\n    console.log(JSON.stringify(['fail', test]));\n  });\n\n  runner.on('end', function() {\n    process.stdout.write(JSON.stringify(['end', self.stats]));\n  });\n}\n\n/**\n * Return a plain-object representation of `test`\n * free of cyclic properties etc.\n *\n * @api private\n * @param {Object} test\n * @return {Object}\n */\nfunction clean(test) {\n  return {\n    title: test.title,\n    fullTitle: test.fullTitle(),\n    duration: test.duration,\n    currentRetry: test.currentRetry()\n  };\n}\n\n}).call(this,require('_process'))\n},{\"./base\":17,\"_process\":51}],25:[function(require,module,exports){\n(function (process){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\n\n/**\n * Expose `JSON`.\n */\n\nexports = module.exports = JSONReporter;\n\n/**\n * Initialize a new `JSON` reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction JSONReporter(runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var tests = [];\n  var pending = [];\n  var failures = [];\n  var passes = [];\n\n  runner.on('test end', function(test) {\n    tests.push(test);\n  });\n\n  runner.on('pass', function(test) {\n    passes.push(test);\n  });\n\n  runner.on('fail', function(test) {\n    failures.push(test);\n  });\n\n  runner.on('pending', function(test) {\n    pending.push(test);\n  });\n\n  runner.on('end', function() {\n    var obj = {\n      stats: self.stats,\n      tests: tests.map(clean),\n      pending: pending.map(clean),\n      failures: failures.map(clean),\n      passes: passes.map(clean)\n    };\n\n    runner.testResults = obj;\n\n    process.stdout.write(JSON.stringify(obj, null, 2));\n  });\n}\n\n/**\n * Return a plain-object representation of `test`\n * free of cyclic properties etc.\n *\n * @api private\n * @param {Object} test\n * @return {Object}\n */\nfunction clean(test) {\n  return {\n    title: test.title,\n    fullTitle: test.fullTitle(),\n    duration: test.duration,\n    currentRetry: test.currentRetry(),\n    err: errorJSON(test.err || {})\n  };\n}\n\n/**\n * Transform `error` into a JSON object.\n *\n * @api private\n * @param {Error} err\n * @return {Object}\n */\nfunction errorJSON(err) {\n  var res = {};\n  Object.getOwnPropertyNames(err).forEach(function(key) {\n    res[key] = err[key];\n  }, err);\n  return res;\n}\n\n}).call(this,require('_process'))\n},{\"./base\":17,\"_process\":51}],26:[function(require,module,exports){\n(function (process){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar cursor = Base.cursor;\nvar color = Base.color;\n\n/**\n * Expose `Landing`.\n */\n\nexports = module.exports = Landing;\n\n/**\n * Airplane color.\n */\n\nBase.colors.plane = 0;\n\n/**\n * Airplane crash color.\n */\n\nBase.colors['plane crash'] = 31;\n\n/**\n * Runway color.\n */\n\nBase.colors.runway = 90;\n\n/**\n * Initialize a new `Landing` reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction Landing(runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var width = Base.window.width * .75 | 0;\n  var total = runner.total;\n  var stream = process.stdout;\n  var plane = color('plane', '✈');\n  var crashed = -1;\n  var n = 0;\n\n  function runway() {\n    var buf = Array(width).join('-');\n    return '  ' + color('runway', buf);\n  }\n\n  runner.on('start', function() {\n    stream.write('\\n\\n\\n  ');\n    cursor.hide();\n  });\n\n  runner.on('test end', function(test) {\n    // check if the plane crashed\n    var col = crashed === -1 ? width * ++n / total | 0 : crashed;\n\n    // show the crash\n    if (test.state === 'failed') {\n      plane = color('plane crash', '✈');\n      crashed = col;\n    }\n\n    // render landing strip\n    stream.write('\\u001b[' + (width + 1) + 'D\\u001b[2A');\n    stream.write(runway());\n    stream.write('\\n  ');\n    stream.write(color('runway', Array(col).join('⋅')));\n    stream.write(plane);\n    stream.write(color('runway', Array(width - col).join('⋅') + '\\n'));\n    stream.write(runway());\n    stream.write('\\u001b[0m');\n  });\n\n  runner.on('end', function() {\n    cursor.show();\n    console.log();\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Landing, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":39,\"./base\":17,\"_process\":51}],27:[function(require,module,exports){\n(function (process){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar color = Base.color;\nvar cursor = Base.cursor;\n\n/**\n * Expose `List`.\n */\n\nexports = module.exports = List;\n\n/**\n * Initialize a new `List` test reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction List(runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var n = 0;\n\n  runner.on('start', function() {\n    console.log();\n  });\n\n  runner.on('test', function(test) {\n    process.stdout.write(color('pass', '    ' + test.fullTitle() + ': '));\n  });\n\n  runner.on('pending', function(test) {\n    var fmt = color('checkmark', '  -')\n      + color('pending', ' %s');\n    console.log(fmt, test.fullTitle());\n  });\n\n  runner.on('pass', function(test) {\n    var fmt = color('checkmark', '  ' + Base.symbols.dot)\n      + color('pass', ' %s: ')\n      + color(test.speed, '%dms');\n    cursor.CR();\n    console.log(fmt, test.fullTitle(), test.duration);\n  });\n\n  runner.on('fail', function(test) {\n    cursor.CR();\n    console.log(color('fail', '  %d) %s'), ++n, test.fullTitle());\n  });\n\n  runner.on('end', self.epilogue.bind(self));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(List, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":39,\"./base\":17,\"_process\":51}],28:[function(require,module,exports){\n(function (process){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar utils = require('../utils');\n\n/**\n * Constants\n */\n\nvar SUITE_PREFIX = '$';\n\n/**\n * Expose `Markdown`.\n */\n\nexports = module.exports = Markdown;\n\n/**\n * Initialize a new `Markdown` reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction Markdown(runner) {\n  Base.call(this, runner);\n\n  var level = 0;\n  var buf = '';\n\n  function title(str) {\n    return Array(level).join('#') + ' ' + str;\n  }\n\n  function mapTOC(suite, obj) {\n    var ret = obj;\n    var key = SUITE_PREFIX + suite.title;\n\n    obj = obj[key] = obj[key] || { suite: suite };\n    suite.suites.forEach(function(suite) {\n      mapTOC(suite, obj);\n    });\n\n    return ret;\n  }\n\n  function stringifyTOC(obj, level) {\n    ++level;\n    var buf = '';\n    var link;\n    for (var key in obj) {\n      if (key === 'suite') {\n        continue;\n      }\n      if (key !== SUITE_PREFIX) {\n        link = ' - [' + key.substring(1) + ']';\n        link += '(#' + utils.slug(obj[key].suite.fullTitle()) + ')\\n';\n        buf += Array(level).join('  ') + link;\n      }\n      buf += stringifyTOC(obj[key], level);\n    }\n    return buf;\n  }\n\n  function generateTOC(suite) {\n    var obj = mapTOC(suite, {});\n    return stringifyTOC(obj, 0);\n  }\n\n  generateTOC(runner.suite);\n\n  runner.on('suite', function(suite) {\n    ++level;\n    var slug = utils.slug(suite.fullTitle());\n    buf += '<a name=\"' + slug + '\"></a>' + '\\n';\n    buf += title(suite.title) + '\\n';\n  });\n\n  runner.on('suite end', function() {\n    --level;\n  });\n\n  runner.on('pass', function(test) {\n    var code = utils.clean(test.body);\n    buf += test.title + '.\\n';\n    buf += '\\n```js\\n';\n    buf += code + '\\n';\n    buf += '```\\n\\n';\n  });\n\n  runner.on('end', function() {\n    process.stdout.write('# TOC\\n');\n    process.stdout.write(generateTOC(runner.suite));\n    process.stdout.write(buf);\n  });\n}\n\n}).call(this,require('_process'))\n},{\"../utils\":39,\"./base\":17,\"_process\":51}],29:[function(require,module,exports){\n(function (process){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\n\n/**\n * Expose `Min`.\n */\n\nexports = module.exports = Min;\n\n/**\n * Initialize a new `Min` minimal test reporter (best used with --watch).\n *\n * @api public\n * @param {Runner} runner\n */\nfunction Min(runner) {\n  Base.call(this, runner);\n\n  runner.on('start', function() {\n    // clear screen\n    process.stdout.write('\\u001b[2J');\n    // set cursor position\n    process.stdout.write('\\u001b[1;3H');\n  });\n\n  runner.on('end', this.epilogue.bind(this));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Min, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":39,\"./base\":17,\"_process\":51}],30:[function(require,module,exports){\n(function (process){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\n\n/**\n * Expose `Dot`.\n */\n\nexports = module.exports = NyanCat;\n\n/**\n * Initialize a new `Dot` matrix test reporter.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction NyanCat(runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var width = Base.window.width * .75 | 0;\n  var nyanCatWidth = this.nyanCatWidth = 11;\n\n  this.colorIndex = 0;\n  this.numberOfLines = 4;\n  this.rainbowColors = self.generateColors();\n  this.scoreboardWidth = 5;\n  this.tick = 0;\n  this.trajectories = [[], [], [], []];\n  this.trajectoryWidthMax = (width - nyanCatWidth);\n\n  runner.on('start', function() {\n    Base.cursor.hide();\n    self.draw();\n  });\n\n  runner.on('pending', function() {\n    self.draw();\n  });\n\n  runner.on('pass', function() {\n    self.draw();\n  });\n\n  runner.on('fail', function() {\n    self.draw();\n  });\n\n  runner.on('end', function() {\n    Base.cursor.show();\n    for (var i = 0; i < self.numberOfLines; i++) {\n      write('\\n');\n    }\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(NyanCat, Base);\n\n/**\n * Draw the nyan cat\n *\n * @api private\n */\n\nNyanCat.prototype.draw = function() {\n  this.appendRainbow();\n  this.drawScoreboard();\n  this.drawRainbow();\n  this.drawNyanCat();\n  this.tick = !this.tick;\n};\n\n/**\n * Draw the \"scoreboard\" showing the number\n * of passes, failures and pending tests.\n *\n * @api private\n */\n\nNyanCat.prototype.drawScoreboard = function() {\n  var stats = this.stats;\n\n  function draw(type, n) {\n    write(' ');\n    write(Base.color(type, n));\n    write('\\n');\n  }\n\n  draw('green', stats.passes);\n  draw('fail', stats.failures);\n  draw('pending', stats.pending);\n  write('\\n');\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Append the rainbow.\n *\n * @api private\n */\n\nNyanCat.prototype.appendRainbow = function() {\n  var segment = this.tick ? '_' : '-';\n  var rainbowified = this.rainbowify(segment);\n\n  for (var index = 0; index < this.numberOfLines; index++) {\n    var trajectory = this.trajectories[index];\n    if (trajectory.length >= this.trajectoryWidthMax) {\n      trajectory.shift();\n    }\n    trajectory.push(rainbowified);\n  }\n};\n\n/**\n * Draw the rainbow.\n *\n * @api private\n */\n\nNyanCat.prototype.drawRainbow = function() {\n  var self = this;\n\n  this.trajectories.forEach(function(line) {\n    write('\\u001b[' + self.scoreboardWidth + 'C');\n    write(line.join(''));\n    write('\\n');\n  });\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Draw the nyan cat\n *\n * @api private\n */\nNyanCat.prototype.drawNyanCat = function() {\n  var self = this;\n  var startWidth = this.scoreboardWidth + this.trajectories[0].length;\n  var dist = '\\u001b[' + startWidth + 'C';\n  var padding = '';\n\n  write(dist);\n  write('_,------,');\n  write('\\n');\n\n  write(dist);\n  padding = self.tick ? '  ' : '   ';\n  write('_|' + padding + '/\\\\_/\\\\ ');\n  write('\\n');\n\n  write(dist);\n  padding = self.tick ? '_' : '__';\n  var tail = self.tick ? '~' : '^';\n  write(tail + '|' + padding + this.face() + ' ');\n  write('\\n');\n\n  write(dist);\n  padding = self.tick ? ' ' : '  ';\n  write(padding + '\"\"  \"\" ');\n  write('\\n');\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Draw nyan cat face.\n *\n * @api private\n * @return {string}\n */\n\nNyanCat.prototype.face = function() {\n  var stats = this.stats;\n  if (stats.failures) {\n    return '( x .x)';\n  } else if (stats.pending) {\n    return '( o .o)';\n  } else if (stats.passes) {\n    return '( ^ .^)';\n  }\n  return '( - .-)';\n};\n\n/**\n * Move cursor up `n`.\n *\n * @api private\n * @param {number} n\n */\n\nNyanCat.prototype.cursorUp = function(n) {\n  write('\\u001b[' + n + 'A');\n};\n\n/**\n * Move cursor down `n`.\n *\n * @api private\n * @param {number} n\n */\n\nNyanCat.prototype.cursorDown = function(n) {\n  write('\\u001b[' + n + 'B');\n};\n\n/**\n * Generate rainbow colors.\n *\n * @api private\n * @return {Array}\n */\nNyanCat.prototype.generateColors = function() {\n  var colors = [];\n\n  for (var i = 0; i < (6 * 7); i++) {\n    var pi3 = Math.floor(Math.PI / 3);\n    var n = (i * (1.0 / 6));\n    var r = Math.floor(3 * Math.sin(n) + 3);\n    var g = Math.floor(3 * Math.sin(n + 2 * pi3) + 3);\n    var b = Math.floor(3 * Math.sin(n + 4 * pi3) + 3);\n    colors.push(36 * r + 6 * g + b + 16);\n  }\n\n  return colors;\n};\n\n/**\n * Apply rainbow to the given `str`.\n *\n * @api private\n * @param {string} str\n * @return {string}\n */\nNyanCat.prototype.rainbowify = function(str) {\n  if (!Base.useColors) {\n    return str;\n  }\n  var color = this.rainbowColors[this.colorIndex % this.rainbowColors.length];\n  this.colorIndex += 1;\n  return '\\u001b[38;5;' + color + 'm' + str + '\\u001b[0m';\n};\n\n/**\n * Stdout helper.\n *\n * @param {string} string A message to write to stdout.\n */\nfunction write(string) {\n  process.stdout.write(string);\n}\n\n}).call(this,require('_process'))\n},{\"../utils\":39,\"./base\":17,\"_process\":51}],31:[function(require,module,exports){\n(function (process){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar color = Base.color;\nvar cursor = Base.cursor;\n\n/**\n * Expose `Progress`.\n */\n\nexports = module.exports = Progress;\n\n/**\n * General progress bar color.\n */\n\nBase.colors.progress = 90;\n\n/**\n * Initialize a new `Progress` bar test reporter.\n *\n * @api public\n * @param {Runner} runner\n * @param {Object} options\n */\nfunction Progress(runner, options) {\n  Base.call(this, runner);\n\n  var self = this;\n  var width = Base.window.width * .50 | 0;\n  var total = runner.total;\n  var complete = 0;\n  var lastN = -1;\n\n  // default chars\n  options = options || {};\n  options.open = options.open || '[';\n  options.complete = options.complete || '▬';\n  options.incomplete = options.incomplete || Base.symbols.dot;\n  options.close = options.close || ']';\n  options.verbose = false;\n\n  // tests started\n  runner.on('start', function() {\n    console.log();\n    cursor.hide();\n  });\n\n  // tests complete\n  runner.on('test end', function() {\n    complete++;\n\n    var percent = complete / total;\n    var n = width * percent | 0;\n    var i = width - n;\n\n    if (n === lastN && !options.verbose) {\n      // Don't re-render the line if it hasn't changed\n      return;\n    }\n    lastN = n;\n\n    cursor.CR();\n    process.stdout.write('\\u001b[J');\n    process.stdout.write(color('progress', '  ' + options.open));\n    process.stdout.write(Array(n).join(options.complete));\n    process.stdout.write(Array(i).join(options.incomplete));\n    process.stdout.write(color('progress', options.close));\n    if (options.verbose) {\n      process.stdout.write(color('progress', ' ' + complete + ' of ' + total));\n    }\n  });\n\n  // tests are complete, output some stats\n  // and the failures if any\n  runner.on('end', function() {\n    cursor.show();\n    console.log();\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Progress, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":39,\"./base\":17,\"_process\":51}],32:[function(require,module,exports){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar color = Base.color;\nvar cursor = Base.cursor;\n\n/**\n * Expose `Spec`.\n */\n\nexports = module.exports = Spec;\n\n/**\n * Initialize a new `Spec` test reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction Spec(runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var indents = 0;\n  var n = 0;\n\n  function indent() {\n    return Array(indents).join('  ');\n  }\n\n  runner.on('start', function() {\n    console.log();\n  });\n\n  runner.on('suite', function(suite) {\n    ++indents;\n    console.log(color('suite', '%s%s'), indent(), suite.title);\n  });\n\n  runner.on('suite end', function() {\n    --indents;\n    if (indents === 1) {\n      console.log();\n    }\n  });\n\n  runner.on('pending', function(test) {\n    var fmt = indent() + color('pending', '  - %s');\n    console.log(fmt, test.title);\n  });\n\n  runner.on('pass', function(test) {\n    var fmt;\n    if (test.speed === 'fast') {\n      fmt = indent()\n        + color('checkmark', '  ' + Base.symbols.ok)\n        + color('pass', ' %s');\n      cursor.CR();\n      console.log(fmt, test.title);\n    } else {\n      fmt = indent()\n        + color('checkmark', '  ' + Base.symbols.ok)\n        + color('pass', ' %s')\n        + color(test.speed, ' (%dms)');\n      cursor.CR();\n      console.log(fmt, test.title, test.duration);\n    }\n  });\n\n  runner.on('fail', function(test) {\n    cursor.CR();\n    console.log(indent() + color('fail', '  %d) %s'), ++n, test.title);\n  });\n\n  runner.on('end', self.epilogue.bind(self));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Spec, Base);\n\n},{\"../utils\":39,\"./base\":17}],33:[function(require,module,exports){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\n\n/**\n * Expose `TAP`.\n */\n\nexports = module.exports = TAP;\n\n/**\n * Initialize a new `TAP` reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction TAP(runner) {\n  Base.call(this, runner);\n\n  var n = 1;\n  var passes = 0;\n  var failures = 0;\n\n  runner.on('start', function() {\n    var total = runner.grepTotal(runner.suite);\n    console.log('%d..%d', 1, total);\n  });\n\n  runner.on('test end', function() {\n    ++n;\n  });\n\n  runner.on('pending', function(test) {\n    console.log('ok %d %s # SKIP -', n, title(test));\n  });\n\n  runner.on('pass', function(test) {\n    passes++;\n    console.log('ok %d %s', n, title(test));\n  });\n\n  runner.on('fail', function(test, err) {\n    failures++;\n    console.log('not ok %d %s', n, title(test));\n    if (err.stack) {\n      console.log(err.stack.replace(/^/gm, '  '));\n    }\n  });\n\n  runner.on('end', function() {\n    console.log('# tests ' + (passes + failures));\n    console.log('# pass ' + passes);\n    console.log('# fail ' + failures);\n  });\n}\n\n/**\n * Return a TAP-safe title of `test`\n *\n * @api private\n * @param {Object} test\n * @return {String}\n */\nfunction title(test) {\n  return test.fullTitle().replace(/#/g, '');\n}\n\n},{\"./base\":17}],34:[function(require,module,exports){\n(function (process,global){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar utils = require('../utils');\nvar inherits = utils.inherits;\nvar fs = require('fs');\nvar escape = utils.escape;\nvar mkdirp = require('mkdirp');\nvar path = require('path');\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\n/**\n * Expose `XUnit`.\n */\n\nexports = module.exports = XUnit;\n\n/**\n * Initialize a new `XUnit` reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction XUnit(runner, options) {\n  Base.call(this, runner);\n\n  var stats = this.stats;\n  var tests = [];\n  var self = this;\n\n  if (options.reporterOptions && options.reporterOptions.output) {\n    if (!fs.createWriteStream) {\n      throw new Error('file output not supported in browser');\n    }\n    mkdirp.sync(path.dirname(options.reporterOptions.output));\n    self.fileStream = fs.createWriteStream(options.reporterOptions.output);\n  }\n\n  runner.on('pending', function(test) {\n    tests.push(test);\n  });\n\n  runner.on('pass', function(test) {\n    tests.push(test);\n  });\n\n  runner.on('fail', function(test) {\n    tests.push(test);\n  });\n\n  runner.on('end', function() {\n    self.write(tag('testsuite', {\n      name: 'Mocha Tests',\n      tests: stats.tests,\n      failures: stats.failures,\n      errors: stats.failures,\n      skipped: stats.tests - stats.failures - stats.passes,\n      timestamp: (new Date()).toUTCString(),\n      time: (stats.duration / 1000) || 0\n    }, false));\n\n    tests.forEach(function(t) {\n      self.test(t);\n    });\n\n    self.write('</testsuite>');\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(XUnit, Base);\n\n/**\n * Override done to close the stream (if it's a file).\n *\n * @param failures\n * @param {Function} fn\n */\nXUnit.prototype.done = function(failures, fn) {\n  if (this.fileStream) {\n    this.fileStream.end(function() {\n      fn(failures);\n    });\n  } else {\n    fn(failures);\n  }\n};\n\n/**\n * Write out the given line.\n *\n * @param {string} line\n */\nXUnit.prototype.write = function(line) {\n  if (this.fileStream) {\n    this.fileStream.write(line + '\\n');\n  } else if (typeof process === 'object' && process.stdout) {\n    process.stdout.write(line + '\\n');\n  } else {\n    console.log(line);\n  }\n};\n\n/**\n * Output tag for the given `test.`\n *\n * @param {Test} test\n */\nXUnit.prototype.test = function(test) {\n  var attrs = {\n    classname: test.parent.fullTitle(),\n    name: test.title,\n    time: (test.duration / 1000) || 0\n  };\n\n  if (test.state === 'failed') {\n    var err = test.err;\n    this.write(tag('testcase', attrs, false, tag('failure', {}, false, cdata(escape(err.message) + '\\n' + err.stack))));\n  } else if (test.pending) {\n    this.write(tag('testcase', attrs, false, tag('skipped', {}, true)));\n  } else {\n    this.write(tag('testcase', attrs, true));\n  }\n};\n\n/**\n * HTML tag helper.\n *\n * @param name\n * @param attrs\n * @param close\n * @param content\n * @return {string}\n */\nfunction tag(name, attrs, close, content) {\n  var end = close ? '/>' : '>';\n  var pairs = [];\n  var tag;\n\n  for (var key in attrs) {\n    if (Object.prototype.hasOwnProperty.call(attrs, key)) {\n      pairs.push(key + '=\"' + escape(attrs[key]) + '\"');\n    }\n  }\n\n  tag = '<' + name + (pairs.length ? ' ' + pairs.join(' ') : '') + end;\n  if (content) {\n    tag += content + '</' + name + end;\n  }\n  return tag;\n}\n\n/**\n * Return cdata escaped CDATA `str`.\n */\n\nfunction cdata(str) {\n  return '<![CDATA[' + escape(str) + ']]>';\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../utils\":39,\"./base\":17,\"_process\":51,\"fs\":41,\"mkdirp\":70,\"path\":41}],35:[function(require,module,exports){\n(function (global){\n/**\n * Module dependencies.\n */\n\nvar EventEmitter = require('events').EventEmitter;\nvar Pending = require('./pending');\nvar debug = require('debug')('mocha:runnable');\nvar milliseconds = require('./ms');\nvar utils = require('./utils');\nvar inherits = utils.inherits;\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\n/**\n * Object#toString().\n */\n\nvar toString = Object.prototype.toString;\n\n/**\n * Expose `Runnable`.\n */\n\nmodule.exports = Runnable;\n\n/**\n * Initialize a new `Runnable` with the given `title` and callback `fn`.\n *\n * @param {String} title\n * @param {Function} fn\n * @api private\n * @param {string} title\n * @param {Function} fn\n */\nfunction Runnable(title, fn) {\n  this.title = title;\n  this.fn = fn;\n  this.async = fn && fn.length;\n  this.sync = !this.async;\n  this._timeout = 2000;\n  this._slow = 75;\n  this._enableTimeouts = true;\n  this.timedOut = false;\n  this._trace = new Error('done() called multiple times');\n  this._retries = -1;\n  this._currentRetry = 0;\n}\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\ninherits(Runnable, EventEmitter);\n\n/**\n * Set & get timeout `ms`.\n *\n * @api private\n * @param {number|string} ms\n * @return {Runnable|number} ms or Runnable instance.\n */\nRunnable.prototype.timeout = function(ms) {\n  if (!arguments.length) {\n    return this._timeout;\n  }\n  if (ms === 0) {\n    this._enableTimeouts = false;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('timeout %d', ms);\n  this._timeout = ms;\n  if (this.timer) {\n    this.resetTimeout();\n  }\n  return this;\n};\n\n/**\n * Set & get slow `ms`.\n *\n * @api private\n * @param {number|string} ms\n * @return {Runnable|number} ms or Runnable instance.\n */\nRunnable.prototype.slow = function(ms) {\n  if (!arguments.length) {\n    return this._slow;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('timeout %d', ms);\n  this._slow = ms;\n  return this;\n};\n\n/**\n * Set and get whether timeout is `enabled`.\n *\n * @api private\n * @param {boolean} enabled\n * @return {Runnable|boolean} enabled or Runnable instance.\n */\nRunnable.prototype.enableTimeouts = function(enabled) {\n  if (!arguments.length) {\n    return this._enableTimeouts;\n  }\n  debug('enableTimeouts %s', enabled);\n  this._enableTimeouts = enabled;\n  return this;\n};\n\n/**\n * Halt and mark as pending.\n *\n * @api private\n */\nRunnable.prototype.skip = function() {\n  throw new Pending();\n};\n\n/**\n * Set number of retries.\n *\n * @api private\n */\nRunnable.prototype.retries = function(n) {\n  if (!arguments.length) {\n    return this._retries;\n  }\n  this._retries = n;\n};\n\n/**\n * Get current retry\n *\n * @api private\n */\nRunnable.prototype.currentRetry = function(n) {\n  if (!arguments.length) {\n    return this._currentRetry;\n  }\n  this._currentRetry = n;\n};\n\n/**\n * Return the full title generated by recursively concatenating the parent's\n * full title.\n *\n * @api public\n * @return {string}\n */\nRunnable.prototype.fullTitle = function() {\n  return this.parent.fullTitle() + ' ' + this.title;\n};\n\n/**\n * Clear the timeout.\n *\n * @api private\n */\nRunnable.prototype.clearTimeout = function() {\n  clearTimeout(this.timer);\n};\n\n/**\n * Inspect the runnable void of private properties.\n *\n * @api private\n * @return {string}\n */\nRunnable.prototype.inspect = function() {\n  return JSON.stringify(this, function(key, val) {\n    if (key[0] === '_') {\n      return;\n    }\n    if (key === 'parent') {\n      return '#<Suite>';\n    }\n    if (key === 'ctx') {\n      return '#<Context>';\n    }\n    return val;\n  }, 2);\n};\n\n/**\n * Reset the timeout.\n *\n * @api private\n */\nRunnable.prototype.resetTimeout = function() {\n  var self = this;\n  var ms = this.timeout() || 1e9;\n\n  if (!this._enableTimeouts) {\n    return;\n  }\n  this.clearTimeout();\n  this.timer = setTimeout(function() {\n    if (!self._enableTimeouts) {\n      return;\n    }\n    self.callback(new Error('timeout of ' + ms + 'ms exceeded. Ensure the done() callback is being called in this test.'));\n    self.timedOut = true;\n  }, ms);\n};\n\n/**\n * Whitelist a list of globals for this test run.\n *\n * @api private\n * @param {string[]} globals\n */\nRunnable.prototype.globals = function(globals) {\n  if (!arguments.length) {\n    return this._allowedGlobals;\n  }\n  this._allowedGlobals = globals;\n};\n\n/**\n * Run the test and invoke `fn(err)`.\n *\n * @param {Function} fn\n * @api private\n */\nRunnable.prototype.run = function(fn) {\n  var self = this;\n  var start = new Date();\n  var ctx = this.ctx;\n  var finished;\n  var emitted;\n\n  // Sometimes the ctx exists, but it is not runnable\n  if (ctx && ctx.runnable) {\n    ctx.runnable(this);\n  }\n\n  // called multiple times\n  function multiple(err) {\n    if (emitted) {\n      return;\n    }\n    emitted = true;\n    self.emit('error', err || new Error('done() called multiple times; stacktrace may be inaccurate'));\n  }\n\n  // finished\n  function done(err) {\n    var ms = self.timeout();\n    if (self.timedOut) {\n      return;\n    }\n    if (finished) {\n      return multiple(err || self._trace);\n    }\n\n    self.clearTimeout();\n    self.duration = new Date() - start;\n    finished = true;\n    if (!err && self.duration > ms && self._enableTimeouts) {\n      err = new Error('timeout of ' + ms + 'ms exceeded. Ensure the done() callback is being called in this test.');\n    }\n    fn(err);\n  }\n\n  // for .resetTimeout()\n  this.callback = done;\n\n  // explicit async with `done` argument\n  if (this.async) {\n    this.resetTimeout();\n\n    if (this.allowUncaught) {\n      return callFnAsync(this.fn);\n    }\n    try {\n      callFnAsync(this.fn);\n    } catch (err) {\n      done(utils.getError(err));\n    }\n    return;\n  }\n\n  if (this.allowUncaught) {\n    callFn(this.fn);\n    done();\n    return;\n  }\n\n  // sync or promise-returning\n  try {\n    if (this.pending) {\n      done();\n    } else {\n      callFn(this.fn);\n    }\n  } catch (err) {\n    done(utils.getError(err));\n  }\n\n  function callFn(fn) {\n    var result = fn.call(ctx);\n    if (result && typeof result.then === 'function') {\n      self.resetTimeout();\n      result\n        .then(function() {\n          done();\n          // Return null so libraries like bluebird do not warn about\n          // subsequently constructed Promises.\n          return null;\n        },\n        function(reason) {\n          done(reason || new Error('Promise rejected with no or falsy reason'));\n        });\n    } else {\n      if (self.asyncOnly) {\n        return done(new Error('--async-only option in use without declaring `done()` or returning a promise'));\n      }\n\n      done();\n    }\n  }\n\n  function callFnAsync(fn) {\n    fn.call(ctx, function(err) {\n      if (err instanceof Error || toString.call(err) === '[object Error]') {\n        return done(err);\n      }\n      if (err) {\n        if (Object.prototype.toString.call(err) === '[object Object]') {\n          return done(new Error('done() invoked with non-Error: '\n            + JSON.stringify(err)));\n        }\n        return done(new Error('done() invoked with non-Error: ' + err));\n      }\n      done();\n    });\n  }\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./ms\":15,\"./pending\":16,\"./utils\":39,\"debug\":2,\"events\":3}],36:[function(require,module,exports){\n(function (process,global){\n/**\n * Module dependencies.\n */\n\nvar EventEmitter = require('events').EventEmitter;\nvar Pending = require('./pending');\nvar utils = require('./utils');\nvar inherits = utils.inherits;\nvar debug = require('debug')('mocha:runner');\nvar Runnable = require('./runnable');\nvar filter = utils.filter;\nvar indexOf = utils.indexOf;\nvar keys = utils.keys;\nvar stackFilter = utils.stackTraceFilter();\nvar stringify = utils.stringify;\nvar type = utils.type;\nvar undefinedError = utils.undefinedError;\nvar isArray = utils.isArray;\n\n/**\n * Non-enumerable globals.\n */\n\nvar globals = [\n  'setTimeout',\n  'clearTimeout',\n  'setInterval',\n  'clearInterval',\n  'XMLHttpRequest',\n  'Date',\n  'setImmediate',\n  'clearImmediate'\n];\n\n/**\n * Expose `Runner`.\n */\n\nmodule.exports = Runner;\n\n/**\n * Initialize a `Runner` for the given `suite`.\n *\n * Events:\n *\n *   - `start`  execution started\n *   - `end`  execution complete\n *   - `suite`  (suite) test suite execution started\n *   - `suite end`  (suite) all tests (and sub-suites) have finished\n *   - `test`  (test) test execution started\n *   - `test end`  (test) test completed\n *   - `hook`  (hook) hook execution started\n *   - `hook end`  (hook) hook complete\n *   - `pass`  (test) test passed\n *   - `fail`  (test, err) test failed\n *   - `pending`  (test) test pending\n *\n * @api public\n * @param {Suite} suite Root suite\n * @param {boolean} [delay] Whether or not to delay execution of root suite\n * until ready.\n */\nfunction Runner(suite, delay) {\n  var self = this;\n  this._globals = [];\n  this._abort = false;\n  this._delay = delay;\n  this.suite = suite;\n  this.started = false;\n  this.total = suite.total();\n  this.failures = 0;\n  this.on('test end', function(test) {\n    self.checkGlobals(test);\n  });\n  this.on('hook end', function(hook) {\n    self.checkGlobals(hook);\n  });\n  this._defaultGrep = /.*/;\n  this.grep(this._defaultGrep);\n  this.globals(this.globalProps().concat(extraGlobals()));\n}\n\n/**\n * Wrapper for setImmediate, process.nextTick, or browser polyfill.\n *\n * @param {Function} fn\n * @api private\n */\nRunner.immediately = global.setImmediate || process.nextTick;\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\ninherits(Runner, EventEmitter);\n\n/**\n * Run tests with full titles matching `re`. Updates runner.total\n * with number of tests matched.\n *\n * @param {RegExp} re\n * @param {Boolean} invert\n * @return {Runner} for chaining\n * @api public\n * @param {RegExp} re\n * @param {boolean} invert\n * @return {Runner} Runner instance.\n */\nRunner.prototype.grep = function(re, invert) {\n  debug('grep %s', re);\n  this._grep = re;\n  this._invert = invert;\n  this.total = this.grepTotal(this.suite);\n  return this;\n};\n\n/**\n * Returns the number of tests matching the grep search for the\n * given suite.\n *\n * @param {Suite} suite\n * @return {Number}\n * @api public\n * @param {Suite} suite\n * @return {number}\n */\nRunner.prototype.grepTotal = function(suite) {\n  var self = this;\n  var total = 0;\n\n  suite.eachTest(function(test) {\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) {\n      match = !match;\n    }\n    if (match) {\n      total++;\n    }\n  });\n\n  return total;\n};\n\n/**\n * Return a list of global properties.\n *\n * @return {Array}\n * @api private\n */\nRunner.prototype.globalProps = function() {\n  var props = keys(global);\n\n  // non-enumerables\n  for (var i = 0; i < globals.length; ++i) {\n    if (~indexOf(props, globals[i])) {\n      continue;\n    }\n    props.push(globals[i]);\n  }\n\n  return props;\n};\n\n/**\n * Allow the given `arr` of globals.\n *\n * @param {Array} arr\n * @return {Runner} for chaining\n * @api public\n * @param {Array} arr\n * @return {Runner} Runner instance.\n */\nRunner.prototype.globals = function(arr) {\n  if (!arguments.length) {\n    return this._globals;\n  }\n  debug('globals %j', arr);\n  this._globals = this._globals.concat(arr);\n  return this;\n};\n\n/**\n * Check for global variable leaks.\n *\n * @api private\n */\nRunner.prototype.checkGlobals = function(test) {\n  if (this.ignoreLeaks) {\n    return;\n  }\n  var ok = this._globals;\n\n  var globals = this.globalProps();\n  var leaks;\n\n  if (test) {\n    ok = ok.concat(test._allowedGlobals || []);\n  }\n\n  if (this.prevGlobalsLength === globals.length) {\n    return;\n  }\n  this.prevGlobalsLength = globals.length;\n\n  leaks = filterLeaks(ok, globals);\n  this._globals = this._globals.concat(leaks);\n\n  if (leaks.length > 1) {\n    this.fail(test, new Error('global leaks detected: ' + leaks.join(', ') + ''));\n  } else if (leaks.length) {\n    this.fail(test, new Error('global leak detected: ' + leaks[0]));\n  }\n};\n\n/**\n * Fail the given `test`.\n *\n * @api private\n * @param {Test} test\n * @param {Error} err\n */\nRunner.prototype.fail = function(test, err) {\n  ++this.failures;\n  test.state = 'failed';\n\n  if (!(err instanceof Error || err && typeof err.message === 'string')) {\n    err = new Error('the ' + type(err) + ' ' + stringify(err) + ' was thrown, throw an Error :)');\n  }\n\n  err.stack = (this.fullStackTrace || !err.stack)\n    ? err.stack\n    : stackFilter(err.stack);\n\n  this.emit('fail', test, err);\n};\n\n/**\n * Fail the given `hook` with `err`.\n *\n * Hook failures work in the following pattern:\n * - If bail, then exit\n * - Failed `before` hook skips all tests in a suite and subsuites,\n *   but jumps to corresponding `after` hook\n * - Failed `before each` hook skips remaining tests in a\n *   suite and jumps to corresponding `after each` hook,\n *   which is run only once\n * - Failed `after` hook does not alter\n *   execution order\n * - Failed `after each` hook skips remaining tests in a\n *   suite and subsuites, but executes other `after each`\n *   hooks\n *\n * @api private\n * @param {Hook} hook\n * @param {Error} err\n */\nRunner.prototype.failHook = function(hook, err) {\n  if (hook.ctx && hook.ctx.currentTest) {\n    hook.originalTitle = hook.originalTitle || hook.title;\n    hook.title = hook.originalTitle + ' for \"' + hook.ctx.currentTest.title + '\"';\n  }\n\n  this.fail(hook, err);\n  if (this.suite.bail()) {\n    this.emit('end');\n  }\n};\n\n/**\n * Run hook `name` callbacks and then invoke `fn()`.\n *\n * @api private\n * @param {string} name\n * @param {Function} fn\n */\n\nRunner.prototype.hook = function(name, fn) {\n  var suite = this.suite;\n  var hooks = suite['_' + name];\n  var self = this;\n\n  function next(i) {\n    var hook = hooks[i];\n    if (!hook) {\n      return fn();\n    }\n    self.currentRunnable = hook;\n\n    hook.ctx.currentTest = self.test;\n\n    self.emit('hook', hook);\n\n    if (!hook.listeners('error').length) {\n      hook.on('error', function(err) {\n        self.failHook(hook, err);\n      });\n    }\n\n    hook.run(function(err) {\n      var testError = hook.error();\n      if (testError) {\n        self.fail(self.test, testError);\n      }\n      if (err) {\n        if (err instanceof Pending) {\n          suite.pending = true;\n        } else {\n          self.failHook(hook, err);\n\n          // stop executing hooks, notify callee of hook err\n          return fn(err);\n        }\n      }\n      self.emit('hook end', hook);\n      delete hook.ctx.currentTest;\n      next(++i);\n    });\n  }\n\n  Runner.immediately(function() {\n    next(0);\n  });\n};\n\n/**\n * Run hook `name` for the given array of `suites`\n * in order, and callback `fn(err, errSuite)`.\n *\n * @api private\n * @param {string} name\n * @param {Array} suites\n * @param {Function} fn\n */\nRunner.prototype.hooks = function(name, suites, fn) {\n  var self = this;\n  var orig = this.suite;\n\n  function next(suite) {\n    self.suite = suite;\n\n    if (!suite) {\n      self.suite = orig;\n      return fn();\n    }\n\n    self.hook(name, function(err) {\n      if (err) {\n        var errSuite = self.suite;\n        self.suite = orig;\n        return fn(err, errSuite);\n      }\n\n      next(suites.pop());\n    });\n  }\n\n  next(suites.pop());\n};\n\n/**\n * Run hooks from the top level down.\n *\n * @param {String} name\n * @param {Function} fn\n * @api private\n */\nRunner.prototype.hookUp = function(name, fn) {\n  var suites = [this.suite].concat(this.parents()).reverse();\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Run hooks from the bottom up.\n *\n * @param {String} name\n * @param {Function} fn\n * @api private\n */\nRunner.prototype.hookDown = function(name, fn) {\n  var suites = [this.suite].concat(this.parents());\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Return an array of parent Suites from\n * closest to furthest.\n *\n * @return {Array}\n * @api private\n */\nRunner.prototype.parents = function() {\n  var suite = this.suite;\n  var suites = [];\n  while (suite.parent) {\n    suite = suite.parent;\n    suites.push(suite);\n  }\n  return suites;\n};\n\n/**\n * Run the current test and callback `fn(err)`.\n *\n * @param {Function} fn\n * @api private\n */\nRunner.prototype.runTest = function(fn) {\n  var self = this;\n  var test = this.test;\n\n  if (this.asyncOnly) {\n    test.asyncOnly = true;\n  }\n\n  if (this.allowUncaught) {\n    test.allowUncaught = true;\n    return test.run(fn);\n  }\n  try {\n    test.on('error', function(err) {\n      self.fail(test, err);\n    });\n    test.run(fn);\n  } catch (err) {\n    fn(err);\n  }\n};\n\n/**\n * Run tests in the given `suite` and invoke the callback `fn()` when complete.\n *\n * @api private\n * @param {Suite} suite\n * @param {Function} fn\n */\nRunner.prototype.runTests = function(suite, fn) {\n  var self = this;\n  var tests = suite.tests.slice();\n  var test;\n\n  function hookErr(_, errSuite, after) {\n    // before/after Each hook for errSuite failed:\n    var orig = self.suite;\n\n    // for failed 'after each' hook start from errSuite parent,\n    // otherwise start from errSuite itself\n    self.suite = after ? errSuite.parent : errSuite;\n\n    if (self.suite) {\n      // call hookUp afterEach\n      self.hookUp('afterEach', function(err2, errSuite2) {\n        self.suite = orig;\n        // some hooks may fail even now\n        if (err2) {\n          return hookErr(err2, errSuite2, true);\n        }\n        // report error suite\n        fn(errSuite);\n      });\n    } else {\n      // there is no need calling other 'after each' hooks\n      self.suite = orig;\n      fn(errSuite);\n    }\n  }\n\n  function next(err, errSuite) {\n    // if we bail after first err\n    if (self.failures && suite._bail) {\n      return fn();\n    }\n\n    if (self._abort) {\n      return fn();\n    }\n\n    if (err) {\n      return hookErr(err, errSuite, true);\n    }\n\n    // next test\n    test = tests.shift();\n\n    // all done\n    if (!test) {\n      return fn();\n    }\n\n    // grep\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) {\n      match = !match;\n    }\n    if (!match) {\n      // Run immediately only if we have defined a grep. When we\n      // define a grep — It can cause maximum callstack error if\n      // the grep is doing a large recursive loop by neglecting\n      // all tests. The run immediately function also comes with\n      // a performance cost. So we don't want to run immediately\n      // if we run the whole test suite, because running the whole\n      // test suite don't do any immediate recursive loops. Thus,\n      // allowing a JS runtime to breathe.\n      if (self._grep !== self._defaultGrep) {\n        Runner.immediately(next);\n      } else {\n        next();\n      }\n      return;\n    }\n\n    function parentPending(suite) {\n      return suite.pending || (suite.parent && parentPending(suite.parent));\n    }\n\n    // pending\n    if (test.pending || parentPending(test.parent)) {\n      self.emit('pending', test);\n      self.emit('test end', test);\n      return next();\n    }\n\n    // execute test and hook(s)\n    self.emit('test', self.test = test);\n    self.hookDown('beforeEach', function(err, errSuite) {\n      if (suite.pending) {\n        self.emit('pending', test);\n        self.emit('test end', test);\n        return next();\n      }\n      if (err) {\n        return hookErr(err, errSuite, false);\n      }\n      self.currentRunnable = self.test;\n      self.runTest(function(err) {\n        test = self.test;\n        if (err) {\n          var retry = test.currentRetry();\n          if (err instanceof Pending) {\n            test.pending = true;\n            self.emit('pending', test);\n          } else if (retry < test.retries()) {\n            var clonedTest = test.clone();\n            clonedTest.currentRetry(retry + 1);\n            tests.unshift(clonedTest);\n\n            // Early return + hook trigger so that it doesn't\n            // increment the count wrong\n            return self.hookUp('afterEach', next);\n          } else {\n            self.fail(test, err);\n          }\n          self.emit('test end', test);\n\n          if (err instanceof Pending) {\n            return next();\n          }\n\n          return self.hookUp('afterEach', next);\n        }\n\n        test.state = 'passed';\n        self.emit('pass', test);\n        self.emit('test end', test);\n        self.hookUp('afterEach', next);\n      });\n    });\n  }\n\n  this.next = next;\n  this.hookErr = hookErr;\n  next();\n};\n\n/**\n * Run the given `suite` and invoke the callback `fn()` when complete.\n *\n * @api private\n * @param {Suite} suite\n * @param {Function} fn\n */\nRunner.prototype.runSuite = function(suite, fn) {\n  var i = 0;\n  var self = this;\n  var total = this.grepTotal(suite);\n  var afterAllHookCalled = false;\n\n  debug('run suite %s', suite.fullTitle());\n\n  if (!total || (self.failures && suite._bail)) {\n    return fn();\n  }\n\n  this.emit('suite', this.suite = suite);\n\n  function next(errSuite) {\n    if (errSuite) {\n      // current suite failed on a hook from errSuite\n      if (errSuite === suite) {\n        // if errSuite is current suite\n        // continue to the next sibling suite\n        return done();\n      }\n      // errSuite is among the parents of current suite\n      // stop execution of errSuite and all sub-suites\n      return done(errSuite);\n    }\n\n    if (self._abort) {\n      return done();\n    }\n\n    var curr = suite.suites[i++];\n    if (!curr) {\n      return done();\n    }\n\n    // Avoid grep neglecting large number of tests causing a\n    // huge recursive loop and thus a maximum call stack error.\n    // See comment in `this.runTests()` for more information.\n    if (self._grep !== self._defaultGrep) {\n      Runner.immediately(function() {\n        self.runSuite(curr, next);\n      });\n    } else {\n      self.runSuite(curr, next);\n    }\n  }\n\n  function done(errSuite) {\n    self.suite = suite;\n    self.nextSuite = next;\n\n    if (afterAllHookCalled) {\n      fn(errSuite);\n    } else {\n      // mark that the afterAll block has been called once\n      // and so can be skipped if there is an error in it.\n      afterAllHookCalled = true;\n\n      // remove reference to test\n      delete self.test;\n\n      self.hook('afterAll', function() {\n        self.emit('suite end', suite);\n        fn(errSuite);\n      });\n    }\n  }\n\n  this.nextSuite = next;\n\n  this.hook('beforeAll', function(err) {\n    if (err) {\n      return done();\n    }\n    self.runTests(suite, next);\n  });\n};\n\n/**\n * Handle uncaught exceptions.\n *\n * @param {Error} err\n * @api private\n */\nRunner.prototype.uncaught = function(err) {\n  if (err) {\n    debug('uncaught exception %s', err !== function() {\n      return this;\n    }.call(err) ? err : (err.message || err));\n  } else {\n    debug('uncaught undefined exception');\n    err = undefinedError();\n  }\n  err.uncaught = true;\n\n  var runnable = this.currentRunnable;\n\n  if (!runnable) {\n    runnable = new Runnable('Uncaught error outside test suite');\n    runnable.parent = this.suite;\n\n    if (this.started) {\n      this.fail(runnable, err);\n    } else {\n      // Can't recover from this failure\n      this.emit('start');\n      this.fail(runnable, err);\n      this.emit('end');\n    }\n\n    return;\n  }\n\n  runnable.clearTimeout();\n\n  // Ignore errors if complete\n  if (runnable.state) {\n    return;\n  }\n  this.fail(runnable, err);\n\n  // recover from test\n  if (runnable.type === 'test') {\n    this.emit('test end', runnable);\n    this.hookUp('afterEach', this.next);\n    return;\n  }\n\n // recover from hooks\n  if (runnable.type === 'hook') {\n    var errSuite = this.suite;\n    // if hook failure is in afterEach block\n    if (runnable.fullTitle().indexOf('after each') > -1) {\n      return this.hookErr(err, errSuite, true);\n    }\n    // if hook failure is in beforeEach block\n    if (runnable.fullTitle().indexOf('before each') > -1) {\n      return this.hookErr(err, errSuite, false);\n    }\n    // if hook failure is in after or before blocks\n    return this.nextSuite(errSuite);\n  }\n\n  // bail\n  this.emit('end');\n};\n\n/**\n * Cleans up the references to all the deferred functions\n * (before/after/beforeEach/afterEach) and tests of a Suite.\n * These must be deleted otherwise a memory leak can happen,\n * as those functions may reference variables from closures,\n * thus those variables can never be garbage collected as long\n * as the deferred functions exist.\n *\n * @param {Suite} suite\n */\nfunction cleanSuiteReferences(suite) {\n  function cleanArrReferences(arr) {\n    for (var i = 0; i < arr.length; i++) {\n      delete arr[i].fn;\n    }\n  }\n\n  if (isArray(suite._beforeAll)) {\n    cleanArrReferences(suite._beforeAll);\n  }\n\n  if (isArray(suite._beforeEach)) {\n    cleanArrReferences(suite._beforeEach);\n  }\n\n  if (isArray(suite._afterAll)) {\n    cleanArrReferences(suite._afterAll);\n  }\n\n  if (isArray(suite._afterEach)) {\n    cleanArrReferences(suite._afterEach);\n  }\n\n  for (var i = 0; i < suite.tests.length; i++) {\n    delete suite.tests[i].fn;\n  }\n}\n\n/**\n * Run the root suite and invoke `fn(failures)`\n * on completion.\n *\n * @param {Function} fn\n * @return {Runner} for chaining\n * @api public\n * @param {Function} fn\n * @return {Runner} Runner instance.\n */\nRunner.prototype.run = function(fn) {\n  var self = this;\n  var rootSuite = this.suite;\n\n  fn = fn || function() {};\n\n  function uncaught(err) {\n    self.uncaught(err);\n  }\n\n  function start() {\n    self.started = true;\n    self.emit('start');\n    self.runSuite(rootSuite, function() {\n      debug('finished running');\n      self.emit('end');\n    });\n  }\n\n  debug('start');\n\n  // references cleanup to avoid memory leaks\n  this.on('suite end', cleanSuiteReferences);\n\n  // callback\n  this.on('end', function() {\n    debug('end');\n    process.removeListener('uncaughtException', uncaught);\n    fn(self.failures);\n  });\n\n  // uncaught exception\n  process.on('uncaughtException', uncaught);\n\n  if (this._delay) {\n    // for reporters, I guess.\n    // might be nice to debounce some dots while we wait.\n    this.emit('waiting', rootSuite);\n    rootSuite.once('run', start);\n  } else {\n    start();\n  }\n\n  return this;\n};\n\n/**\n * Cleanly abort execution.\n *\n * @api public\n * @return {Runner} Runner instance.\n */\nRunner.prototype.abort = function() {\n  debug('aborting');\n  this._abort = true;\n\n  return this;\n};\n\n/**\n * Filter leaks with the given globals flagged as `ok`.\n *\n * @api private\n * @param {Array} ok\n * @param {Array} globals\n * @return {Array}\n */\nfunction filterLeaks(ok, globals) {\n  return filter(globals, function(key) {\n    // Firefox and Chrome exposes iframes as index inside the window object\n    if (/^d+/.test(key)) {\n      return false;\n    }\n\n    // in firefox\n    // if runner runs in an iframe, this iframe's window.getInterface method not init at first\n    // it is assigned in some seconds\n    if (global.navigator && (/^getInterface/).test(key)) {\n      return false;\n    }\n\n    // an iframe could be approached by window[iframeIndex]\n    // in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak\n    if (global.navigator && (/^\\d+/).test(key)) {\n      return false;\n    }\n\n    // Opera and IE expose global variables for HTML element IDs (issue #243)\n    if (/^mocha-/.test(key)) {\n      return false;\n    }\n\n    var matched = filter(ok, function(ok) {\n      if (~ok.indexOf('*')) {\n        return key.indexOf(ok.split('*')[0]) === 0;\n      }\n      return key === ok;\n    });\n    return !matched.length && (!global.navigator || key !== 'onerror');\n  });\n}\n\n/**\n * Array of globals dependent on the environment.\n *\n * @return {Array}\n * @api private\n */\nfunction extraGlobals() {\n  if (typeof process === 'object' && typeof process.version === 'string') {\n    var parts = process.version.split('.');\n    var nodeVersion = utils.reduce(parts, function(a, v) {\n      return a << 8 | v;\n    });\n\n    // 'errno' was renamed to process._errno in v0.9.11.\n\n    if (nodeVersion < 0x00090B) {\n      return ['errno'];\n    }\n  }\n\n  return [];\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./pending\":16,\"./runnable\":35,\"./utils\":39,\"_process\":51,\"debug\":2,\"events\":3}],37:[function(require,module,exports){\n/**\n * Module dependencies.\n */\n\nvar EventEmitter = require('events').EventEmitter;\nvar Hook = require('./hook');\nvar utils = require('./utils');\nvar inherits = utils.inherits;\nvar debug = require('debug')('mocha:suite');\nvar milliseconds = require('./ms');\n\n/**\n * Expose `Suite`.\n */\n\nexports = module.exports = Suite;\n\n/**\n * Create a new `Suite` with the given `title` and parent `Suite`. When a suite\n * with the same title is already present, that suite is returned to provide\n * nicer reporter and more flexible meta-testing.\n *\n * @api public\n * @param {Suite} parent\n * @param {string} title\n * @return {Suite}\n */\nexports.create = function(parent, title) {\n  var suite = new Suite(title, parent.ctx);\n  suite.parent = parent;\n  if (parent.pending) {\n    suite.pending = true;\n  }\n  title = suite.fullTitle();\n  parent.addSuite(suite);\n  return suite;\n};\n\n/**\n * Initialize a new `Suite` with the given `title` and `ctx`.\n *\n * @api private\n * @param {string} title\n * @param {Context} parentContext\n */\nfunction Suite(title, parentContext) {\n  this.title = title;\n  function Context() {}\n  Context.prototype = parentContext;\n  this.ctx = new Context();\n  this.suites = [];\n  this.tests = [];\n  this.pending = false;\n  this._beforeEach = [];\n  this._beforeAll = [];\n  this._afterEach = [];\n  this._afterAll = [];\n  this.root = !title;\n  this._timeout = 2000;\n  this._enableTimeouts = true;\n  this._slow = 75;\n  this._bail = false;\n  this._retries = -1;\n  this.delayed = false;\n}\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\ninherits(Suite, EventEmitter);\n\n/**\n * Return a clone of this `Suite`.\n *\n * @api private\n * @return {Suite}\n */\nSuite.prototype.clone = function() {\n  var suite = new Suite(this.title);\n  debug('clone');\n  suite.ctx = this.ctx;\n  suite.timeout(this.timeout());\n  suite.retries(this.retries());\n  suite.enableTimeouts(this.enableTimeouts());\n  suite.slow(this.slow());\n  suite.bail(this.bail());\n  return suite;\n};\n\n/**\n * Set timeout `ms` or short-hand such as \"2s\".\n *\n * @api private\n * @param {number|string} ms\n * @return {Suite|number} for chaining\n */\nSuite.prototype.timeout = function(ms) {\n  if (!arguments.length) {\n    return this._timeout;\n  }\n  if (ms.toString() === '0') {\n    this._enableTimeouts = false;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('timeout %d', ms);\n  this._timeout = parseInt(ms, 10);\n  return this;\n};\n\n/**\n * Set number of times to retry a failed test.\n *\n * @api private\n * @param {number|string} n\n * @return {Suite|number} for chaining\n */\nSuite.prototype.retries = function(n) {\n  if (!arguments.length) {\n    return this._retries;\n  }\n  debug('retries %d', n);\n  this._retries = parseInt(n, 10) || 0;\n  return this;\n};\n\n/**\n  * Set timeout to `enabled`.\n  *\n  * @api private\n  * @param {boolean} enabled\n  * @return {Suite|boolean} self or enabled\n  */\nSuite.prototype.enableTimeouts = function(enabled) {\n  if (!arguments.length) {\n    return this._enableTimeouts;\n  }\n  debug('enableTimeouts %s', enabled);\n  this._enableTimeouts = enabled;\n  return this;\n};\n\n/**\n * Set slow `ms` or short-hand such as \"2s\".\n *\n * @api private\n * @param {number|string} ms\n * @return {Suite|number} for chaining\n */\nSuite.prototype.slow = function(ms) {\n  if (!arguments.length) {\n    return this._slow;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('slow %d', ms);\n  this._slow = ms;\n  return this;\n};\n\n/**\n * Sets whether to bail after first error.\n *\n * @api private\n * @param {boolean} bail\n * @return {Suite|number} for chaining\n */\nSuite.prototype.bail = function(bail) {\n  if (!arguments.length) {\n    return this._bail;\n  }\n  debug('bail %s', bail);\n  this._bail = bail;\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` before running tests.\n *\n * @api private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.beforeAll = function(title, fn) {\n  if (this.pending) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"before all\" hook' + (title ? ': ' + title : '');\n\n  var hook = new Hook(title, fn);\n  hook.parent = this;\n  hook.timeout(this.timeout());\n  hook.retries(this.retries());\n  hook.enableTimeouts(this.enableTimeouts());\n  hook.slow(this.slow());\n  hook.ctx = this.ctx;\n  this._beforeAll.push(hook);\n  this.emit('beforeAll', hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` after running tests.\n *\n * @api private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.afterAll = function(title, fn) {\n  if (this.pending) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"after all\" hook' + (title ? ': ' + title : '');\n\n  var hook = new Hook(title, fn);\n  hook.parent = this;\n  hook.timeout(this.timeout());\n  hook.retries(this.retries());\n  hook.enableTimeouts(this.enableTimeouts());\n  hook.slow(this.slow());\n  hook.ctx = this.ctx;\n  this._afterAll.push(hook);\n  this.emit('afterAll', hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` before each test case.\n *\n * @api private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.beforeEach = function(title, fn) {\n  if (this.pending) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"before each\" hook' + (title ? ': ' + title : '');\n\n  var hook = new Hook(title, fn);\n  hook.parent = this;\n  hook.timeout(this.timeout());\n  hook.retries(this.retries());\n  hook.enableTimeouts(this.enableTimeouts());\n  hook.slow(this.slow());\n  hook.ctx = this.ctx;\n  this._beforeEach.push(hook);\n  this.emit('beforeEach', hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` after each test case.\n *\n * @api private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.afterEach = function(title, fn) {\n  if (this.pending) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"after each\" hook' + (title ? ': ' + title : '');\n\n  var hook = new Hook(title, fn);\n  hook.parent = this;\n  hook.timeout(this.timeout());\n  hook.retries(this.retries());\n  hook.enableTimeouts(this.enableTimeouts());\n  hook.slow(this.slow());\n  hook.ctx = this.ctx;\n  this._afterEach.push(hook);\n  this.emit('afterEach', hook);\n  return this;\n};\n\n/**\n * Add a test `suite`.\n *\n * @api private\n * @param {Suite} suite\n * @return {Suite} for chaining\n */\nSuite.prototype.addSuite = function(suite) {\n  suite.parent = this;\n  suite.timeout(this.timeout());\n  suite.retries(this.retries());\n  suite.enableTimeouts(this.enableTimeouts());\n  suite.slow(this.slow());\n  suite.bail(this.bail());\n  this.suites.push(suite);\n  this.emit('suite', suite);\n  return this;\n};\n\n/**\n * Add a `test` to this suite.\n *\n * @api private\n * @param {Test} test\n * @return {Suite} for chaining\n */\nSuite.prototype.addTest = function(test) {\n  test.parent = this;\n  test.timeout(this.timeout());\n  test.retries(this.retries());\n  test.enableTimeouts(this.enableTimeouts());\n  test.slow(this.slow());\n  test.ctx = this.ctx;\n  this.tests.push(test);\n  this.emit('test', test);\n  return this;\n};\n\n/**\n * Return the full title generated by recursively concatenating the parent's\n * full title.\n *\n * @api public\n * @return {string}\n */\nSuite.prototype.fullTitle = function() {\n  if (this.parent) {\n    var full = this.parent.fullTitle();\n    if (full) {\n      return full + ' ' + this.title;\n    }\n  }\n  return this.title;\n};\n\n/**\n * Return the total number of tests.\n *\n * @api public\n * @return {number}\n */\nSuite.prototype.total = function() {\n  return utils.reduce(this.suites, function(sum, suite) {\n    return sum + suite.total();\n  }, 0) + this.tests.length;\n};\n\n/**\n * Iterates through each suite recursively to find all tests. Applies a\n * function in the format `fn(test)`.\n *\n * @api private\n * @param {Function} fn\n * @return {Suite}\n */\nSuite.prototype.eachTest = function(fn) {\n  utils.forEach(this.tests, fn);\n  utils.forEach(this.suites, function(suite) {\n    suite.eachTest(fn);\n  });\n  return this;\n};\n\n/**\n * This will run the root suite if we happen to be running in delayed mode.\n */\nSuite.prototype.run = function run() {\n  if (this.root) {\n    this.emit('run');\n  }\n};\n\n},{\"./hook\":7,\"./ms\":15,\"./utils\":39,\"debug\":2,\"events\":3}],38:[function(require,module,exports){\n/**\n * Module dependencies.\n */\n\nvar Runnable = require('./runnable');\nvar inherits = require('./utils').inherits;\n\n/**\n * Expose `Test`.\n */\n\nmodule.exports = Test;\n\n/**\n * Initialize a new `Test` with the given `title` and callback `fn`.\n *\n * @api private\n * @param {String} title\n * @param {Function} fn\n */\nfunction Test(title, fn) {\n  Runnable.call(this, title, fn);\n  this.pending = !fn;\n  this.type = 'test';\n  this.body = (fn || '').toString();\n}\n\n/**\n * Inherit from `Runnable.prototype`.\n */\ninherits(Test, Runnable);\n\nTest.prototype.clone = function() {\n  var test = new Test(this.title, this.fn);\n  test.timeout(this.timeout());\n  test.slow(this.slow());\n  test.enableTimeouts(this.enableTimeouts());\n  test.retries(this.retries());\n  test.currentRetry(this.currentRetry());\n  test.globals(this.globals());\n  test.parent = this.parent;\n  test.file = this.file;\n  test.ctx = this.ctx;\n  return test;\n};\n\n},{\"./runnable\":35,\"./utils\":39}],39:[function(require,module,exports){\n(function (process,Buffer){\n/* eslint-env browser */\n\n/**\n * Module dependencies.\n */\n\nvar basename = require('path').basename;\nvar debug = require('debug')('mocha:watch');\nvar exists = require('fs').existsSync || require('path').existsSync;\nvar glob = require('glob');\nvar join = require('path').join;\nvar readdirSync = require('fs').readdirSync;\nvar statSync = require('fs').statSync;\nvar watchFile = require('fs').watchFile;\n\n/**\n * Ignored directories.\n */\n\nvar ignore = ['node_modules', '.git'];\n\nexports.inherits = require('util').inherits;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @api private\n * @param  {string} html\n * @return {string}\n */\nexports.escape = function(html) {\n  return String(html)\n    .replace(/&/g, '&amp;')\n    .replace(/\"/g, '&quot;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;');\n};\n\n/**\n * Array#forEach (<=IE8)\n *\n * @api private\n * @param {Array} arr\n * @param {Function} fn\n * @param {Object} scope\n */\nexports.forEach = function(arr, fn, scope) {\n  for (var i = 0, l = arr.length; i < l; i++) {\n    fn.call(scope, arr[i], i);\n  }\n};\n\n/**\n * Test if the given obj is type of string.\n *\n * @api private\n * @param {Object} obj\n * @return {boolean}\n */\nexports.isString = function(obj) {\n  return typeof obj === 'string';\n};\n\n/**\n * Array#map (<=IE8)\n *\n * @api private\n * @param {Array} arr\n * @param {Function} fn\n * @param {Object} scope\n * @return {Array}\n */\nexports.map = function(arr, fn, scope) {\n  var result = [];\n  for (var i = 0, l = arr.length; i < l; i++) {\n    result.push(fn.call(scope, arr[i], i, arr));\n  }\n  return result;\n};\n\n/**\n * Array#indexOf (<=IE8)\n *\n * @api private\n * @param {Array} arr\n * @param {Object} obj to find index of\n * @param {number} start\n * @return {number}\n */\nexports.indexOf = function(arr, obj, start) {\n  for (var i = start || 0, l = arr.length; i < l; i++) {\n    if (arr[i] === obj) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n/**\n * Array#reduce (<=IE8)\n *\n * @api private\n * @param {Array} arr\n * @param {Function} fn\n * @param {Object} val Initial value.\n * @return {*}\n */\nexports.reduce = function(arr, fn, val) {\n  var rval = val;\n\n  for (var i = 0, l = arr.length; i < l; i++) {\n    rval = fn(rval, arr[i], i, arr);\n  }\n\n  return rval;\n};\n\n/**\n * Array#filter (<=IE8)\n *\n * @api private\n * @param {Array} arr\n * @param {Function} fn\n * @return {Array}\n */\nexports.filter = function(arr, fn) {\n  var ret = [];\n\n  for (var i = 0, l = arr.length; i < l; i++) {\n    var val = arr[i];\n    if (fn(val, i, arr)) {\n      ret.push(val);\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Object.keys (<=IE8)\n *\n * @api private\n * @param {Object} obj\n * @return {Array} keys\n */\nexports.keys = typeof Object.keys === 'function' ? Object.keys : function(obj) {\n  var keys = [];\n  var has = Object.prototype.hasOwnProperty; // for `window` on <=IE8\n\n  for (var key in obj) {\n    if (has.call(obj, key)) {\n      keys.push(key);\n    }\n  }\n\n  return keys;\n};\n\n/**\n * Watch the given `files` for changes\n * and invoke `fn(file)` on modification.\n *\n * @api private\n * @param {Array} files\n * @param {Function} fn\n */\nexports.watch = function(files, fn) {\n  var options = { interval: 100 };\n  files.forEach(function(file) {\n    debug('file %s', file);\n    watchFile(file, options, function(curr, prev) {\n      if (prev.mtime < curr.mtime) {\n        fn(file);\n      }\n    });\n  });\n};\n\n/**\n * Array.isArray (<=IE8)\n *\n * @api private\n * @param {Object} obj\n * @return {Boolean}\n */\nvar isArray = typeof Array.isArray === 'function' ? Array.isArray : function(obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n};\n\nexports.isArray = isArray;\n\n/**\n * Buffer.prototype.toJSON polyfill.\n *\n * @type {Function}\n */\nif (typeof Buffer !== 'undefined' && Buffer.prototype) {\n  Buffer.prototype.toJSON = Buffer.prototype.toJSON || function() {\n    return Array.prototype.slice.call(this, 0);\n  };\n}\n\n/**\n * Ignored files.\n *\n * @api private\n * @param {string} path\n * @return {boolean}\n */\nfunction ignored(path) {\n  return !~ignore.indexOf(path);\n}\n\n/**\n * Lookup files in the given `dir`.\n *\n * @api private\n * @param {string} dir\n * @param {string[]} [ext=['.js']]\n * @param {Array} [ret=[]]\n * @return {Array}\n */\nexports.files = function(dir, ext, ret) {\n  ret = ret || [];\n  ext = ext || ['js'];\n\n  var re = new RegExp('\\\\.(' + ext.join('|') + ')$');\n\n  readdirSync(dir)\n    .filter(ignored)\n    .forEach(function(path) {\n      path = join(dir, path);\n      if (statSync(path).isDirectory()) {\n        exports.files(path, ext, ret);\n      } else if (path.match(re)) {\n        ret.push(path);\n      }\n    });\n\n  return ret;\n};\n\n/**\n * Compute a slug from the given `str`.\n *\n * @api private\n * @param {string} str\n * @return {string}\n */\nexports.slug = function(str) {\n  return str\n    .toLowerCase()\n    .replace(/ +/g, '-')\n    .replace(/[^-\\w]/g, '');\n};\n\n/**\n * Strip the function definition from `str`, and re-indent for pre whitespace.\n *\n * @param {string} str\n * @return {string}\n */\nexports.clean = function(str) {\n  str = str\n    .replace(/\\r\\n?|[\\n\\u2028\\u2029]/g, '\\n').replace(/^\\uFEFF/, '')\n    .replace(/^function *\\(.*\\)\\s*\\{|\\(.*\\) *=> *\\{?/, '')\n    .replace(/\\s+\\}$/, '');\n\n  var spaces = str.match(/^\\n?( *)/)[1].length;\n  var tabs = str.match(/^\\n?(\\t*)/)[1].length;\n  var re = new RegExp('^\\n?' + (tabs ? '\\t' : ' ') + '{' + (tabs ? tabs : spaces) + '}', 'gm');\n\n  str = str.replace(re, '');\n\n  return exports.trim(str);\n};\n\n/**\n * Trim the given `str`.\n *\n * @api private\n * @param {string} str\n * @return {string}\n */\nexports.trim = function(str) {\n  return str.replace(/^\\s+|\\s+$/g, '');\n};\n\n/**\n * Parse the given `qs`.\n *\n * @api private\n * @param {string} qs\n * @return {Object}\n */\nexports.parseQuery = function(qs) {\n  return exports.reduce(qs.replace('?', '').split('&'), function(obj, pair) {\n    var i = pair.indexOf('=');\n    var key = pair.slice(0, i);\n    var val = pair.slice(++i);\n\n    obj[key] = decodeURIComponent(val);\n    return obj;\n  }, {});\n};\n\n/**\n * Highlight the given string of `js`.\n *\n * @api private\n * @param {string} js\n * @return {string}\n */\nfunction highlight(js) {\n  return js\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\\/\\/(.*)/gm, '<span class=\"comment\">//$1</span>')\n    .replace(/('.*?')/gm, '<span class=\"string\">$1</span>')\n    .replace(/(\\d+\\.\\d+)/gm, '<span class=\"number\">$1</span>')\n    .replace(/(\\d+)/gm, '<span class=\"number\">$1</span>')\n    .replace(/\\bnew[ \\t]+(\\w+)/gm, '<span class=\"keyword\">new</span> <span class=\"init\">$1</span>')\n    .replace(/\\b(function|new|throw|return|var|if|else)\\b/gm, '<span class=\"keyword\">$1</span>');\n}\n\n/**\n * Highlight the contents of tag `name`.\n *\n * @api private\n * @param {string} name\n */\nexports.highlightTags = function(name) {\n  var code = document.getElementById('mocha').getElementsByTagName(name);\n  for (var i = 0, len = code.length; i < len; ++i) {\n    code[i].innerHTML = highlight(code[i].innerHTML);\n  }\n};\n\n/**\n * If a value could have properties, and has none, this function is called,\n * which returns a string representation of the empty value.\n *\n * Functions w/ no properties return `'[Function]'`\n * Arrays w/ length === 0 return `'[]'`\n * Objects w/ no properties return `'{}'`\n * All else: return result of `value.toString()`\n *\n * @api private\n * @param {*} value The value to inspect.\n * @param {string} [type] The type of the value, if known.\n * @returns {string}\n */\nfunction emptyRepresentation(value, type) {\n  type = type || exports.type(value);\n\n  switch (type) {\n    case 'function':\n      return '[Function]';\n    case 'object':\n      return '{}';\n    case 'array':\n      return '[]';\n    default:\n      return value.toString();\n  }\n}\n\n/**\n * Takes some variable and asks `Object.prototype.toString()` what it thinks it\n * is.\n *\n * @api private\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\n * @param {*} value The value to test.\n * @returns {string}\n * @example\n * type({}) // 'object'\n * type([]) // 'array'\n * type(1) // 'number'\n * type(false) // 'boolean'\n * type(Infinity) // 'number'\n * type(null) // 'null'\n * type(new Date()) // 'date'\n * type(/foo/) // 'regexp'\n * type('type') // 'string'\n * type(global) // 'global'\n */\nexports.type = function type(value) {\n  if (value === undefined) {\n    return 'undefined';\n  } else if (value === null) {\n    return 'null';\n  } else if (typeof Buffer !== 'undefined' && Buffer.isBuffer(value)) {\n    return 'buffer';\n  }\n  return Object.prototype.toString.call(value)\n    .replace(/^\\[.+\\s(.+?)\\]$/, '$1')\n    .toLowerCase();\n};\n\n/**\n * Stringify `value`. Different behavior depending on type of value:\n *\n * - If `value` is undefined or null, return `'[undefined]'` or `'[null]'`, respectively.\n * - If `value` is not an object, function or array, return result of `value.toString()` wrapped in double-quotes.\n * - If `value` is an *empty* object, function, or array, return result of function\n *   {@link emptyRepresentation}.\n * - If `value` has properties, call {@link exports.canonicalize} on it, then return result of\n *   JSON.stringify().\n *\n * @api private\n * @see exports.type\n * @param {*} value\n * @return {string}\n */\nexports.stringify = function(value) {\n  var type = exports.type(value);\n\n  if (!~exports.indexOf(['object', 'array', 'function'], type)) {\n    if (type !== 'buffer') {\n      return jsonStringify(value);\n    }\n    var json = value.toJSON();\n    // Based on the toJSON result\n    return jsonStringify(json.data && json.type ? json.data : json, 2)\n      .replace(/,(\\n|$)/g, '$1');\n  }\n\n  for (var prop in value) {\n    if (Object.prototype.hasOwnProperty.call(value, prop)) {\n      return jsonStringify(exports.canonicalize(value), 2).replace(/,(\\n|$)/g, '$1');\n    }\n  }\n\n  return emptyRepresentation(value, type);\n};\n\n/**\n * like JSON.stringify but more sense.\n *\n * @api private\n * @param {Object}  object\n * @param {number=} spaces\n * @param {number=} depth\n * @returns {*}\n */\nfunction jsonStringify(object, spaces, depth) {\n  if (typeof spaces === 'undefined') {\n    // primitive types\n    return _stringify(object);\n  }\n\n  depth = depth || 1;\n  var space = spaces * depth;\n  var str = isArray(object) ? '[' : '{';\n  var end = isArray(object) ? ']' : '}';\n  var length = object.length || exports.keys(object).length;\n  // `.repeat()` polyfill\n  function repeat(s, n) {\n    return new Array(n).join(s);\n  }\n\n  function _stringify(val) {\n    switch (exports.type(val)) {\n      case 'null':\n      case 'undefined':\n        val = '[' + val + ']';\n        break;\n      case 'array':\n      case 'object':\n        val = jsonStringify(val, spaces, depth + 1);\n        break;\n      case 'boolean':\n      case 'regexp':\n      case 'number':\n        val = val === 0 && (1 / val) === -Infinity // `-0`\n          ? '-0'\n          : val.toString();\n        break;\n      case 'date':\n        var sDate = isNaN(val.getTime())        // Invalid date\n          ? val.toString()\n          : val.toISOString();\n        val = '[Date: ' + sDate + ']';\n        break;\n      case 'buffer':\n        var json = val.toJSON();\n        // Based on the toJSON result\n        json = json.data && json.type ? json.data : json;\n        val = '[Buffer: ' + jsonStringify(json, 2, depth + 1) + ']';\n        break;\n      default:\n        val = (val === '[Function]' || val === '[Circular]')\n          ? val\n          : JSON.stringify(val); // string\n    }\n    return val;\n  }\n\n  for (var i in object) {\n    if (!object.hasOwnProperty(i)) {\n      continue; // not my business\n    }\n    --length;\n    str += '\\n ' + repeat(' ', space)\n      + (isArray(object) ? '' : '\"' + i + '\": ') // key\n      + _stringify(object[i])                     // value\n      + (length ? ',' : '');                     // comma\n  }\n\n  return str\n    // [], {}\n    + (str.length !== 1 ? '\\n' + repeat(' ', --space) + end : end);\n}\n\n/**\n * Test if a value is a buffer.\n *\n * @api private\n * @param {*} value The value to test.\n * @return {boolean} True if `value` is a buffer, otherwise false\n */\nexports.isBuffer = function(value) {\n  return typeof Buffer !== 'undefined' && Buffer.isBuffer(value);\n};\n\n/**\n * Return a new Thing that has the keys in sorted order. Recursive.\n *\n * If the Thing...\n * - has already been seen, return string `'[Circular]'`\n * - is `undefined`, return string `'[undefined]'`\n * - is `null`, return value `null`\n * - is some other primitive, return the value\n * - is not a primitive or an `Array`, `Object`, or `Function`, return the value of the Thing's `toString()` method\n * - is a non-empty `Array`, `Object`, or `Function`, return the result of calling this function again.\n * - is an empty `Array`, `Object`, or `Function`, return the result of calling `emptyRepresentation()`\n *\n * @api private\n * @see {@link exports.stringify}\n * @param {*} value Thing to inspect.  May or may not have properties.\n * @param {Array} [stack=[]] Stack of seen values\n * @return {(Object|Array|Function|string|undefined)}\n */\nexports.canonicalize = function(value, stack) {\n  var canonicalizedObj;\n  /* eslint-disable no-unused-vars */\n  var prop;\n  /* eslint-enable no-unused-vars */\n  var type = exports.type(value);\n  function withStack(value, fn) {\n    stack.push(value);\n    fn();\n    stack.pop();\n  }\n\n  stack = stack || [];\n\n  if (exports.indexOf(stack, value) !== -1) {\n    return '[Circular]';\n  }\n\n  switch (type) {\n    case 'undefined':\n    case 'buffer':\n    case 'null':\n      canonicalizedObj = value;\n      break;\n    case 'array':\n      withStack(value, function() {\n        canonicalizedObj = exports.map(value, function(item) {\n          return exports.canonicalize(item, stack);\n        });\n      });\n      break;\n    case 'function':\n      /* eslint-disable guard-for-in */\n      for (prop in value) {\n        canonicalizedObj = {};\n        break;\n      }\n      /* eslint-enable guard-for-in */\n      if (!canonicalizedObj) {\n        canonicalizedObj = emptyRepresentation(value, type);\n        break;\n      }\n    /* falls through */\n    case 'object':\n      canonicalizedObj = canonicalizedObj || {};\n      withStack(value, function() {\n        exports.forEach(exports.keys(value).sort(), function(key) {\n          canonicalizedObj[key] = exports.canonicalize(value[key], stack);\n        });\n      });\n      break;\n    case 'date':\n    case 'number':\n    case 'regexp':\n    case 'boolean':\n      canonicalizedObj = value;\n      break;\n    default:\n      canonicalizedObj = value + '';\n  }\n\n  return canonicalizedObj;\n};\n\n/**\n * Lookup file names at the given `path`.\n *\n * @api public\n * @param {string} path Base path to start searching from.\n * @param {string[]} extensions File extensions to look for.\n * @param {boolean} recursive Whether or not to recurse into subdirectories.\n * @return {string[]} An array of paths.\n */\nexports.lookupFiles = function lookupFiles(path, extensions, recursive) {\n  var files = [];\n  var re = new RegExp('\\\\.(' + extensions.join('|') + ')$');\n\n  if (!exists(path)) {\n    if (exists(path + '.js')) {\n      path += '.js';\n    } else {\n      files = glob.sync(path);\n      if (!files.length) {\n        throw new Error(\"cannot resolve path (or pattern) '\" + path + \"'\");\n      }\n      return files;\n    }\n  }\n\n  try {\n    var stat = statSync(path);\n    if (stat.isFile()) {\n      return path;\n    }\n  } catch (err) {\n    // ignore error\n    return;\n  }\n\n  readdirSync(path).forEach(function(file) {\n    file = join(path, file);\n    try {\n      var stat = statSync(file);\n      if (stat.isDirectory()) {\n        if (recursive) {\n          files = files.concat(lookupFiles(file, extensions, recursive));\n        }\n        return;\n      }\n    } catch (err) {\n      // ignore error\n      return;\n    }\n    if (!stat.isFile() || !re.test(file) || basename(file)[0] === '.') {\n      return;\n    }\n    files.push(file);\n  });\n\n  return files;\n};\n\n/**\n * Generate an undefined error with a message warning the user.\n *\n * @return {Error}\n */\n\nexports.undefinedError = function() {\n  return new Error('Caught undefined error, did you throw without specifying what?');\n};\n\n/**\n * Generate an undefined error if `err` is not defined.\n *\n * @param {Error} err\n * @return {Error}\n */\n\nexports.getError = function(err) {\n  return err || exports.undefinedError();\n};\n\n/**\n * @summary\n * This Filter based on `mocha-clean` module.(see: `github.com/rstacruz/mocha-clean`)\n * @description\n * When invoking this function you get a filter function that get the Error.stack as an input,\n * and return a prettify output.\n * (i.e: strip Mocha and internal node functions from stack trace).\n * @returns {Function}\n */\nexports.stackTraceFilter = function() {\n  // TODO: Replace with `process.browser`\n  var slash = '/';\n  var is = typeof document === 'undefined' ? { node: true } : { browser: true };\n  var cwd = is.node\n      ? process.cwd() + slash\n      : (typeof location === 'undefined' ? window.location : location).href.replace(/\\/[^\\/]*$/, '/');\n\n  function isMochaInternal(line) {\n    return (~line.indexOf('node_modules' + slash + 'mocha' + slash))\n      || (~line.indexOf('components' + slash + 'mochajs' + slash))\n      || (~line.indexOf('components' + slash + 'mocha' + slash))\n      || (~line.indexOf(slash + 'mocha.js'));\n  }\n\n  function isNodeInternal(line) {\n    return (~line.indexOf('(timers.js:'))\n      || (~line.indexOf('(events.js:'))\n      || (~line.indexOf('(node.js:'))\n      || (~line.indexOf('(module.js:'))\n      || (~line.indexOf('GeneratorFunctionPrototype.next (native)'))\n      || false;\n  }\n\n  return function(stack) {\n    stack = stack.split('\\n');\n\n    stack = exports.reduce(stack, function(list, line) {\n      if (isMochaInternal(line)) {\n        return list;\n      }\n\n      if (is.node && isNodeInternal(line)) {\n        return list;\n      }\n\n      // Clean up cwd(absolute)\n      list.push(line.replace(cwd, ''));\n      return list;\n    }, []);\n\n    return stack.join('\\n');\n  };\n};\n\n}).call(this,require('_process'),require(\"buffer\").Buffer)\n},{\"_process\":51,\"buffer\":43,\"debug\":2,\"fs\":41,\"glob\":41,\"path\":41,\"util\":66}],40:[function(require,module,exports){\n(function (process){\nvar WritableStream = require('stream').Writable\nvar inherits = require('util').inherits\n\nmodule.exports = BrowserStdout\n\n\ninherits(BrowserStdout, WritableStream)\n\nfunction BrowserStdout(opts) {\n  if (!(this instanceof BrowserStdout)) return new BrowserStdout(opts)\n\n  opts = opts || {}\n  WritableStream.call(this, opts)\n  this.label = (opts.label !== undefined) ? opts.label : 'stdout'\n}\n\nBrowserStdout.prototype._write = function(chunks, encoding, cb) {\n  var output = chunks.toString ? chunks.toString() : chunks\n  if (this.label === false) {\n    console.log(output)\n  } else {\n    console.log(this.label+':', output)\n  }\n  process.nextTick(cb)\n}\n\n}).call(this,require('_process'))\n},{\"_process\":51,\"stream\":63,\"util\":66}],41:[function(require,module,exports){\n\n},{}],42:[function(require,module,exports){\narguments[4][41][0].apply(exports,arguments)\n},{\"dup\":41}],43:[function(require,module,exports){\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('is-array')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192 // not used by this implementation\n\nvar rootParent = {}\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property\n *     on objects.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = (function () {\n  function Bar () {}\n  try {\n    var arr = new Uint8Array(1)\n    arr.foo = function () { return 42 }\n    arr.constructor = Bar\n    return arr.foo() === 42 && // typed array instances can be augmented\n        arr.constructor === Bar && // constructor can be set\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n})()\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\n/**\n * Class: Buffer\n * =============\n *\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\n * with function properties for all the node `Buffer` API functions. We use\n * `Uint8Array` so that square bracket notation works as expected -- it returns\n * a single octet.\n *\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\n * prototype.\n */\nfunction Buffer (arg) {\n  if (!(this instanceof Buffer)) {\n    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n    return new Buffer(arg)\n  }\n\n  this.length = 0\n  this.parent = undefined\n\n  // Common case.\n  if (typeof arg === 'number') {\n    return fromNumber(this, arg)\n  }\n\n  // Slightly less common case.\n  if (typeof arg === 'string') {\n    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n  }\n\n  // Unusual.\n  return fromObject(this, arg)\n}\n\nfunction fromNumber (that, length) {\n  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < length; i++) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n\n  // Assumption: byteLength() return value is always < kMaxLength.\n  var length = byteLength(string, encoding) | 0\n  that = allocate(that, length)\n\n  that.write(string, encoding)\n  return that\n}\n\nfunction fromObject (that, object) {\n  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n\n  if (isArray(object)) return fromArray(that, object)\n\n  if (object == null) {\n    throw new TypeError('must start with number, buffer, array or string')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined') {\n    if (object.buffer instanceof ArrayBuffer) {\n      return fromTypedArray(that, object)\n    }\n    if (object instanceof ArrayBuffer) {\n      return fromArrayBuffer(that, object)\n    }\n  }\n\n  if (object.length) return fromArrayLike(that, object)\n\n  return fromJsonObject(that, object)\n}\n\nfunction fromBuffer (that, buffer) {\n  var length = checked(buffer.length) | 0\n  that = allocate(that, length)\n  buffer.copy(that, 0, 0, length)\n  return that\n}\n\nfunction fromArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Duplicate of fromArray() to keep fromArray() monomorphic.\nfunction fromTypedArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  // Truncating the elements is probably not what people expect from typed\n  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n  // of the old Buffer constructor.\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    array.byteLength\n    that = Buffer._augment(new Uint8Array(array))\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromTypedArray(that, new Uint8Array(array))\n  }\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n// Returns a zero-length buffer for inputs that don't conform to the spec.\nfunction fromJsonObject (that, object) {\n  var array\n  var length = 0\n\n  if (object.type === 'Buffer' && isArray(object.data)) {\n    array = object.data\n    length = checked(array.length) | 0\n  }\n  that = allocate(that, length)\n\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction allocate (that, length) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = Buffer._augment(new Uint8Array(length))\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that.length = length\n    that._isBuffer = true\n  }\n\n  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n  if (fromPool) that.parent = rootParent\n\n  return that\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (subject, encoding) {\n  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\n  var buf = new Buffer(subject, encoding)\n  delete buf.parent\n  return buf\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  var i = 0\n  var len = Math.min(x, y)\n  while (i < len) {\n    if (a[i] !== b[i]) break\n\n    ++i\n  }\n\n  if (i !== len) {\n    x = a[i]\n    y = b[i]\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; i++) {\n      length += list[i].length\n    }\n  }\n\n  var buf = new Buffer(length)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\nfunction byteLength (string, encoding) {\n  if (typeof string !== 'string') string = '' + string\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'binary':\n      // Deprecated\n      case 'raw':\n      case 'raws':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\n// pre-set for values that may exist in the future\nBuffer.prototype.length = undefined\nBuffer.prototype.parent = undefined\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  start = start | 0\n  end = end === undefined || end === Infinity ? this.length : end | 0\n\n  if (!encoding) encoding = 'utf8'\n  if (start < 0) start = 0\n  if (end > this.length) end = this.length\n  if (end <= start) return ''\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'binary':\n        return binarySlice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return 0\n  return Buffer.compare(this, b)\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n  byteOffset >>= 0\n\n  if (this.length === 0) return -1\n  if (byteOffset >= this.length) return -1\n\n  // Negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\n  if (typeof val === 'string') {\n    if (val.length === 0) return -1 // special case: looking for empty string always fails\n    return String.prototype.indexOf.call(this, val, byteOffset)\n  }\n  if (Buffer.isBuffer(val)) {\n    return arrayIndexOf(this, val, byteOffset)\n  }\n  if (typeof val === 'number') {\n    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n    }\n    return arrayIndexOf(this, [ val ], byteOffset)\n  }\n\n  function arrayIndexOf (arr, val, byteOffset) {\n    var foundIndex = -1\n    for (var i = 0; byteOffset + i < arr.length; i++) {\n      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n      } else {\n        foundIndex = -1\n      }\n    }\n    return -1\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\n// `get` is deprecated\nBuffer.prototype.get = function get (offset) {\n  console.log('.get() is deprecated. Access using array indexes instead.')\n  return this.readUInt8(offset)\n}\n\n// `set` is deprecated\nBuffer.prototype.set = function set (v, offset) {\n  console.log('.set() is deprecated. Access using array indexes instead.')\n  return this.writeUInt8(v, offset)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) throw new Error('Invalid hex string')\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction binaryWrite (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    var swap = encoding\n    encoding = offset\n    offset = length | 0\n    length = swap\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'binary':\n        return binaryWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction binarySlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = Buffer._augment(this.subarray(start, end))\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  if (newBuf.length) newBuf.parent = this.parent || this\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = value\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = value\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = value\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = value\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = value\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = value\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = value\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n  if (offset < 0) throw new RangeError('index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; i--) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; i++) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    target._set(this.subarray(start, start + len), targetStart)\n  }\n\n  return len\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (end < start) throw new RangeError('end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\n  var i\n  if (typeof value === 'number') {\n    for (i = start; i < end; i++) {\n      this[i] = value\n    }\n  } else {\n    var bytes = utf8ToBytes(value.toString())\n    var len = bytes.length\n    for (i = start; i < end; i++) {\n      this[i] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n/**\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n */\nBuffer.prototype.toArrayBuffer = function toArrayBuffer () {\n  if (typeof Uint8Array !== 'undefined') {\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      return (new Buffer(this)).buffer\n    } else {\n      var buf = new Uint8Array(this.length)\n      for (var i = 0, len = buf.length; i < len; i += 1) {\n        buf[i] = this[i]\n      }\n      return buf.buffer\n    }\n  } else {\n    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n  }\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar BP = Buffer.prototype\n\n/**\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n */\nBuffer._augment = function _augment (arr) {\n  arr.constructor = Buffer\n  arr._isBuffer = true\n\n  // save reference to original Uint8Array set method before overwriting\n  arr._set = arr.set\n\n  // deprecated\n  arr.get = BP.get\n  arr.set = BP.set\n\n  arr.write = BP.write\n  arr.toString = BP.toString\n  arr.toLocaleString = BP.toString\n  arr.toJSON = BP.toJSON\n  arr.equals = BP.equals\n  arr.compare = BP.compare\n  arr.indexOf = BP.indexOf\n  arr.copy = BP.copy\n  arr.slice = BP.slice\n  arr.readUIntLE = BP.readUIntLE\n  arr.readUIntBE = BP.readUIntBE\n  arr.readUInt8 = BP.readUInt8\n  arr.readUInt16LE = BP.readUInt16LE\n  arr.readUInt16BE = BP.readUInt16BE\n  arr.readUInt32LE = BP.readUInt32LE\n  arr.readUInt32BE = BP.readUInt32BE\n  arr.readIntLE = BP.readIntLE\n  arr.readIntBE = BP.readIntBE\n  arr.readInt8 = BP.readInt8\n  arr.readInt16LE = BP.readInt16LE\n  arr.readInt16BE = BP.readInt16BE\n  arr.readInt32LE = BP.readInt32LE\n  arr.readInt32BE = BP.readInt32BE\n  arr.readFloatLE = BP.readFloatLE\n  arr.readFloatBE = BP.readFloatBE\n  arr.readDoubleLE = BP.readDoubleLE\n  arr.readDoubleBE = BP.readDoubleBE\n  arr.writeUInt8 = BP.writeUInt8\n  arr.writeUIntLE = BP.writeUIntLE\n  arr.writeUIntBE = BP.writeUIntBE\n  arr.writeUInt16LE = BP.writeUInt16LE\n  arr.writeUInt16BE = BP.writeUInt16BE\n  arr.writeUInt32LE = BP.writeUInt32LE\n  arr.writeUInt32BE = BP.writeUInt32BE\n  arr.writeIntLE = BP.writeIntLE\n  arr.writeIntBE = BP.writeIntBE\n  arr.writeInt8 = BP.writeInt8\n  arr.writeInt16LE = BP.writeInt16LE\n  arr.writeInt16BE = BP.writeInt16BE\n  arr.writeInt32LE = BP.writeInt32LE\n  arr.writeInt32BE = BP.writeInt32BE\n  arr.writeFloatLE = BP.writeFloatLE\n  arr.writeFloatBE = BP.writeFloatBE\n  arr.writeDoubleLE = BP.writeDoubleLE\n  arr.writeDoubleBE = BP.writeDoubleBE\n  arr.fill = BP.fill\n  arr.inspect = BP.inspect\n  arr.toArrayBuffer = BP.toArrayBuffer\n\n  return arr\n}\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; i++) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n},{\"base64-js\":44,\"ieee754\":45,\"is-array\":46}],44:[function(require,module,exports){\nvar lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n\t'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n\tvar PLUS   = '+'.charCodeAt(0)\n\tvar SLASH  = '/'.charCodeAt(0)\n\tvar NUMBER = '0'.charCodeAt(0)\n\tvar LOWER  = 'a'.charCodeAt(0)\n\tvar UPPER  = 'A'.charCodeAt(0)\n\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\n\tfunction decode (elt) {\n\t\tvar code = elt.charCodeAt(0)\n\t\tif (code === PLUS ||\n\t\t    code === PLUS_URL_SAFE)\n\t\t\treturn 62 // '+'\n\t\tif (code === SLASH ||\n\t\t    code === SLASH_URL_SAFE)\n\t\t\treturn 63 // '/'\n\t\tif (code < NUMBER)\n\t\t\treturn -1 //no match\n\t\tif (code < NUMBER + 10)\n\t\t\treturn code - NUMBER + 26 + 26\n\t\tif (code < UPPER + 26)\n\t\t\treturn code - UPPER\n\t\tif (code < LOWER + 26)\n\t\t\treturn code - LOWER + 26\n\t}\n\n\tfunction b64ToByteArray (b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr\n\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tvar len = b64.length\n\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\n\t\tvar L = 0\n\n\t\tfunction push (v) {\n\t\t\tarr[L++] = v\n\t\t}\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\tpush(tmp & 0xFF)\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\treturn arr\n\t}\n\n\tfunction uint8ToBase64 (uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length\n\n\t\tfunction encode (num) {\n\t\t\treturn lookup.charAt(num)\n\t\t}\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t}\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\toutput += tripletToBase64(temp)\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\toutput += '=='\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\toutput += '='\n\t\t\t\tbreak\n\t\t}\n\n\t\treturn output\n\t}\n\n\texports.toByteArray = b64ToByteArray\n\texports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n\n},{}],45:[function(require,module,exports){\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n},{}],46:[function(require,module,exports){\n\n/**\n * isArray\n */\n\nvar isArray = Array.isArray;\n\n/**\n * toString\n */\n\nvar str = Object.prototype.toString;\n\n/**\n * Whether or not the given `val`\n * is an array.\n *\n * example:\n *\n *        isArray([]);\n *        // > true\n *        isArray(arguments);\n *        // > false\n *        isArray('');\n *        // > false\n *\n * @param {mixed} val\n * @return {bool}\n */\n\nmodule.exports = isArray || function (val) {\n  return !! val && '[object Array]' == str.call(val);\n};\n\n},{}],47:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        len = arguments.length;\n        args = new Array(len - 1);\n        for (i = 1; i < len; i++)\n          args[i - 1] = arguments[i];\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    len = arguments.length;\n    args = new Array(len - 1);\n    for (i = 1; i < len; i++)\n      args[i - 1] = arguments[i];\n\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    var m;\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (isFunction(emitter._events[type]))\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n},{}],48:[function(require,module,exports){\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n},{}],49:[function(require,module,exports){\nmodule.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n},{}],50:[function(require,module,exports){\nexports.endianness = function () { return 'LE' };\n\nexports.hostname = function () {\n    if (typeof location !== 'undefined') {\n        return location.hostname\n    }\n    else return '';\n};\n\nexports.loadavg = function () { return [] };\n\nexports.uptime = function () { return 0 };\n\nexports.freemem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.totalmem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.cpus = function () { return [] };\n\nexports.type = function () { return 'Browser' };\n\nexports.release = function () {\n    if (typeof navigator !== 'undefined') {\n        return navigator.appVersion;\n    }\n    return '';\n};\n\nexports.networkInterfaces\n= exports.getNetworkInterfaces\n= function () { return {} };\n\nexports.arch = function () { return 'javascript' };\n\nexports.platform = function () { return 'browser' };\n\nexports.tmpdir = exports.tmpDir = function () {\n    return '/tmp';\n};\n\nexports.EOL = '\\n';\n\n},{}],51:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],52:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_duplex.js\")\n\n},{\"./lib/_stream_duplex.js\":53}],53:[function(require,module,exports){\n(function (process){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nforEach(objectKeys(Writable.prototype), function(method) {\n  if (!Duplex.prototype[method])\n    Duplex.prototype[method] = Writable.prototype[method];\n});\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false)\n    this.readable = false;\n\n  if (options && options.writable === false)\n    this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false)\n    this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended)\n    return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(this.end.bind(this));\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\n}).call(this,require('_process'))\n},{\"./_stream_readable\":55,\"./_stream_writable\":57,\"_process\":51,\"core-util-is\":58,\"inherits\":48}],54:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough))\n    return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n},{\"./_stream_transform\":56,\"core-util-is\":58,\"inherits\":48}],55:[function(require,module,exports){\n(function (process){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\nvar EE = require('events').EventEmitter;\n\n/*<replacement>*/\nif (!EE.listenerCount) EE.listenerCount = function(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\nvar Stream = require('stream');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar StringDecoder;\n\n\n/*<replacement>*/\nvar debug = require('util');\nif (debug && debug.debuglog) {\n  debug = debug.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\n\nutil.inherits(Readable, Stream);\n\nfunction ReadableState(options, stream) {\n  var Duplex = require('./_stream_duplex');\n\n  options = options || {};\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var defaultHwm = options.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.buffer = [];\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex)\n    this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // when piping, we only care about 'readable' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder)\n      StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  var Duplex = require('./_stream_duplex');\n\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n  var state = this._readableState;\n\n  if (util.isString(chunk) && !state.objectMode) {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = new Buffer(chunk, encoding);\n      encoding = '';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function(chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);\n  } else if (util.isNullOrUndefined(chunk)) {\n    state.reading = false;\n    if (!state.ended)\n      onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);\n    } else if (state.endEmitted && addToFront) {\n      var e = new Error('stream.unshift() after end event');\n      stream.emit('error', e);\n    } else {\n      if (state.decoder && !addToFront && !encoding)\n        chunk = state.decoder.write(chunk);\n\n      if (!addToFront)\n        state.reading = false;\n\n      // if we want the data now, just emit it.\n      if (state.flowing && state.length === 0 && !state.sync) {\n        stream.emit('data', chunk);\n        stream.read(0);\n      } else {\n        // update the buffer info.\n        state.length += state.objectMode ? 1 : chunk.length;\n        if (addToFront)\n          state.buffer.unshift(chunk);\n        else\n          state.buffer.push(chunk);\n\n        if (state.needReadable)\n          emitReadable(stream);\n      }\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended &&\n         (state.needReadable ||\n          state.length < state.highWaterMark ||\n          state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  if (!StringDecoder)\n    StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 128MB\nvar MAX_HWM = 0x800000;\nfunction roundUpToNextPowerOf2(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2\n    n--;\n    for (var p = 1; p < 32; p <<= 1) n |= n >> p;\n    n++;\n  }\n  return n;\n}\n\nfunction howMuchToRead(n, state) {\n  if (state.length === 0 && state.ended)\n    return 0;\n\n  if (state.objectMode)\n    return n === 0 ? 0 : 1;\n\n  if (isNaN(n) || util.isNull(n)) {\n    // only flow one buffer at a time\n    if (state.flowing && state.buffer.length)\n      return state.buffer[0].length;\n    else\n      return state.length;\n  }\n\n  if (n <= 0)\n    return 0;\n\n  // If we're asking for more than the target buffer level,\n  // then raise the water mark.  Bump up to the next highest\n  // power of 2, to prevent increasing it excessively in tiny\n  // amounts.\n  if (n > state.highWaterMark)\n    state.highWaterMark = roundUpToNextPowerOf2(n);\n\n  // don't have that much.  return null, unless we've ended.\n  if (n > state.length) {\n    if (!state.ended) {\n      state.needReadable = true;\n      return 0;\n    } else\n      return state.length;\n  }\n\n  return n;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  debug('read', n);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (!util.isNumber(n) || n > 0)\n    state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 &&\n      state.needReadable &&\n      (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended)\n      endReadable(this);\n    else\n      emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0)\n      endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  }\n\n  if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0)\n      state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n  }\n\n  // If _read pushed data synchronously, then `reading` will be false,\n  // and we need to re-evaluate how much data we can return to the user.\n  if (doRead && !state.reading)\n    n = howMuchToRead(nOrig, state);\n\n  var ret;\n  if (n > 0)\n    ret = fromList(n, state);\n  else\n    ret = null;\n\n  if (util.isNull(ret)) {\n    state.needReadable = true;\n    n = 0;\n  }\n\n  state.length -= n;\n\n  // If we have nothing in the buffer, then we want to know\n  // as soon as we *do* get something into the buffer.\n  if (state.length === 0 && !state.ended)\n    state.needReadable = true;\n\n  // If we tried to read() past the EOF, then emit end on the next tick.\n  if (nOrig !== n && state.ended && state.length === 0)\n    endReadable(this);\n\n  if (!util.isNull(ret))\n    this.emit('data', ret);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!util.isBuffer(chunk) &&\n      !util.isString(chunk) &&\n      !util.isNullOrUndefined(chunk) &&\n      !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n\nfunction onEofChunk(stream, state) {\n  if (state.decoder && !state.ended) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync)\n      process.nextTick(function() {\n        emitReadable_(stream);\n      });\n    else\n      emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(function() {\n      maybeReadMore_(stream, state);\n    });\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended &&\n         state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n    else\n      len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  this.emit('error', new Error('not implemented'));\n};\n\nReadable.prototype.pipe = function(dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted)\n    process.nextTick(endFn);\n  else\n    src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    debug('onunpipe');\n    if (readable === src) {\n      cleanup();\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', cleanup);\n    src.removeListener('data', ondata);\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain &&\n        (!dest._writableState || dest._writableState.needDrain))\n      ondrain();\n  }\n\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    if (false === ret) {\n      debug('false write response, pause',\n            src._readableState.awaitDrain);\n      src._readableState.awaitDrain++;\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EE.listenerCount(dest, 'error') === 0)\n      dest.emit('error', er);\n  }\n  // This is a brutally ugly hack to make sure that our error handler\n  // is attached before any userland ones.  NEVER DO THIS.\n  if (!dest._events || !dest._events.error)\n    dest.on('error', onerror);\n  else if (isArray(dest._events.error))\n    dest._events.error.unshift(onerror);\n  else\n    dest._events.error = [onerror, dest._events.error];\n\n\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain)\n      state.awaitDrain--;\n    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  var state = this._readableState;\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0)\n    return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes)\n      return this;\n\n    if (!dest)\n      dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest)\n      dest.emit('unpipe', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++)\n      dests[i].emit('unpipe', this);\n    return this;\n  }\n\n  // try to find the right one.\n  var i = indexOf(state.pipes, dest);\n  if (i === -1)\n    return this;\n\n  state.pipes.splice(i, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1)\n    state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function(ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  // If listening to data, and it has not explicitly been paused,\n  // then call resume to start the flow of data on the next tick.\n  if (ev === 'data' && false !== this._readableState.flowing) {\n    this.resume();\n  }\n\n  if (ev === 'readable' && this.readable) {\n    var state = this._readableState;\n    if (!state.readableListening) {\n      state.readableListening = true;\n      state.emittedReadable = false;\n      state.needReadable = true;\n      if (!state.reading) {\n        var self = this;\n        process.nextTick(function() {\n          debug('readable nexttick read 0');\n          self.read(0);\n        });\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    if (!state.reading) {\n      debug('resume read 0');\n      this.read(0);\n    }\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(function() {\n      resume_(stream, state);\n    });\n  }\n}\n\nfunction resume_(stream, state) {\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading)\n    stream.read(0);\n}\n\nReadable.prototype.pause = function() {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  if (state.flowing) {\n    do {\n      var chunk = stream.read();\n    } while (null !== chunk && state.flowing);\n  }\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function() {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length)\n        self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function(chunk) {\n    debug('wrapped data');\n    if (state.decoder)\n      chunk = state.decoder.write(chunk);\n    if (!chunk || !state.objectMode && !chunk.length)\n      return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {\n      this[i] = function(method) { return function() {\n        return stream[method].apply(stream, arguments);\n      }}(i);\n    }\n  }\n\n  // proxy certain important events.\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n  forEach(events, function(ev) {\n    stream.on(ev, self.emit.bind(self, ev));\n  });\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function(n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n  var list = state.buffer;\n  var length = state.length;\n  var stringMode = !!state.decoder;\n  var objectMode = !!state.objectMode;\n  var ret;\n\n  // nothing in the list, definitely empty.\n  if (list.length === 0)\n    return null;\n\n  if (length === 0)\n    ret = null;\n  else if (objectMode)\n    ret = list.shift();\n  else if (!n || n >= length) {\n    // read it all, truncate the array.\n    if (stringMode)\n      ret = list.join('');\n    else\n      ret = Buffer.concat(list, length);\n    list.length = 0;\n  } else {\n    // read just some of it.\n    if (n < list[0].length) {\n      // just take a part of the first list item.\n      // slice is the same for buffers and strings.\n      var buf = list[0];\n      ret = buf.slice(0, n);\n      list[0] = buf.slice(n);\n    } else if (n === list[0].length) {\n      // first list is a perfect match\n      ret = list.shift();\n    } else {\n      // complex case.\n      // we have enough to cover it, but it spans past the first buffer.\n      if (stringMode)\n        ret = '';\n      else\n        ret = new Buffer(n);\n\n      var c = 0;\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\n        var buf = list[0];\n        var cpy = Math.min(n - c, buf.length);\n\n        if (stringMode)\n          ret += buf.slice(0, cpy);\n        else\n          buf.copy(ret, c, 0, cpy);\n\n        if (cpy < buf.length)\n          list[0] = buf.slice(cpy);\n        else\n          list.shift();\n\n        c += cpy;\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0)\n    throw new Error('endReadable called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(function() {\n      // Check that we didn't get one last unshift.\n      if (!state.endEmitted && state.length === 0) {\n        state.endEmitted = true;\n        stream.readable = false;\n        stream.emit('end');\n      }\n    });\n  }\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf (xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n\n}).call(this,require('_process'))\n},{\"./_stream_duplex\":53,\"_process\":51,\"buffer\":43,\"core-util-is\":58,\"events\":47,\"inherits\":48,\"isarray\":49,\"stream\":63,\"string_decoder/\":64,\"util\":42}],56:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\n\nfunction TransformState(options, stream) {\n  this.afterTransform = function(er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb)\n    return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (!util.isNullOrUndefined(data))\n    stream.push(data);\n\n  if (cb)\n    cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\n\nfunction Transform(options) {\n  if (!(this instanceof Transform))\n    return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = new TransformState(options, this);\n\n  // when the writable side finishes, then flush out anything remaining.\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  this.once('prefinish', function() {\n    if (util.isFunction(this._flush))\n      this._flush(function(er) {\n        done(stream, er);\n      });\n    else\n      done(stream);\n  });\n}\n\nTransform.prototype.push = function(chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n  throw new Error('not implemented');\n};\n\nTransform.prototype._write = function(chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform ||\n        rs.needReadable ||\n        rs.length < rs.highWaterMark)\n      this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n  var ts = this._transformState;\n\n  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\n\nfunction done(stream, er) {\n  if (er)\n    return stream.emit('error', er);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length)\n    throw new Error('calling transform done when ws.length != 0');\n\n  if (ts.transforming)\n    throw new Error('calling transform done when still transforming');\n\n  return stream.push(null);\n}\n\n},{\"./_stream_duplex\":53,\"core-util-is\":58,\"inherits\":48}],57:[function(require,module,exports){\n(function (process){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, cb), and it'll handle all\n// the drain event emission and buffering.\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Stream = require('stream');\n\nutil.inherits(Writable, Stream);\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n}\n\nfunction WritableState(options, stream) {\n  var Duplex = require('./_stream_duplex');\n\n  options = options || {};\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = options.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex)\n    this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function(er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.buffer = [];\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n}\n\nfunction Writable(options) {\n  var Duplex = require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Duplex))\n    return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n  this.emit('error', new Error('Cannot pipe. Not readable.'));\n};\n\n\nfunction writeAfterEnd(stream, state, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  process.nextTick(function() {\n    cb(er);\n  });\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  if (!util.isBuffer(chunk) &&\n      !util.isString(chunk) &&\n      !util.isNullOrUndefined(chunk) &&\n      !state.objectMode) {\n    var er = new TypeError('Invalid non-string/buffer chunk');\n    stream.emit('error', er);\n    process.nextTick(function() {\n      cb(er);\n    });\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function(chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (util.isFunction(encoding)) {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (util.isBuffer(chunk))\n    encoding = 'buffer';\n  else if (!encoding)\n    encoding = state.defaultEncoding;\n\n  if (!util.isFunction(cb))\n    cb = function() {};\n\n  if (state.ended)\n    writeAfterEnd(this, state, cb);\n  else if (validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function() {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function() {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing &&\n        !state.corked &&\n        !state.finished &&\n        !state.bufferProcessing &&\n        state.buffer.length)\n      clearBuffer(this, state);\n  }\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode &&\n      state.decodeStrings !== false &&\n      util.isString(chunk)) {\n    chunk = new Buffer(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n  if (util.isBuffer(chunk))\n    encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing || state.corked)\n    state.buffer.push(new WriteReq(chunk, encoding, cb));\n  else\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev)\n    stream._writev(chunk, state.onwrite);\n  else\n    stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  if (sync)\n    process.nextTick(function() {\n      state.pendingcb--;\n      cb(er);\n    });\n  else {\n    state.pendingcb--;\n    cb(er);\n  }\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er)\n    onwriteError(stream, state, sync, er, cb);\n  else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(stream, state);\n\n    if (!finished &&\n        !state.corked &&\n        !state.bufferProcessing &&\n        state.buffer.length) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(function() {\n        afterWrite(stream, state, finished, cb);\n      });\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished)\n    onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n\n  if (stream._writev && state.buffer.length > 1) {\n    // Fast case, write everything using _writev()\n    var cbs = [];\n    for (var c = 0; c < state.buffer.length; c++)\n      cbs.push(state.buffer[c].callback);\n\n    // count the one we are adding, as well.\n    // TODO(isaacs) clean this up\n    state.pendingcb++;\n    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {\n      for (var i = 0; i < cbs.length; i++) {\n        state.pendingcb--;\n        cbs[i](err);\n      }\n    });\n\n    // Clear buffer\n    state.buffer = [];\n  } else {\n    // Slow case, write chunks one-by-one\n    for (var c = 0; c < state.buffer.length; c++) {\n      var entry = state.buffer[c];\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        c++;\n        break;\n      }\n    }\n\n    if (c < state.buffer.length)\n      state.buffer = state.buffer.slice(c);\n    else\n      state.buffer.length = 0;\n  }\n\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function(chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function(chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (util.isFunction(chunk)) {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (util.isFunction(encoding)) {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (!util.isNullOrUndefined(chunk))\n    this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished)\n    endWritable(this, state, cb);\n};\n\n\nfunction needFinish(stream, state) {\n  return (state.ending &&\n          state.length === 0 &&\n          !state.finished &&\n          !state.writing);\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished) {\n    state.prefinished = true;\n    stream.emit('prefinish');\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(stream, state);\n  if (need) {\n    if (state.pendingcb === 0) {\n      prefinish(stream, state);\n      state.finished = true;\n      stream.emit('finish');\n    } else\n      prefinish(stream, state);\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished)\n      process.nextTick(cb);\n    else\n      stream.once('finish', cb);\n  }\n  state.ended = true;\n}\n\n}).call(this,require('_process'))\n},{\"./_stream_duplex\":53,\"_process\":51,\"buffer\":43,\"core-util-is\":58,\"inherits\":48,\"stream\":63}],58:[function(require,module,exports){\n(function (Buffer){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nfunction isBuffer(arg) {\n  return Buffer.isBuffer(arg);\n}\nexports.isBuffer = isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":43}],59:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_passthrough.js\")\n\n},{\"./lib/_stream_passthrough.js\":54}],60:[function(require,module,exports){\nexports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = require('stream');\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n\n},{\"./lib/_stream_duplex.js\":53,\"./lib/_stream_passthrough.js\":54,\"./lib/_stream_readable.js\":55,\"./lib/_stream_transform.js\":56,\"./lib/_stream_writable.js\":57,\"stream\":63}],61:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_transform.js\")\n\n},{\"./lib/_stream_transform.js\":56}],62:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_writable.js\")\n\n},{\"./lib/_stream_writable.js\":57}],63:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('inherits');\n\ninherits(Stream, EE);\nStream.Readable = require('readable-stream/readable.js');\nStream.Writable = require('readable-stream/writable.js');\nStream.Duplex = require('readable-stream/duplex.js');\nStream.Transform = require('readable-stream/transform.js');\nStream.PassThrough = require('readable-stream/passthrough.js');\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n},{\"events\":47,\"inherits\":48,\"readable-stream/duplex.js\":52,\"readable-stream/passthrough.js\":59,\"readable-stream/readable.js\":60,\"readable-stream/transform.js\":61,\"readable-stream/writable.js\":62}],64:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Buffer = require('buffer').Buffer;\n\nvar isBufferEncoding = Buffer.isEncoding\n  || function(encoding) {\n       switch (encoding && encoding.toLowerCase()) {\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n         default: return false;\n       }\n     }\n\n\nfunction assertEncoding(encoding) {\n  if (encoding && !isBufferEncoding(encoding)) {\n    throw new Error('Unknown encoding: ' + encoding);\n  }\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\n//\n// @TODO Handling all encodings inside a single object makes it very difficult\n// to reason about this code, so it should be split up in the future.\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n// points as used by CESU-8.\nvar StringDecoder = exports.StringDecoder = function(encoding) {\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n  assertEncoding(encoding);\n  switch (this.encoding) {\n    case 'utf8':\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\n      this.surrogateSize = 3;\n      break;\n    case 'ucs2':\n    case 'utf16le':\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\n      this.surrogateSize = 2;\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\n      break;\n    case 'base64':\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n      this.surrogateSize = 3;\n      this.detectIncompleteChar = base64DetectIncompleteChar;\n      break;\n    default:\n      this.write = passThroughWrite;\n      return;\n  }\n\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n  this.charBuffer = new Buffer(6);\n  // Number of bytes received for the current incomplete multi-byte character.\n  this.charReceived = 0;\n  // Number of bytes expected for the current incomplete multi-byte character.\n  this.charLength = 0;\n};\n\n\n// write decodes the given buffer and returns it as JS string that is\n// guaranteed to not contain any partial multi-byte characters. Any partial\n// character found at the end of the buffer is buffered up, and will be\n// returned when calling write again with the remaining bytes.\n//\n// Note: Converting a Buffer containing an orphan surrogate to a String\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\n// Buffer#write) will replace incomplete surrogates with the unicode\n// replacement character. See https://codereview.chromium.org/121173009/ .\nStringDecoder.prototype.write = function(buffer) {\n  var charStr = '';\n  // if our last write ended with an incomplete multibyte character\n  while (this.charLength) {\n    // determine how many remaining bytes this buffer has to offer for this char\n    var available = (buffer.length >= this.charLength - this.charReceived) ?\n        this.charLength - this.charReceived :\n        buffer.length;\n\n    // add the new bytes to the char buffer\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n    this.charReceived += available;\n\n    if (this.charReceived < this.charLength) {\n      // still not enough chars in this buffer? wait for more ...\n      return '';\n    }\n\n    // remove bytes belonging to the current character from the buffer\n    buffer = buffer.slice(available, buffer.length);\n\n    // get the character that was split\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n    var charCode = charStr.charCodeAt(charStr.length - 1);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      this.charLength += this.surrogateSize;\n      charStr = '';\n      continue;\n    }\n    this.charReceived = this.charLength = 0;\n\n    // if there are no more bytes in this buffer, just emit our char\n    if (buffer.length === 0) {\n      return charStr;\n    }\n    break;\n  }\n\n  // determine and set charLength / charReceived\n  this.detectIncompleteChar(buffer);\n\n  var end = buffer.length;\n  if (this.charLength) {\n    // buffer the incomplete character bytes we got\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n    end -= this.charReceived;\n  }\n\n  charStr += buffer.toString(this.encoding, 0, end);\n\n  var end = charStr.length - 1;\n  var charCode = charStr.charCodeAt(end);\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n    var size = this.surrogateSize;\n    this.charLength += size;\n    this.charReceived += size;\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\n    buffer.copy(this.charBuffer, 0, 0, size);\n    return charStr.substring(0, end);\n  }\n\n  // or just emit the charStr\n  return charStr;\n};\n\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n// the end of the given buffer. If so, it sets this.charLength to the byte\n// length that character, and sets this.charReceived to the number of bytes\n// that are available for this character.\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n  // determine how many bytes we have to check at the end of this buffer\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n  // Figure out if one of the last i bytes of our buffer announces an\n  // incomplete char.\n  for (; i > 0; i--) {\n    var c = buffer[buffer.length - i];\n\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n    // 110XXXXX\n    if (i == 1 && c >> 5 == 0x06) {\n      this.charLength = 2;\n      break;\n    }\n\n    // 1110XXXX\n    if (i <= 2 && c >> 4 == 0x0E) {\n      this.charLength = 3;\n      break;\n    }\n\n    // 11110XXX\n    if (i <= 3 && c >> 3 == 0x1E) {\n      this.charLength = 4;\n      break;\n    }\n  }\n  this.charReceived = i;\n};\n\nStringDecoder.prototype.end = function(buffer) {\n  var res = '';\n  if (buffer && buffer.length)\n    res = this.write(buffer);\n\n  if (this.charReceived) {\n    var cr = this.charReceived;\n    var buf = this.charBuffer;\n    var enc = this.encoding;\n    res += buf.slice(0, cr).toString(enc);\n  }\n\n  return res;\n};\n\nfunction passThroughWrite(buffer) {\n  return buffer.toString(this.encoding);\n}\n\nfunction utf16DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 2;\n  this.charLength = this.charReceived ? 2 : 0;\n}\n\nfunction base64DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 3;\n  this.charLength = this.charReceived ? 3 : 0;\n}\n\n},{\"buffer\":43}],65:[function(require,module,exports){\nmodule.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n},{}],66:[function(require,module,exports){\n(function (process,global){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./support/isBuffer\":65,\"_process\":51,\"inherits\":48}],67:[function(require,module,exports){\n/* See LICENSE file for terms of use */\n\n/*\n * Text diff implementation.\n *\n * This library supports the following APIS:\n * JsDiff.diffChars: Character by character diff\n * JsDiff.diffWords: Word (as defined by \\b regex) diff which ignores whitespace\n * JsDiff.diffLines: Line based diff\n *\n * JsDiff.diffCss: Diff targeted at CSS content\n *\n * These methods are based on the implementation proposed in\n * \"An O(ND) Difference Algorithm and its Variations\" (Myers, 1986).\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927\n */\n(function(global, undefined) {\n  var objectPrototypeToString = Object.prototype.toString;\n\n  /*istanbul ignore next*/\n  function map(arr, mapper, that) {\n    if (Array.prototype.map) {\n      return Array.prototype.map.call(arr, mapper, that);\n    }\n\n    var other = new Array(arr.length);\n\n    for (var i = 0, n = arr.length; i < n; i++) {\n      other[i] = mapper.call(that, arr[i], i, arr);\n    }\n    return other;\n  }\n  function clonePath(path) {\n    return { newPos: path.newPos, components: path.components.slice(0) };\n  }\n  function removeEmpty(array) {\n    var ret = [];\n    for (var i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n    return ret;\n  }\n  function escapeHTML(s) {\n    var n = s;\n    n = n.replace(/&/g, '&amp;');\n    n = n.replace(/</g, '&lt;');\n    n = n.replace(/>/g, '&gt;');\n    n = n.replace(/\"/g, '&quot;');\n\n    return n;\n  }\n\n  // This function handles the presence of circular references by bailing out when encountering an\n  // object that is already on the \"stack\" of items being processed.\n  function canonicalize(obj, stack, replacementStack) {\n    stack = stack || [];\n    replacementStack = replacementStack || [];\n\n    var i;\n\n    for (i = 0; i < stack.length; i += 1) {\n      if (stack[i] === obj) {\n        return replacementStack[i];\n      }\n    }\n\n    var canonicalizedObj;\n\n    if ('[object Array]' === objectPrototypeToString.call(obj)) {\n      stack.push(obj);\n      canonicalizedObj = new Array(obj.length);\n      replacementStack.push(canonicalizedObj);\n      for (i = 0; i < obj.length; i += 1) {\n        canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack);\n      }\n      stack.pop();\n      replacementStack.pop();\n    } else if (typeof obj === 'object' && obj !== null) {\n      stack.push(obj);\n      canonicalizedObj = {};\n      replacementStack.push(canonicalizedObj);\n      var sortedKeys = [],\n          key;\n      for (key in obj) {\n        sortedKeys.push(key);\n      }\n      sortedKeys.sort();\n      for (i = 0; i < sortedKeys.length; i += 1) {\n        key = sortedKeys[i];\n        canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack);\n      }\n      stack.pop();\n      replacementStack.pop();\n    } else {\n      canonicalizedObj = obj;\n    }\n    return canonicalizedObj;\n  }\n\n  function buildValues(components, newString, oldString, useLongestToken) {\n    var componentPos = 0,\n        componentLen = components.length,\n        newPos = 0,\n        oldPos = 0;\n\n    for (; componentPos < componentLen; componentPos++) {\n      var component = components[componentPos];\n      if (!component.removed) {\n        if (!component.added && useLongestToken) {\n          var value = newString.slice(newPos, newPos + component.count);\n          value = map(value, function(value, i) {\n            var oldValue = oldString[oldPos + i];\n            return oldValue.length > value.length ? oldValue : value;\n          });\n\n          component.value = value.join('');\n        } else {\n          component.value = newString.slice(newPos, newPos + component.count).join('');\n        }\n        newPos += component.count;\n\n        // Common case\n        if (!component.added) {\n          oldPos += component.count;\n        }\n      } else {\n        component.value = oldString.slice(oldPos, oldPos + component.count).join('');\n        oldPos += component.count;\n\n        // Reverse add and remove so removes are output first to match common convention\n        // The diffing algorithm is tied to add then remove output and this is the simplest\n        // route to get the desired output with minimal overhead.\n        if (componentPos && components[componentPos - 1].added) {\n          var tmp = components[componentPos - 1];\n          components[componentPos - 1] = components[componentPos];\n          components[componentPos] = tmp;\n        }\n      }\n    }\n\n    return components;\n  }\n\n  function Diff(ignoreWhitespace) {\n    this.ignoreWhitespace = ignoreWhitespace;\n  }\n  Diff.prototype = {\n    diff: function(oldString, newString, callback) {\n      var self = this;\n\n      function done(value) {\n        if (callback) {\n          setTimeout(function() { callback(undefined, value); }, 0);\n          return true;\n        } else {\n          return value;\n        }\n      }\n\n      // Handle the identity case (this is due to unrolling editLength == 0\n      if (newString === oldString) {\n        return done([{ value: newString }]);\n      }\n      if (!newString) {\n        return done([{ value: oldString, removed: true }]);\n      }\n      if (!oldString) {\n        return done([{ value: newString, added: true }]);\n      }\n\n      newString = this.tokenize(newString);\n      oldString = this.tokenize(oldString);\n\n      var newLen = newString.length, oldLen = oldString.length;\n      var editLength = 1;\n      var maxEditLength = newLen + oldLen;\n      var bestPath = [{ newPos: -1, components: [] }];\n\n      // Seed editLength = 0, i.e. the content starts with the same values\n      var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n      if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n        // Identity per the equality and tokenizer\n        return done([{value: newString.join('')}]);\n      }\n\n      // Main worker method. checks all permutations of a given edit length for acceptance.\n      function execEditLength() {\n        for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n          var basePath;\n          var addPath = bestPath[diagonalPath - 1],\n              removePath = bestPath[diagonalPath + 1],\n              oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n          if (addPath) {\n            // No one else is going to attempt to use this value, clear it\n            bestPath[diagonalPath - 1] = undefined;\n          }\n\n          var canAdd = addPath && addPath.newPos + 1 < newLen,\n              canRemove = removePath && 0 <= oldPos && oldPos < oldLen;\n          if (!canAdd && !canRemove) {\n            // If this path is a terminal then prune\n            bestPath[diagonalPath] = undefined;\n            continue;\n          }\n\n          // Select the diagonal that we want to branch from. We select the prior\n          // path whose position in the new string is the farthest from the origin\n          // and does not pass the bounds of the diff graph\n          if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {\n            basePath = clonePath(removePath);\n            self.pushComponent(basePath.components, undefined, true);\n          } else {\n            basePath = addPath;   // No need to clone, we've pulled it from the list\n            basePath.newPos++;\n            self.pushComponent(basePath.components, true, undefined);\n          }\n\n          oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);\n\n          // If we have hit the end of both strings, then we are done\n          if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n            return done(buildValues(basePath.components, newString, oldString, self.useLongestToken));\n          } else {\n            // Otherwise track this path as a potential candidate and continue.\n            bestPath[diagonalPath] = basePath;\n          }\n        }\n\n        editLength++;\n      }\n\n      // Performs the length of edit iteration. Is a bit fugly as this has to support the\n      // sync and async mode which is never fun. Loops over execEditLength until a value\n      // is produced.\n      if (callback) {\n        (function exec() {\n          setTimeout(function() {\n            // This should not happen, but we want to be safe.\n            /*istanbul ignore next */\n            if (editLength > maxEditLength) {\n              return callback();\n            }\n\n            if (!execEditLength()) {\n              exec();\n            }\n          }, 0);\n        }());\n      } else {\n        while (editLength <= maxEditLength) {\n          var ret = execEditLength();\n          if (ret) {\n            return ret;\n          }\n        }\n      }\n    },\n\n    pushComponent: function(components, added, removed) {\n      var last = components[components.length - 1];\n      if (last && last.added === added && last.removed === removed) {\n        // We need to clone here as the component clone operation is just\n        // as shallow array clone\n        components[components.length - 1] = {count: last.count + 1, added: added, removed: removed };\n      } else {\n        components.push({count: 1, added: added, removed: removed });\n      }\n    },\n    extractCommon: function(basePath, newString, oldString, diagonalPath) {\n      var newLen = newString.length,\n          oldLen = oldString.length,\n          newPos = basePath.newPos,\n          oldPos = newPos - diagonalPath,\n\n          commonCount = 0;\n      while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n        newPos++;\n        oldPos++;\n        commonCount++;\n      }\n\n      if (commonCount) {\n        basePath.components.push({count: commonCount});\n      }\n\n      basePath.newPos = newPos;\n      return oldPos;\n    },\n\n    equals: function(left, right) {\n      var reWhitespace = /\\S/;\n      return left === right || (this.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right));\n    },\n    tokenize: function(value) {\n      return value.split('');\n    }\n  };\n\n  var CharDiff = new Diff();\n\n  var WordDiff = new Diff(true);\n  var WordWithSpaceDiff = new Diff();\n  WordDiff.tokenize = WordWithSpaceDiff.tokenize = function(value) {\n    return removeEmpty(value.split(/(\\s+|\\b)/));\n  };\n\n  var CssDiff = new Diff(true);\n  CssDiff.tokenize = function(value) {\n    return removeEmpty(value.split(/([{}:;,]|\\s+)/));\n  };\n\n  var LineDiff = new Diff();\n\n  var TrimmedLineDiff = new Diff();\n  TrimmedLineDiff.ignoreTrim = true;\n\n  LineDiff.tokenize = TrimmedLineDiff.tokenize = function(value) {\n    var retLines = [],\n        lines = value.split(/^/m);\n    for (var i = 0; i < lines.length; i++) {\n      var line = lines[i],\n          lastLine = lines[i - 1],\n          lastLineLastChar = lastLine && lastLine[lastLine.length - 1];\n\n      // Merge lines that may contain windows new lines\n      if (line === '\\n' && lastLineLastChar === '\\r') {\n          retLines[retLines.length - 1] = retLines[retLines.length - 1].slice(0, -1) + '\\r\\n';\n      } else {\n        if (this.ignoreTrim) {\n          line = line.trim();\n          // add a newline unless this is the last line.\n          if (i < lines.length - 1) {\n            line += '\\n';\n          }\n        }\n        retLines.push(line);\n      }\n    }\n\n    return retLines;\n  };\n\n  var PatchDiff = new Diff();\n  PatchDiff.tokenize = function(value) {\n    var ret = [],\n        linesAndNewlines = value.split(/(\\n|\\r\\n)/);\n\n    // Ignore the final empty token that occurs if the string ends with a new line\n    if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n      linesAndNewlines.pop();\n    }\n\n    // Merge the content and line separators into single tokens\n    for (var i = 0; i < linesAndNewlines.length; i++) {\n      var line = linesAndNewlines[i];\n\n      if (i % 2) {\n        ret[ret.length - 1] += line;\n      } else {\n        ret.push(line);\n      }\n    }\n    return ret;\n  };\n\n  var SentenceDiff = new Diff();\n  SentenceDiff.tokenize = function(value) {\n    return removeEmpty(value.split(/(\\S.+?[.!?])(?=\\s+|$)/));\n  };\n\n  var JsonDiff = new Diff();\n  // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n  // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n  JsonDiff.useLongestToken = true;\n  JsonDiff.tokenize = LineDiff.tokenize;\n  JsonDiff.equals = function(left, right) {\n    return LineDiff.equals(left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'));\n  };\n\n  var JsDiff = {\n    Diff: Diff,\n\n    diffChars: function(oldStr, newStr, callback) { return CharDiff.diff(oldStr, newStr, callback); },\n    diffWords: function(oldStr, newStr, callback) { return WordDiff.diff(oldStr, newStr, callback); },\n    diffWordsWithSpace: function(oldStr, newStr, callback) { return WordWithSpaceDiff.diff(oldStr, newStr, callback); },\n    diffLines: function(oldStr, newStr, callback) { return LineDiff.diff(oldStr, newStr, callback); },\n    diffTrimmedLines: function(oldStr, newStr, callback) { return TrimmedLineDiff.diff(oldStr, newStr, callback); },\n\n    diffSentences: function(oldStr, newStr, callback) { return SentenceDiff.diff(oldStr, newStr, callback); },\n\n    diffCss: function(oldStr, newStr, callback) { return CssDiff.diff(oldStr, newStr, callback); },\n    diffJson: function(oldObj, newObj, callback) {\n      return JsonDiff.diff(\n        typeof oldObj === 'string' ? oldObj : JSON.stringify(canonicalize(oldObj), undefined, '  '),\n        typeof newObj === 'string' ? newObj : JSON.stringify(canonicalize(newObj), undefined, '  '),\n        callback\n      );\n    },\n\n    createTwoFilesPatch: function(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader) {\n      var ret = [];\n\n      if (oldFileName == newFileName) {\n        ret.push('Index: ' + oldFileName);\n      }\n      ret.push('===================================================================');\n      ret.push('--- ' + oldFileName + (typeof oldHeader === 'undefined' ? '' : '\\t' + oldHeader));\n      ret.push('+++ ' + newFileName + (typeof newHeader === 'undefined' ? '' : '\\t' + newHeader));\n\n      var diff = PatchDiff.diff(oldStr, newStr);\n      diff.push({value: '', lines: []});   // Append an empty value to make cleanup easier\n\n      // Formats a given set of lines for printing as context lines in a patch\n      function contextLines(lines) {\n        return map(lines, function(entry) { return ' ' + entry; });\n      }\n\n      // Outputs the no newline at end of file warning if needed\n      function eofNL(curRange, i, current) {\n        var last = diff[diff.length - 2],\n            isLast = i === diff.length - 2,\n            isLastOfType = i === diff.length - 3 && current.added !== last.added;\n\n        // Figure out if this is the last line for the given file and missing NL\n        if (!(/\\n$/.test(current.value)) && (isLast || isLastOfType)) {\n          curRange.push('\\\\ No newline at end of file');\n        }\n      }\n\n      var oldRangeStart = 0, newRangeStart = 0, curRange = [],\n          oldLine = 1, newLine = 1;\n      for (var i = 0; i < diff.length; i++) {\n        var current = diff[i],\n            lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n        current.lines = lines;\n\n        if (current.added || current.removed) {\n          // If we have previous context, start with that\n          if (!oldRangeStart) {\n            var prev = diff[i - 1];\n            oldRangeStart = oldLine;\n            newRangeStart = newLine;\n\n            if (prev) {\n              curRange = contextLines(prev.lines.slice(-4));\n              oldRangeStart -= curRange.length;\n              newRangeStart -= curRange.length;\n            }\n          }\n\n          // Output our changes\n          curRange.push.apply(curRange, map(lines, function(entry) {\n            return (current.added ? '+' : '-') + entry;\n          }));\n          eofNL(curRange, i, current);\n\n          // Track the updated file position\n          if (current.added) {\n            newLine += lines.length;\n          } else {\n            oldLine += lines.length;\n          }\n        } else {\n          // Identical context lines. Track line changes\n          if (oldRangeStart) {\n            // Close out any changes that have been output (or join overlapping)\n            if (lines.length <= 8 && i < diff.length - 2) {\n              // Overlapping\n              curRange.push.apply(curRange, contextLines(lines));\n            } else {\n              // end the range and output\n              var contextSize = Math.min(lines.length, 4);\n              ret.push(\n                  '@@ -' + oldRangeStart + ',' + (oldLine - oldRangeStart + contextSize)\n                  + ' +' + newRangeStart + ',' + (newLine - newRangeStart + contextSize)\n                  + ' @@');\n              ret.push.apply(ret, curRange);\n              ret.push.apply(ret, contextLines(lines.slice(0, contextSize)));\n              if (lines.length <= 4) {\n                eofNL(ret, i, current);\n              }\n\n              oldRangeStart = 0;\n              newRangeStart = 0;\n              curRange = [];\n            }\n          }\n          oldLine += lines.length;\n          newLine += lines.length;\n        }\n      }\n\n      return ret.join('\\n') + '\\n';\n    },\n\n    createPatch: function(fileName, oldStr, newStr, oldHeader, newHeader) {\n      return JsDiff.createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader);\n    },\n\n    applyPatch: function(oldStr, uniDiff) {\n      var diffstr = uniDiff.split('\\n'),\n          hunks = [],\n          i = 0,\n          remEOFNL = false,\n          addEOFNL = false;\n\n      // Skip to the first change hunk\n      while (i < diffstr.length && !(/^@@/.test(diffstr[i]))) {\n        i++;\n      }\n\n      // Parse the unified diff\n      for (; i < diffstr.length; i++) {\n        if (diffstr[i][0] === '@') {\n          var chnukHeader = diffstr[i].split(/@@ -(\\d+),(\\d+) \\+(\\d+),(\\d+) @@/);\n          hunks.unshift({\n            start: chnukHeader[3],\n            oldlength: +chnukHeader[2],\n            removed: [],\n            newlength: chnukHeader[4],\n            added: []\n          });\n        } else if (diffstr[i][0] === '+') {\n          hunks[0].added.push(diffstr[i].substr(1));\n        } else if (diffstr[i][0] === '-') {\n          hunks[0].removed.push(diffstr[i].substr(1));\n        } else if (diffstr[i][0] === ' ') {\n          hunks[0].added.push(diffstr[i].substr(1));\n          hunks[0].removed.push(diffstr[i].substr(1));\n        } else if (diffstr[i][0] === '\\\\') {\n          if (diffstr[i - 1][0] === '+') {\n            remEOFNL = true;\n          } else if (diffstr[i - 1][0] === '-') {\n            addEOFNL = true;\n          }\n        }\n      }\n\n      // Apply the diff to the input\n      var lines = oldStr.split('\\n');\n      for (i = hunks.length - 1; i >= 0; i--) {\n        var hunk = hunks[i];\n        // Sanity check the input string. Bail if we don't match.\n        for (var j = 0; j < hunk.oldlength; j++) {\n          if (lines[hunk.start - 1 + j] !== hunk.removed[j]) {\n            return false;\n          }\n        }\n        Array.prototype.splice.apply(lines, [hunk.start - 1, hunk.oldlength].concat(hunk.added));\n      }\n\n      // Handle EOFNL insertion/removal\n      if (remEOFNL) {\n        while (!lines[lines.length - 1]) {\n          lines.pop();\n        }\n      } else if (addEOFNL) {\n        lines.push('');\n      }\n      return lines.join('\\n');\n    },\n\n    convertChangesToXML: function(changes) {\n      var ret = [];\n      for (var i = 0; i < changes.length; i++) {\n        var change = changes[i];\n        if (change.added) {\n          ret.push('<ins>');\n        } else if (change.removed) {\n          ret.push('<del>');\n        }\n\n        ret.push(escapeHTML(change.value));\n\n        if (change.added) {\n          ret.push('</ins>');\n        } else if (change.removed) {\n          ret.push('</del>');\n        }\n      }\n      return ret.join('');\n    },\n\n    // See: http://code.google.com/p/google-diff-match-patch/wiki/API\n    convertChangesToDMP: function(changes) {\n      var ret = [],\n          change,\n          operation;\n      for (var i = 0; i < changes.length; i++) {\n        change = changes[i];\n        if (change.added) {\n          operation = 1;\n        } else if (change.removed) {\n          operation = -1;\n        } else {\n          operation = 0;\n        }\n\n        ret.push([operation, change.value]);\n      }\n      return ret;\n    },\n\n    canonicalize: canonicalize\n  };\n\n  /*istanbul ignore next */\n  /*global module */\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = JsDiff;\n  } else if (typeof define === 'function' && define.amd) {\n    /*global define */\n    define([], function() { return JsDiff; });\n  } else if (typeof global.JsDiff === 'undefined') {\n    global.JsDiff = JsDiff;\n  }\n}(this));\n\n},{}],68:[function(require,module,exports){\n'use strict';\n\nvar matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\n\nmodule.exports = function (str) {\n\tif (typeof str !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\treturn str.replace(matchOperatorsRe,  '\\\\$&');\n};\n\n},{}],69:[function(require,module,exports){\n(function (process){\n// Growl - Copyright TJ Holowaychuk <tj@vision-media.ca> (MIT Licensed)\n\n/**\n * Module dependencies.\n */\n\nvar exec = require('child_process').exec\n  , fs = require('fs')\n  , path = require('path')\n  , exists = fs.existsSync || path.existsSync\n  , os = require('os')\n  , quote = JSON.stringify\n  , cmd;\n\nfunction which(name) {\n  var paths = process.env.PATH.split(':');\n  var loc;\n  \n  for (var i = 0, len = paths.length; i < len; ++i) {\n    loc = path.join(paths[i], name);\n    if (exists(loc)) return loc;\n  }\n}\n\nswitch(os.type()) {\n  case 'Darwin':\n    if (which('terminal-notifier')) {\n      cmd = {\n          type: \"Darwin-NotificationCenter\"\n        , pkg: \"terminal-notifier\"\n        , msg: '-message'\n        , title: '-title'\n        , subtitle: '-subtitle'\n        , priority: {\n              cmd: '-execute'\n            , range: []\n          }\n      };\n    } else {\n      cmd = {\n          type: \"Darwin-Growl\"\n        , pkg: \"growlnotify\"\n        , msg: '-m'\n        , sticky: '--sticky'\n        , priority: {\n              cmd: '--priority'\n            , range: [\n                -2\n              , -1\n              , 0\n              , 1\n              , 2\n              , \"Very Low\"\n              , \"Moderate\"\n              , \"Normal\"\n              , \"High\"\n              , \"Emergency\"\n            ]\n          }\n      };\n    }\n    break;\n  case 'Linux':\n    cmd = {\n        type: \"Linux\"\n      , pkg: \"notify-send\"\n      , msg: ''\n      , sticky: '-t 0'\n      , icon: '-i'\n      , priority: {\n          cmd: '-u'\n        , range: [\n            \"low\"\n          , \"normal\"\n          , \"critical\"\n        ]\n      }\n    };\n    break;\n  case 'Windows_NT':\n    cmd = {\n        type: \"Windows\"\n      , pkg: \"growlnotify\"\n      , msg: ''\n      , sticky: '/s:true'\n      , title: '/t:'\n      , icon: '/i:'\n      , priority: {\n            cmd: '/p:'\n          , range: [\n              -2\n            , -1\n            , 0\n            , 1\n            , 2\n          ]\n        }\n    };\n    break;\n}\n\n/**\n * Expose `growl`.\n */\n\nexports = module.exports = growl;\n\n/**\n * Node-growl version.\n */\n\nexports.version = '1.4.1'\n\n/**\n * Send growl notification _msg_ with _options_.\n *\n * Options:\n *\n *  - title   Notification title\n *  - sticky  Make the notification stick (defaults to false)\n *  - priority  Specify an int or named key (default is 0)\n *  - name    Application name (defaults to growlnotify)\n *  - image\n *    - path to an icon sets --iconpath\n *    - path to an image sets --image\n *    - capitalized word sets --appIcon\n *    - filename uses extname as --icon\n *    - otherwise treated as --icon\n *\n * Examples:\n *\n *   growl('New email')\n *   growl('5 new emails', { title: 'Thunderbird' })\n *   growl('Email sent', function(){\n *     // ... notification sent\n *   })\n *\n * @param {string} msg\n * @param {object} options\n * @param {function} fn\n * @api public\n */\n\nfunction growl(msg, options, fn) {\n  var image\n    , args\n    , options = options || {}\n    , fn = fn || function(){};\n\n  // noop\n  if (!cmd) return fn(new Error('growl not supported on this platform'));\n  args = [cmd.pkg];\n\n  // image\n  if (image = options.image) {\n    switch(cmd.type) {\n      case 'Darwin-Growl':\n        var flag, ext = path.extname(image).substr(1)\n        flag = flag || ext == 'icns' && 'iconpath'\n        flag = flag || /^[A-Z]/.test(image) && 'appIcon'\n        flag = flag || /^png|gif|jpe?g$/.test(ext) && 'image'\n        flag = flag || ext && (image = ext) && 'icon'\n        flag = flag || 'icon'\n        args.push('--' + flag, quote(image))\n        break;\n      case 'Linux':\n        args.push(cmd.icon, quote(image));\n        // libnotify defaults to sticky, set a hint for transient notifications\n        if (!options.sticky) args.push('--hint=int:transient:1');\n        break;\n      case 'Windows':\n        args.push(cmd.icon + quote(image));\n        break;\n    }\n  }\n\n  // sticky\n  if (options.sticky) args.push(cmd.sticky);\n\n  // priority\n  if (options.priority) {\n    var priority = options.priority + '';\n    var checkindexOf = cmd.priority.range.indexOf(priority);\n    if (~cmd.priority.range.indexOf(priority)) {\n      args.push(cmd.priority, options.priority);\n    }\n  }\n\n  // name\n  if (options.name && cmd.type === \"Darwin-Growl\") {\n    args.push('--name', options.name);\n  }\n\n  switch(cmd.type) {\n    case 'Darwin-Growl':\n      args.push(cmd.msg);\n      args.push(quote(msg));\n      if (options.title) args.push(quote(options.title));\n      break;\n    case 'Darwin-NotificationCenter':\n      args.push(cmd.msg);\n      args.push(quote(msg));\n      if (options.title) {\n        args.push(cmd.title);\n        args.push(quote(options.title));\n      }\n      if (options.subtitle) {\n        args.push(cmd.subtitle);\n        args.push(quote(options.subtitle));\n      }\n      break;\n    case 'Darwin-Growl':\n      args.push(cmd.msg);\n      args.push(quote(msg));\n      if (options.title) args.push(quote(options.title));\n      break;\n    case 'Linux':\n      if (options.title) {\n        args.push(quote(options.title));\n        args.push(cmd.msg);\n        args.push(quote(msg));\n      } else {\n        args.push(quote(msg));\n      }\n      break;\n    case 'Windows':\n      args.push(quote(msg));\n      if (options.title) args.push(cmd.title + quote(options.title));\n      break;\n  }\n\n  // execute\n  exec(args.join(' '), fn);\n};\n\n}).call(this,require('_process'))\n},{\"_process\":51,\"child_process\":41,\"fs\":41,\"os\":50,\"path\":41}],70:[function(require,module,exports){\n(function (process){\nvar path = require('path');\nvar fs = require('fs');\nvar _0777 = parseInt('0777', 8);\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, opts, f, made) {\n    if (typeof opts === 'function') {\n        f = opts;\n        opts = {};\n    }\n    else if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n    \n    var cb = f || function () {};\n    p = path.resolve(p);\n    \n    xfs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                mkdirP(path.dirname(p), opts, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, opts, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                xfs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, opts, made) {\n    if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    p = path.resolve(p);\n\n    try {\n        xfs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), opts, made);\n                sync(p, opts, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = xfs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n\n}).call(this,require('_process'))\n},{\"_process\":51,\"fs\":41,\"path\":41}],71:[function(require,module,exports){\n(function (process,global){\n/**\n * Shim process.stdout.\n */\n\nprocess.stdout = require('browser-stdout')();\n\nvar Mocha = require('../');\n\n/**\n * Create a Mocha instance.\n *\n * @return {undefined}\n */\n\nvar mocha = new Mocha({ reporter: 'html' });\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n\nvar uncaughtExceptionHandlers = [];\n\nvar originalOnerrorHandler = global.onerror;\n\n/**\n * Remove uncaughtException listener.\n * Revert to original onerror handler if previously defined.\n */\n\nprocess.removeListener = function(e, fn){\n  if ('uncaughtException' == e) {\n    if (originalOnerrorHandler) {\n      global.onerror = originalOnerrorHandler;\n    } else {\n      global.onerror = function() {};\n    }\n    var i = Mocha.utils.indexOf(uncaughtExceptionHandlers, fn);\n    if (i != -1) { uncaughtExceptionHandlers.splice(i, 1); }\n  }\n};\n\n/**\n * Implements uncaughtException listener.\n */\n\nprocess.on = function(e, fn){\n  if ('uncaughtException' == e) {\n    global.onerror = function(err, url, line){\n      fn(new Error(err + ' (' + url + ':' + line + ')'));\n      return !mocha.allowUncaught;\n    };\n    uncaughtExceptionHandlers.push(fn);\n  }\n};\n\n// The BDD UI is registered by default, but no UI will be functional in the\n// browser without an explicit call to the overridden `mocha.ui` (see below).\n// Ensure that this default UI does not expose its methods to the global scope.\nmocha.suite.removeAllListeners('pre-require');\n\nvar immediateQueue = []\n  , immediateTimeout;\n\nfunction timeslice() {\n  var immediateStart = new Date().getTime();\n  while (immediateQueue.length && (new Date().getTime() - immediateStart) < 100) {\n    immediateQueue.shift()();\n  }\n  if (immediateQueue.length) {\n    immediateTimeout = setTimeout(timeslice, 0);\n  } else {\n    immediateTimeout = null;\n  }\n}\n\n/**\n * High-performance override of Runner.immediately.\n */\n\nMocha.Runner.immediately = function(callback) {\n  immediateQueue.push(callback);\n  if (!immediateTimeout) {\n    immediateTimeout = setTimeout(timeslice, 0);\n  }\n};\n\n/**\n * Function to allow assertion libraries to throw errors directly into mocha.\n * This is useful when running tests in a browser because window.onerror will\n * only receive the 'message' attribute of the Error.\n */\nmocha.throwError = function(err) {\n  Mocha.utils.forEach(uncaughtExceptionHandlers, function (fn) {\n    fn(err);\n  });\n  throw err;\n};\n\n/**\n * Override ui to ensure that the ui functions are initialized.\n * Normally this would happen in Mocha.prototype.loadFiles.\n */\n\nmocha.ui = function(ui){\n  Mocha.prototype.ui.call(this, ui);\n  this.suite.emit('pre-require', global, null, this);\n  return this;\n};\n\n/**\n * Setup mocha with the given setting options.\n */\n\nmocha.setup = function(opts){\n  if ('string' == typeof opts) opts = { ui: opts };\n  for (var opt in opts) this[opt](opts[opt]);\n  return this;\n};\n\n/**\n * Run mocha, returning the Runner.\n */\n\nmocha.run = function(fn){\n  var options = mocha.options;\n  mocha.globals('location');\n\n  var query = Mocha.utils.parseQuery(global.location.search || '');\n  if (query.grep) mocha.grep(new RegExp(query.grep));\n  if (query.fgrep) mocha.grep(query.fgrep);\n  if (query.invert) mocha.invert();\n\n  return Mocha.prototype.run.call(mocha, function(err){\n    // The DOM Document is not available in Web Workers.\n    var document = global.document;\n    if (document && document.getElementById('mocha') && options.noHighlighting !== true) {\n      Mocha.utils.highlightTags('code');\n    }\n    if (fn) fn(err);\n  });\n};\n\n/**\n * Expose the process shim.\n * https://github.com/mochajs/mocha/pull/916\n */\n\nMocha.process = process;\n\n/**\n * Expose mocha.\n */\n\nglobal.Mocha = Mocha;\nglobal.mocha = mocha;\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../\":1,\"_process\":51,\"browser-stdout\":40}]},{},[71]);\n"

/***/ },
/* 9 */,
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {process.nextTick(function() {
		delete __webpack_require__.c[module.id];
		if(typeof window !== "undefined" && window.mochaPhantomJS)
			mochaPhantomJS.run();
		else
			mocha.run();
	});
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 11 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMjI1NTI4YzNjN2NiMzU4Mzk2MWQiLCJ3ZWJwYWNrOi8vLy4vdGVzdC5iYWJlbC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9tb2NoYS1sb2FkZXIvd2ViLmpzIiwid2VicGFjazovLy8uLi9+L21vY2hhL21vY2hhLmNzcz83NGEwIiwid2VicGFjazovLy8uLi9+L21vY2hhL21vY2hhLmNzcyIsIndlYnBhY2s6Ly8vLi4vfi9jc3MtbG9hZGVyL2Nzc1RvU3RyaW5nLmpzIiwid2VicGFjazovLy8uLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vbW9jaGEvbW9jaGEuanM/YzZhNCIsIndlYnBhY2s6Ly8vLi4vfi9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9tb2NoYS9tb2NoYS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9tb2NoYS1sb2FkZXIvc3RhcnQuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9+L25vZGUtbGlicy1icm93c2VyL34vcHJvY2Vzcy9icm93c2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRixFOzs7Ozs7QUNiQSwwQ0FBeUMsNENBQTRDOztBQUVyRjtBQUNBOzs7Ozs7O0FDSEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBeUg7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFzQixLQUFLLEVBQUUsSUFBSSxtSEFBbUgsdURBQXVELHVCQUF1QixLQUFLLCtKQUErSixJQUFJLEVBQUUsZ0RBQWdELEVBQUUsR0FBRyxPQUFPLEc7Ozs7Ozs7QUNBbGh3VTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7Ozs7OztBQ05EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCLFVBQVUiLCJmaWxlIjoiaW5saW5lLXNvdXJjZW1hcC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgMjI1NTI4YzNjN2NiMzU4Mzk2MWRcbiAqKi8iLCJyZXF1aXJlKFwiISEvVXNlcnMvY2hlbXpxbS9jb21wb25lbnQtZGV2L3N0YWNrLXNvdXJjZS1tYXAvbm9kZV9tb2R1bGVzL21vY2hhLWxvYWRlci93ZWIuanNcIik7XG5tb2NoYS5zZXR1cChcImJkZFwiKTtcbnJlcXVpcmUoXCIhIS9Vc2Vycy9jaGVtenFtL2NvbXBvbmVudC1kZXYvc3RhY2stc291cmNlLW1hcC90ZXN0L3Rlc3QuYmFiZWwuanNcIilcbnJlcXVpcmUoXCIhIS9Vc2Vycy9jaGVtenFtL2NvbXBvbmVudC1kZXYvc3RhY2stc291cmNlLW1hcC9ub2RlX21vZHVsZXMvbW9jaGEtbG9hZGVyL3N0YXJ0LmpzXCIpO1xuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdCgpO1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG5cdFx0bW9jaGEuc3VpdGUuc3VpdGVzLmxlbmd0aCA9IDA7XG5cdFx0dmFyIHN0YXRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vY2hhLXN0YXRzJyk7XG5cdFx0dmFyIHJlcG9ydCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2NoYS1yZXBvcnQnKTtcblx0XHRzdGF0cy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0YXRzKTtcblx0XHRyZXBvcnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChyZXBvcnQpO1xuXHR9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vbW9jaGEtbG9hZGVyIS4vdGVzdC5iYWJlbC5qc1xuICoqIG1vZHVsZSBpZCA9IDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImlmICghIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibW9jaGFcIikpIHsgZG9jdW1lbnQud3JpdGUoXCI8ZGl2IGlkPVxcXCJtb2NoYVxcXCI+PC9kaXY+XCIpOyB9XHJcblxyXG5yZXF1aXJlKFwiIXN0eWxlIWNzcyFtb2NoYS9tb2NoYS5jc3NcIik7XHJcbnJlcXVpcmUoXCIhc2NyaXB0IW1vY2hhL21vY2hhLmpzXCIpO1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vbW9jaGEtbG9hZGVyL3dlYi5qc1xuICoqIG1vZHVsZSBpZCA9IDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEvVXNlcnMvY2hlbXpxbS9jb21wb25lbnQtZGV2L3N0YWNrLXNvdXJjZS1tYXAvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhL1VzZXJzL2NoZW16cW0vY29tcG9uZW50LWRldi9zdGFjay1zb3VyY2UtbWFwL25vZGVfbW9kdWxlcy9tb2NoYS9tb2NoYS5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS9Vc2Vycy9jaGVtenFtL2NvbXBvbmVudC1kZXYvc3RhY2stc291cmNlLW1hcC9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEvVXNlcnMvY2hlbXpxbS9jb21wb25lbnQtZGV2L3N0YWNrLXNvdXJjZS1tYXAvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhL1VzZXJzL2NoZW16cW0vY29tcG9uZW50LWRldi9zdGFjay1zb3VyY2UtbWFwL25vZGVfbW9kdWxlcy9tb2NoYS9tb2NoYS5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEvVXNlcnMvY2hlbXpxbS9jb21wb25lbnQtZGV2L3N0YWNrLXNvdXJjZS1tYXAvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhL1VzZXJzL2NoZW16cW0vY29tcG9uZW50LWRldi9zdGFjay1zb3VyY2UtbWFwL25vZGVfbW9kdWxlcy9tb2NoYS9tb2NoYS5jc3NcIik7XG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHR9KTtcblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vc3R5bGUtbG9hZGVyIS4uL34vY3NzLWxvYWRlciEuLi9+L21vY2hhL21vY2hhLmNzc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIvVXNlcnMvY2hlbXpxbS9jb21wb25lbnQtZGV2L3N0YWNrLXNvdXJjZS1tYXAvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvY3NzVG9TdHJpbmcuanNcIikoKTtcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIkBjaGFyc2V0IFxcXCJ1dGYtOFxcXCI7XFxuXFxuYm9keSB7XFxuICBtYXJnaW46MDtcXG59XFxuXFxuI21vY2hhIHtcXG4gIGZvbnQ6IDIwcHgvMS41IFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsIEhlbHZldGljYSwgQXJpYWwsIHNhbnMtc2VyaWY7XFxuICBtYXJnaW46IDYwcHggNTBweDtcXG59XFxuXFxuI21vY2hhIHVsLFxcbiNtb2NoYSBsaSB7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG5cXG4jbW9jaGEgdWwge1xcbiAgbGlzdC1zdHlsZTogbm9uZTtcXG59XFxuXFxuI21vY2hhIGgxLFxcbiNtb2NoYSBoMiB7XFxuICBtYXJnaW46IDA7XFxufVxcblxcbiNtb2NoYSBoMSB7XFxuICBtYXJnaW4tdG9wOiAxNXB4O1xcbiAgZm9udC1zaXplOiAxZW07XFxuICBmb250LXdlaWdodDogMjAwO1xcbn1cXG5cXG4jbW9jaGEgaDEgYSB7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICBjb2xvcjogaW5oZXJpdDtcXG59XFxuXFxuI21vY2hhIGgxIGE6aG92ZXIge1xcbiAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxufVxcblxcbiNtb2NoYSAuc3VpdGUgLnN1aXRlIGgxIHtcXG4gIG1hcmdpbi10b3A6IDA7XFxuICBmb250LXNpemU6IC44ZW07XFxufVxcblxcbiNtb2NoYSAuaGlkZGVuIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcblxcbiNtb2NoYSBoMiB7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBmb250LXdlaWdodDogbm9ybWFsO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG4jbW9jaGEgLnN1aXRlIHtcXG4gIG1hcmdpbi1sZWZ0OiAxNXB4O1xcbn1cXG5cXG4jbW9jaGEgLnRlc3Qge1xcbiAgbWFyZ2luLWxlZnQ6IDE1cHg7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QucGVuZGluZzpob3ZlciBoMjo6YWZ0ZXIge1xcbiAgY29udGVudDogJyhwZW5kaW5nKSc7XFxuICBmb250LWZhbWlseTogYXJpYWwsIHNhbnMtc2VyaWY7XFxufVxcblxcbiNtb2NoYSAudGVzdC5wYXNzLm1lZGl1bSAuZHVyYXRpb24ge1xcbiAgYmFja2dyb3VuZDogI2MwOTg1MztcXG59XFxuXFxuI21vY2hhIC50ZXN0LnBhc3Muc2xvdyAuZHVyYXRpb24ge1xcbiAgYmFja2dyb3VuZDogI2I5NGE0ODtcXG59XFxuXFxuI21vY2hhIC50ZXN0LnBhc3M6OmJlZm9yZSB7XFxuICBjb250ZW50OiAn4pyTJztcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICBtYXJnaW4tcmlnaHQ6IDVweDtcXG4gIGNvbG9yOiAjMDBkNmIyO1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QucGFzcyAuZHVyYXRpb24ge1xcbiAgZm9udC1zaXplOiA5cHg7XFxuICBtYXJnaW4tbGVmdDogNXB4O1xcbiAgcGFkZGluZzogMnB4IDVweDtcXG4gIGNvbG9yOiAjZmZmO1xcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiBpbnNldCAwIDFweCAxcHggcmdiYSgwLDAsMCwuMik7XFxuICAtbW96LWJveC1zaGFkb3c6IGluc2V0IDAgMXB4IDFweCByZ2JhKDAsMCwwLC4yKTtcXG4gIGJveC1zaGFkb3c6IGluc2V0IDAgMXB4IDFweCByZ2JhKDAsMCwwLC4yKTtcXG4gIC13ZWJraXQtYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgLW1vei1ib3JkZXItcmFkaXVzOiA1cHg7XFxuICAtbXMtYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgLW8tYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QucGFzcy5mYXN0IC5kdXJhdGlvbiB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QucGVuZGluZyB7XFxuICBjb2xvcjogIzBiOTdjNDtcXG59XFxuXFxuI21vY2hhIC50ZXN0LnBlbmRpbmc6OmJlZm9yZSB7XFxuICBjb250ZW50OiAn4pemJztcXG4gIGNvbG9yOiAjMGI5N2M0O1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QuZmFpbCB7XFxuICBjb2xvcjogI2MwMDtcXG59XFxuXFxuI21vY2hhIC50ZXN0LmZhaWwgcHJlIHtcXG4gIGNvbG9yOiBibGFjaztcXG59XFxuXFxuI21vY2hhIC50ZXN0LmZhaWw6OmJlZm9yZSB7XFxuICBjb250ZW50OiAn4pyWJztcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICBtYXJnaW4tcmlnaHQ6IDVweDtcXG4gIGNvbG9yOiAjYzAwO1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QgcHJlLmVycm9yIHtcXG4gIGNvbG9yOiAjYzAwO1xcbiAgbWF4LWhlaWdodDogMzAwcHg7XFxuICBvdmVyZmxvdzogYXV0bztcXG59XFxuXFxuI21vY2hhIC50ZXN0IC5odG1sLWVycm9yIHtcXG4gIG92ZXJmbG93OiBhdXRvO1xcbiAgY29sb3I6IGJsYWNrO1xcbiAgbGluZS1oZWlnaHQ6IDEuNTtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICBjbGVhcjogbGVmdDtcXG4gIGZvbnQ6IDEycHgvMS41IG1vbmFjbywgbW9ub3NwYWNlO1xcbiAgbWFyZ2luOiA1cHg7XFxuICBwYWRkaW5nOiAxNXB4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2VlZTtcXG4gIG1heC13aWR0aDogODUlOyAvKigxKSovXFxuICBtYXgtd2lkdGg6IGNhbGMoMTAwJSAtIDQycHgpOyAvKigyKSovXFxuICBtYXgtaGVpZ2h0OiAzMDBweDtcXG4gIHdvcmQtd3JhcDogYnJlYWstd29yZDtcXG4gIGJvcmRlci1ib3R0b20tY29sb3I6ICNkZGQ7XFxuICAtd2Via2l0LWJvcmRlci1yYWRpdXM6IDNweDtcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogMCAxcHggM3B4ICNlZWU7XFxuICAtbW96LWJvcmRlci1yYWRpdXM6IDNweDtcXG4gIC1tb3otYm94LXNoYWRvdzogMCAxcHggM3B4ICNlZWU7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxufVxcblxcbiNtb2NoYSAudGVzdCAuaHRtbC1lcnJvciBwcmUuZXJyb3Ige1xcbiAgYm9yZGVyOiBub25lO1xcbiAgLXdlYmtpdC1ib3JkZXItcmFkaXVzOiBub25lO1xcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiBub25lO1xcbiAgLW1vei1ib3JkZXItcmFkaXVzOiBub25lO1xcbiAgLW1vei1ib3gtc2hhZG93OiBub25lO1xcbiAgcGFkZGluZzogMDtcXG4gIG1hcmdpbjogMDtcXG4gIG1hcmdpbi10b3A6IDE4cHg7XFxuICBtYXgtaGVpZ2h0OiBub25lO1xcbn1cXG5cXG4vKipcXG4gKiAoMSk6IGFwcHJveGltYXRlIGZvciBicm93c2VycyBub3Qgc3VwcG9ydGluZyBjYWxjXFxuICogKDIpOiA0MiA9IDIqMTUgKyAyKjEwICsgMioxIChwYWRkaW5nICsgbWFyZ2luICsgYm9yZGVyKVxcbiAqICAgICAgXl4gc2VyaW91c2x5XFxuICovXFxuI21vY2hhIC50ZXN0IHByZSB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgY2xlYXI6IGxlZnQ7XFxuICBmb250OiAxMnB4LzEuNSBtb25hY28sIG1vbm9zcGFjZTtcXG4gIG1hcmdpbjogNXB4O1xcbiAgcGFkZGluZzogMTVweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNlZWU7XFxuICBtYXgtd2lkdGg6IDg1JTsgLyooMSkqL1xcbiAgbWF4LXdpZHRoOiBjYWxjKDEwMCUgLSA0MnB4KTsgLyooMikqL1xcbiAgd29yZC13cmFwOiBicmVhay13b3JkO1xcbiAgYm9yZGVyLWJvdHRvbS1jb2xvcjogI2RkZDtcXG4gIC13ZWJraXQtYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiAwIDFweCAzcHggI2VlZTtcXG4gIC1tb3otYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgLW1vei1ib3gtc2hhZG93OiAwIDFweCAzcHggI2VlZTtcXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXG59XFxuXFxuI21vY2hhIC50ZXN0IGgyIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuXFxuI21vY2hhIC50ZXN0IGEucmVwbGF5IHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogM3B4O1xcbiAgcmlnaHQ6IDA7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICB3aWR0aDogMTVweDtcXG4gIGhlaWdodDogMTVweDtcXG4gIGxpbmUtaGVpZ2h0OiAxNXB4O1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgYmFja2dyb3VuZDogI2VlZTtcXG4gIGZvbnQtc2l6ZTogMTVweDtcXG4gIC1tb3otYm9yZGVyLXJhZGl1czogMTVweDtcXG4gIGJvcmRlci1yYWRpdXM6IDE1cHg7XFxuICAtd2Via2l0LXRyYW5zaXRpb246IG9wYWNpdHkgMjAwbXM7XFxuICAtbW96LXRyYW5zaXRpb246IG9wYWNpdHkgMjAwbXM7XFxuICB0cmFuc2l0aW9uOiBvcGFjaXR5IDIwMG1zO1xcbiAgb3BhY2l0eTogMC4zO1xcbiAgY29sb3I6ICM4ODg7XFxufVxcblxcbiNtb2NoYSAudGVzdDpob3ZlciBhLnJlcGxheSB7XFxuICBvcGFjaXR5OiAxO1xcbn1cXG5cXG4jbW9jaGEtcmVwb3J0LnBhc3MgLnRlc3QuZmFpbCB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG5cXG4jbW9jaGEtcmVwb3J0LmZhaWwgLnRlc3QucGFzcyB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG5cXG4jbW9jaGEtcmVwb3J0LnBlbmRpbmcgLnRlc3QucGFzcyxcXG4jbW9jaGEtcmVwb3J0LnBlbmRpbmcgLnRlc3QuZmFpbCB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG4jbW9jaGEtcmVwb3J0LnBlbmRpbmcgLnRlc3QucGFzcy5wZW5kaW5nIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG5cXG4jbW9jaGEtZXJyb3Ige1xcbiAgY29sb3I6ICNjMDA7XFxuICBmb250LXNpemU6IDEuNWVtO1xcbiAgZm9udC13ZWlnaHQ6IDEwMDtcXG4gIGxldHRlci1zcGFjaW5nOiAxcHg7XFxufVxcblxcbiNtb2NoYS1zdGF0cyB7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB0b3A6IDE1cHg7XFxuICByaWdodDogMTBweDtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIG1hcmdpbjogMDtcXG4gIGNvbG9yOiAjODg4O1xcbiAgei1pbmRleDogMTtcXG59XFxuXFxuI21vY2hhLXN0YXRzIC5wcm9ncmVzcyB7XFxuICBmbG9hdDogcmlnaHQ7XFxuICBwYWRkaW5nLXRvcDogMDtcXG59XFxuXFxuI21vY2hhLXN0YXRzIGVtIHtcXG4gIGNvbG9yOiBibGFjaztcXG59XFxuXFxuI21vY2hhLXN0YXRzIGEge1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgY29sb3I6IGluaGVyaXQ7XFxufVxcblxcbiNtb2NoYS1zdGF0cyBhOmhvdmVyIHtcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZWVlO1xcbn1cXG5cXG4jbW9jaGEtc3RhdHMgbGkge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgbWFyZ2luOiAwIDVweDtcXG4gIGxpc3Qtc3R5bGU6IG5vbmU7XFxuICBwYWRkaW5nLXRvcDogMTFweDtcXG59XFxuXFxuI21vY2hhLXN0YXRzIGNhbnZhcyB7XFxuICB3aWR0aDogNDBweDtcXG4gIGhlaWdodDogNDBweDtcXG59XFxuXFxuI21vY2hhIGNvZGUgLmNvbW1lbnQgeyBjb2xvcjogI2RkZDsgfVxcbiNtb2NoYSBjb2RlIC5pbml0IHsgY29sb3I6ICMyZjZmYWQ7IH1cXG4jbW9jaGEgY29kZSAuc3RyaW5nIHsgY29sb3I6ICM1ODkwYWQ7IH1cXG4jbW9jaGEgY29kZSAua2V5d29yZCB7IGNvbG9yOiAjOGE2MzQzOyB9XFxuI21vY2hhIGNvZGUgLm51bWJlciB7IGNvbG9yOiAjMmY2ZmFkOyB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC1kZXZpY2Utd2lkdGg6IDQ4MHB4KSB7XFxuICAjbW9jaGEge1xcbiAgICBtYXJnaW46IDYwcHggMHB4O1xcbiAgfVxcblxcbiAgI21vY2hhICNzdGF0cyB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIH1cXG59XFxuXCIsIFwiXCJdKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY3NzLWxvYWRlciEuLi9+L21vY2hhL21vY2hhLmNzc1xuICoqIG1vZHVsZSBpZCA9IDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGxpc3QgPSBbXTtcclxuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XHJcblx0XHR2YXIgcmVzdWx0ID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IHRoaXNbaV07XHJcblx0XHRcdGlmKGl0ZW1bMl0pIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGl0ZW1bMV0gKyBcIn1cIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goaXRlbVsxXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZXN1bHQuam9pbihcIlwiKTtcclxuXHR9O1xyXG5cdHJldHVybiBsaXN0O1xyXG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2Nzcy1sb2FkZXIvY3NzVG9TdHJpbmcuanNcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgc3R5bGVzSW5Eb20gPSB7fSxcclxuXHRtZW1vaXplID0gZnVuY3Rpb24oZm4pIHtcclxuXHRcdHZhciBtZW1vO1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdFx0cmV0dXJuIG1lbW87XHJcblx0XHR9O1xyXG5cdH0sXHJcblx0aXNJRTkgPSBtZW1vaXplKGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIC9tc2llIDlcXGIvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XHJcblx0fSksXHJcblx0Z2V0SGVhZEVsZW1lbnQgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcclxuXHR9KSxcclxuXHRzaW5nbGV0b25FbGVtZW50ID0gbnVsbCxcclxuXHRzaW5nbGV0b25Db3VudGVyID0gMDtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xyXG5cdGlmKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xyXG5cdFx0aWYodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XHJcblx0fVxyXG5cclxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XHJcblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxyXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNJRTkoKTtcclxuXHJcblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0KTtcclxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcclxuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XHJcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xyXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XHJcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcclxuXHRcdH1cclxuXHRcdGlmKG5ld0xpc3QpIHtcclxuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0KTtcclxuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xyXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XHJcblx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKVxyXG5cdFx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oKTtcclxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKSB7XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XHJcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcclxuXHRcdGlmKGRvbVN0eWxlKSB7XHJcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIHBhcnRzID0gW107XHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMobGlzdCkge1xyXG5cdHZhciBzdHlsZXMgPSBbXTtcclxuXHR2YXIgbmV3U3R5bGVzID0ge307XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcclxuXHRcdHZhciBpZCA9IGl0ZW1bMF07XHJcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcclxuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XHJcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcclxuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcclxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKVxyXG5cdFx0XHRzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XHJcblx0fVxyXG5cdHJldHVybiBzdHlsZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCgpIHtcclxuXHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xyXG5cdHZhciBoZWFkID0gZ2V0SGVhZEVsZW1lbnQoKTtcclxuXHRzdHlsZUVsZW1lbnQudHlwZSA9IFwidGV4dC9jc3NcIjtcclxuXHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0cmV0dXJuIHN0eWxlRWxlbWVudDtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XHJcblx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmU7XHJcblxyXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xyXG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KCkpO1xyXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpO1xyXG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpO1xyXG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0dXBkYXRlKG9iaik7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcclxuXHRcdGlmKG5ld09iaikge1xyXG5cdFx0XHRpZihuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJlbW92ZSgpO1xyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlcGxhY2VUZXh0KHNvdXJjZSwgaWQsIHJlcGxhY2VtZW50KSB7XHJcblx0dmFyIGJvdW5kYXJpZXMgPSBbXCIvKiogPj5cIiArIGlkICsgXCIgKiovXCIsIFwiLyoqIFwiICsgaWQgKyBcIjw8ICoqL1wiXTtcclxuXHR2YXIgc3RhcnQgPSBzb3VyY2UubGFzdEluZGV4T2YoYm91bmRhcmllc1swXSk7XHJcblx0dmFyIHdyYXBwZWRSZXBsYWNlbWVudCA9IHJlcGxhY2VtZW50XHJcblx0XHQ/IChib3VuZGFyaWVzWzBdICsgcmVwbGFjZW1lbnQgKyBib3VuZGFyaWVzWzFdKVxyXG5cdFx0OiBcIlwiO1xyXG5cdGlmIChzb3VyY2UubGFzdEluZGV4T2YoYm91bmRhcmllc1swXSkgPj0gMCkge1xyXG5cdFx0dmFyIGVuZCA9IHNvdXJjZS5sYXN0SW5kZXhPZihib3VuZGFyaWVzWzFdKSArIGJvdW5kYXJpZXNbMV0ubGVuZ3RoO1xyXG5cdFx0cmV0dXJuIHNvdXJjZS5zbGljZSgwLCBzdGFydCkgKyB3cmFwcGVkUmVwbGFjZW1lbnQgKyBzb3VyY2Uuc2xpY2UoZW5kKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmV0dXJuIHNvdXJjZSArIHdyYXBwZWRSZXBsYWNlbWVudDtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcclxuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XHJcblxyXG5cdGlmKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCwgaW5kZXgsIGNzcyk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcclxuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXM7XHJcblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XHJcblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlRWxlbWVudCwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IG9iai5jc3M7XHJcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xyXG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xyXG5cclxuXHRpZihzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkgKyBcIiAqL1wiO1xyXG5cdFx0XHRjc3MgPSBcIkBpbXBvcnQgdXJsKFxcXCJkYXRhOnRleHQvY3NzO2Jhc2U2NCxcIiArIGJ0b2EoY3NzKSArIFwiXFxcIilcIjtcclxuXHRcdH0gY2F0Y2goZSkge31cclxuXHR9XHJcblxyXG5cdGlmKG1lZGlhKSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXHJcblx0fVxyXG5cclxuXHRpZihzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcclxuXHR9IGVsc2Uge1xyXG5cdFx0d2hpbGUoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcclxuXHRcdH1cclxuXHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcclxuXHR9XHJcbn1cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcbiAqKiBtb2R1bGUgaWQgPSA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKFwiISEvVXNlcnMvY2hlbXpxbS9jb21wb25lbnQtZGV2L3N0YWNrLXNvdXJjZS1tYXAvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9Vc2Vycy9jaGVtenFtL2NvbXBvbmVudC1kZXYvc3RhY2stc291cmNlLW1hcC9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvVXNlcnMvY2hlbXpxbS9jb21wb25lbnQtZGV2L3N0YWNrLXNvdXJjZS1tYXAvbm9kZV9tb2R1bGVzL21vY2hhL21vY2hhLmpzXCIpKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9zY3JpcHQtbG9hZGVyIS4uL34vbW9jaGEvbW9jaGEuanNcbiAqKiBtb2R1bGUgaWQgPSA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNyYykge1xyXG5cdGlmICh0eXBlb2YgZXhlY1NjcmlwdCA9PT0gXCJmdW5jdGlvblwiKVxyXG5cdFx0ZXhlY1NjcmlwdChzcmMpO1xyXG5cdGVsc2VcclxuXHRcdGV2YWwuY2FsbChudWxsLCBzcmMpO1xyXG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXG4gKiogbW9kdWxlIGlkID0gN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XFxcImZ1bmN0aW9uXFxcIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcXFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcXFwiK28rXFxcIidcXFwiKTt0aHJvdyBmLmNvZGU9XFxcIk1PRFVMRV9OT1RfRk9VTkRcXFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XFxcImZ1bmN0aW9uXFxcIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxubW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzLmVudi5DT1ZcXG4gID8gcmVxdWlyZSgnLi9saWItY292L21vY2hhJylcXG4gIDogcmVxdWlyZSgnLi9saWIvbW9jaGEnKTtcXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiLi9saWItY292L21vY2hhXFxcIjp1bmRlZmluZWQsXFxcIi4vbGliL21vY2hhXFxcIjoxNCxcXFwiX3Byb2Nlc3NcXFwiOjUxfV0sMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHR5cGUpIHtcXG4gIHJldHVybiBmdW5jdGlvbigpIHt9O1xcbn07XFxuXFxufSx7fV0sMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyoqXFxuICogTW9kdWxlIGV4cG9ydHMuXFxuICovXFxuXFxuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XFxuXFxuLyoqXFxuICogT2JqZWN0I2hhc093blByb3BlcnR5IHJlZmVyZW5jZS5cXG4gKi9cXG52YXIgb2JqVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xcblxcbi8qKlxcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYW4gYXJyYXkuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdC5cXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhIGJvb2xlYW4sIG90aGVyd2lzZSBmYWxzZS5cXG4gKi9cXG5mdW5jdGlvbiBpc0FycmF5KHZhbCkge1xcbiAgcmV0dXJuIG9ialRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcXG59XFxuXFxuLyoqXFxuICogRXZlbnQgZW1pdHRlciBjb25zdHJ1Y3Rvci5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge31cXG5cXG4vKipcXG4gKiBBZGQgYSBsaXN0ZW5lci5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRXZlbnQgbmFtZS5cXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBFdmVudCBoYW5kbGVyLlxcbiAqIEByZXR1cm4ge0V2ZW50RW1pdHRlcn0gRW1pdHRlciBpbnN0YW5jZS5cXG4gKi9cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24obmFtZSwgZm4pIHtcXG4gIGlmICghdGhpcy4kZXZlbnRzKSB7XFxuICAgIHRoaXMuJGV2ZW50cyA9IHt9O1xcbiAgfVxcblxcbiAgaWYgKCF0aGlzLiRldmVudHNbbmFtZV0pIHtcXG4gICAgdGhpcy4kZXZlbnRzW25hbWVdID0gZm47XFxuICB9IGVsc2UgaWYgKGlzQXJyYXkodGhpcy4kZXZlbnRzW25hbWVdKSkge1xcbiAgICB0aGlzLiRldmVudHNbbmFtZV0ucHVzaChmbik7XFxuICB9IGVsc2Uge1xcbiAgICB0aGlzLiRldmVudHNbbmFtZV0gPSBbdGhpcy4kZXZlbnRzW25hbWVdLCBmbl07XFxuICB9XFxuXFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xcblxcbi8qKlxcbiAqIEFkZHMgYSB2b2xhdGlsZSBsaXN0ZW5lci5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRXZlbnQgbmFtZS5cXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBFdmVudCBoYW5kbGVyLlxcbiAqIEByZXR1cm4ge0V2ZW50RW1pdHRlcn0gRW1pdHRlciBpbnN0YW5jZS5cXG4gKi9cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihuYW1lLCBmbikge1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgZnVuY3Rpb24gb24oKSB7XFxuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIobmFtZSwgb24pO1xcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgfVxcblxcbiAgb24ubGlzdGVuZXIgPSBmbjtcXG4gIHRoaXMub24obmFtZSwgb24pO1xcblxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBSZW1vdmUgYSBsaXN0ZW5lci5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRXZlbnQgbmFtZS5cXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBFdmVudCBoYW5kbGVyLlxcbiAqIEByZXR1cm4ge0V2ZW50RW1pdHRlcn0gRW1pdHRlciBpbnN0YW5jZS5cXG4gKi9cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24obmFtZSwgZm4pIHtcXG4gIGlmICh0aGlzLiRldmVudHMgJiYgdGhpcy4kZXZlbnRzW25hbWVdKSB7XFxuICAgIHZhciBsaXN0ID0gdGhpcy4kZXZlbnRzW25hbWVdO1xcblxcbiAgICBpZiAoaXNBcnJheShsaXN0KSkge1xcbiAgICAgIHZhciBwb3MgPSAtMTtcXG5cXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgICAgICBpZiAobGlzdFtpXSA9PT0gZm4gfHwgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gZm4pKSB7XFxuICAgICAgICAgIHBvcyA9IGk7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAocG9zIDwgMCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgICAgfVxcblxcbiAgICAgIGxpc3Quc3BsaWNlKHBvcywgMSk7XFxuXFxuICAgICAgaWYgKCFsaXN0Lmxlbmd0aCkge1xcbiAgICAgICAgZGVsZXRlIHRoaXMuJGV2ZW50c1tuYW1lXTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAobGlzdCA9PT0gZm4gfHwgKGxpc3QubGlzdGVuZXIgJiYgbGlzdC5saXN0ZW5lciA9PT0gZm4pKSB7XFxuICAgICAgZGVsZXRlIHRoaXMuJGV2ZW50c1tuYW1lXTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBSZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgYW4gZXZlbnQuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEV2ZW50IG5hbWUuXFxuICogQHJldHVybiB7RXZlbnRFbWl0dGVyfSBFbWl0dGVyIGluc3RhbmNlLlxcbiAqL1xcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24obmFtZSkge1xcbiAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkge1xcbiAgICB0aGlzLiRldmVudHMgPSB7fTtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuXFxuICBpZiAodGhpcy4kZXZlbnRzICYmIHRoaXMuJGV2ZW50c1tuYW1lXSkge1xcbiAgICB0aGlzLiRldmVudHNbbmFtZV0gPSBudWxsO1xcbiAgfVxcblxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgYWxsIGxpc3RlbmVycyBmb3IgYSBnaXZlbiBldmVudC5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRXZlbnQgbmFtZS5cXG4gKiBAcmV0dXJuIHtFdmVudEVtaXR0ZXJ9IEVtaXR0ZXIgaW5zdGFuY2UuXFxuICovXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihuYW1lKSB7XFxuICBpZiAoIXRoaXMuJGV2ZW50cykge1xcbiAgICB0aGlzLiRldmVudHMgPSB7fTtcXG4gIH1cXG5cXG4gIGlmICghdGhpcy4kZXZlbnRzW25hbWVdKSB7XFxuICAgIHRoaXMuJGV2ZW50c1tuYW1lXSA9IFtdO1xcbiAgfVxcblxcbiAgaWYgKCFpc0FycmF5KHRoaXMuJGV2ZW50c1tuYW1lXSkpIHtcXG4gICAgdGhpcy4kZXZlbnRzW25hbWVdID0gW3RoaXMuJGV2ZW50c1tuYW1lXV07XFxuICB9XFxuXFxuICByZXR1cm4gdGhpcy4kZXZlbnRzW25hbWVdO1xcbn07XFxuXFxuLyoqXFxuICogRW1pdCBhbiBldmVudC5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRXZlbnQgbmFtZS5cXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGF0IGxlYXN0IG9uZSBoYW5kbGVyIHdhcyBpbnZva2VkLCBlbHNlIGZhbHNlLlxcbiAqL1xcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKG5hbWUpIHtcXG4gIGlmICghdGhpcy4kZXZlbnRzKSB7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG5cXG4gIHZhciBoYW5kbGVyID0gdGhpcy4kZXZlbnRzW25hbWVdO1xcblxcbiAgaWYgKCFoYW5kbGVyKSB7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG5cXG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcXG5cXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xcbiAgfSBlbHNlIGlmIChpc0FycmF5KGhhbmRsZXIpKSB7XFxuICAgIHZhciBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XFxuXFxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcblxcbiAgcmV0dXJuIHRydWU7XFxufTtcXG5cXG59LHt9XSw0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vKipcXG4gKiBFeHBvc2UgYFByb2dyZXNzYC5cXG4gKi9cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IFByb2dyZXNzO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYFByb2dyZXNzYCBpbmRpY2F0b3IuXFxuICovXFxuZnVuY3Rpb24gUHJvZ3Jlc3MoKSB7XFxuICB0aGlzLnBlcmNlbnQgPSAwO1xcbiAgdGhpcy5zaXplKDApO1xcbiAgdGhpcy5mb250U2l6ZSgxMSk7XFxuICB0aGlzLmZvbnQoJ2hlbHZldGljYSwgYXJpYWwsIHNhbnMtc2VyaWYnKTtcXG59XFxuXFxuLyoqXFxuICogU2V0IHByb2dyZXNzIHNpemUgdG8gYHNpemVgLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZVxcbiAqIEByZXR1cm4ge1Byb2dyZXNzfSBQcm9ncmVzcyBpbnN0YW5jZS5cXG4gKi9cXG5Qcm9ncmVzcy5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKHNpemUpIHtcXG4gIHRoaXMuX3NpemUgPSBzaXplO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgdGV4dCB0byBgdGV4dGAuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XFxuICogQHJldHVybiB7UHJvZ3Jlc3N9IFByb2dyZXNzIGluc3RhbmNlLlxcbiAqL1xcblByb2dyZXNzLnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24odGV4dCkge1xcbiAgdGhpcy5fdGV4dCA9IHRleHQ7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCBmb250IHNpemUgdG8gYHNpemVgLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZVxcbiAqIEByZXR1cm4ge1Byb2dyZXNzfSBQcm9ncmVzcyBpbnN0YW5jZS5cXG4gKi9cXG5Qcm9ncmVzcy5wcm90b3R5cGUuZm9udFNpemUgPSBmdW5jdGlvbihzaXplKSB7XFxuICB0aGlzLl9mb250U2l6ZSA9IHNpemU7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCBmb250IHRvIGBmYW1pbHlgLlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IGZhbWlseVxcbiAqIEByZXR1cm4ge1Byb2dyZXNzfSBQcm9ncmVzcyBpbnN0YW5jZS5cXG4gKi9cXG5Qcm9ncmVzcy5wcm90b3R5cGUuZm9udCA9IGZ1bmN0aW9uKGZhbWlseSkge1xcbiAgdGhpcy5fZm9udCA9IGZhbWlseTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogVXBkYXRlIHBlcmNlbnRhZ2UgdG8gYG5gLlxcbiAqXFxuICogQHBhcmFtIHtudW1iZXJ9IG5cXG4gKiBAcmV0dXJuIHtQcm9ncmVzc30gUHJvZ3Jlc3MgaW5zdGFuY2UuXFxuICovXFxuUHJvZ3Jlc3MucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKG4pIHtcXG4gIHRoaXMucGVyY2VudCA9IG47XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIERyYXcgb24gYGN0eGAuXFxuICpcXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyZH0gY3R4XFxuICogQHJldHVybiB7UHJvZ3Jlc3N9IFByb2dyZXNzIGluc3RhbmNlLlxcbiAqL1xcblByb2dyZXNzLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oY3R4KSB7XFxuICB0cnkge1xcbiAgICB2YXIgcGVyY2VudCA9IE1hdGgubWluKHRoaXMucGVyY2VudCwgMTAwKTtcXG4gICAgdmFyIHNpemUgPSB0aGlzLl9zaXplO1xcbiAgICB2YXIgaGFsZiA9IHNpemUgLyAyO1xcbiAgICB2YXIgeCA9IGhhbGY7XFxuICAgIHZhciB5ID0gaGFsZjtcXG4gICAgdmFyIHJhZCA9IGhhbGYgLSAxO1xcbiAgICB2YXIgZm9udFNpemUgPSB0aGlzLl9mb250U2l6ZTtcXG5cXG4gICAgY3R4LmZvbnQgPSBmb250U2l6ZSArICdweCAnICsgdGhpcy5fZm9udDtcXG5cXG4gICAgdmFyIGFuZ2xlID0gTWF0aC5QSSAqIDIgKiAocGVyY2VudCAvIDEwMCk7XFxuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgc2l6ZSwgc2l6ZSk7XFxuXFxuICAgIC8vIG91dGVyIGNpcmNsZVxcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAnIzlmOWY5Zic7XFxuICAgIGN0eC5iZWdpblBhdGgoKTtcXG4gICAgY3R4LmFyYyh4LCB5LCByYWQsIDAsIGFuZ2xlLCBmYWxzZSk7XFxuICAgIGN0eC5zdHJva2UoKTtcXG5cXG4gICAgLy8gaW5uZXIgY2lyY2xlXFxuICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjZWVlJztcXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xcbiAgICBjdHguYXJjKHgsIHksIHJhZCAtIDEsIDAsIGFuZ2xlLCB0cnVlKTtcXG4gICAgY3R4LnN0cm9rZSgpO1xcblxcbiAgICAvLyB0ZXh0XFxuICAgIHZhciB0ZXh0ID0gdGhpcy5fdGV4dCB8fCAocGVyY2VudCB8IDApICsgJyUnO1xcbiAgICB2YXIgdyA9IGN0eC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aDtcXG5cXG4gICAgY3R4LmZpbGxUZXh0KHRleHQsIHggLSB3IC8gMiArIDEsIHkgKyBmb250U2l6ZSAvIDIgLSAxKTtcXG4gIH0gY2F0Y2ggKGVycikge1xcbiAgICAvLyBkb24ndCBmYWlsIGlmIHdlIGNhbid0IHJlbmRlciBwcm9ncmVzc1xcbiAgfVxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG59LHt9XSw1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKGdsb2JhbCl7XFxuZXhwb3J0cy5pc2F0dHkgPSBmdW5jdGlvbiBpc2F0dHkoKSB7XFxuICByZXR1cm4gdHJ1ZTtcXG59O1xcblxcbmV4cG9ydHMuZ2V0V2luZG93U2l6ZSA9IGZ1bmN0aW9uIGdldFdpbmRvd1NpemUoKSB7XFxuICBpZiAoJ2lubmVySGVpZ2h0JyBpbiBnbG9iYWwpIHtcXG4gICAgcmV0dXJuIFtnbG9iYWwuaW5uZXJIZWlnaHQsIGdsb2JhbC5pbm5lcldpZHRoXTtcXG4gIH1cXG4gIC8vIEluIGEgV2ViIFdvcmtlciwgdGhlIERPTSBXaW5kb3cgaXMgbm90IGF2YWlsYWJsZS5cXG4gIHJldHVybiBbNjQwLCA0ODBdO1xcbn07XFxuXFxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7fV0sNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyoqXFxuICogRXhwb3NlIGBDb250ZXh0YC5cXG4gKi9cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRleHQ7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgQ29udGV4dGAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5mdW5jdGlvbiBDb250ZXh0KCkge31cXG5cXG4vKipcXG4gKiBTZXQgb3IgZ2V0IHRoZSBjb250ZXh0IGBSdW5uYWJsZWAgdG8gYHJ1bm5hYmxlYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7UnVubmFibGV9IHJ1bm5hYmxlXFxuICogQHJldHVybiB7Q29udGV4dH1cXG4gKi9cXG5Db250ZXh0LnByb3RvdHlwZS5ydW5uYWJsZSA9IGZ1bmN0aW9uKHJ1bm5hYmxlKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX3J1bm5hYmxlO1xcbiAgfVxcbiAgdGhpcy50ZXN0ID0gdGhpcy5fcnVubmFibGUgPSBydW5uYWJsZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IHRlc3QgdGltZW91dCBgbXNgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IG1zXFxuICogQHJldHVybiB7Q29udGV4dH0gc2VsZlxcbiAqL1xcbkNvbnRleHQucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbihtcykge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLnJ1bm5hYmxlKCkudGltZW91dCgpO1xcbiAgfVxcbiAgdGhpcy5ydW5uYWJsZSgpLnRpbWVvdXQobXMpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgdGVzdCB0aW1lb3V0IGBlbmFibGVkYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxcbiAqIEByZXR1cm4ge0NvbnRleHR9IHNlbGZcXG4gKi9cXG5Db250ZXh0LnByb3RvdHlwZS5lbmFibGVUaW1lb3V0cyA9IGZ1bmN0aW9uKGVuYWJsZWQpIHtcXG4gIHRoaXMucnVubmFibGUoKS5lbmFibGVUaW1lb3V0cyhlbmFibGVkKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IHRlc3Qgc2xvd25lc3MgdGhyZXNob2xkIGBtc2AuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gbXNcXG4gKiBAcmV0dXJuIHtDb250ZXh0fSBzZWxmXFxuICovXFxuQ29udGV4dC5wcm90b3R5cGUuc2xvdyA9IGZ1bmN0aW9uKG1zKSB7XFxuICB0aGlzLnJ1bm5hYmxlKCkuc2xvdyhtcyk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIE1hcmsgYSB0ZXN0IGFzIHNraXBwZWQuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcmV0dXJuIHtDb250ZXh0fSBzZWxmXFxuICovXFxuQ29udGV4dC5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uKCkge1xcbiAgdGhpcy5ydW5uYWJsZSgpLnNraXAoKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogQWxsb3cgYSBudW1iZXIgb2YgcmV0cmllcyBvbiBmYWlsZWQgdGVzdHNcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXFxuICogQHJldHVybiB7Q29udGV4dH0gc2VsZlxcbiAqL1xcbkNvbnRleHQucHJvdG90eXBlLnJldHJpZXMgPSBmdW5jdGlvbihuKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMucnVubmFibGUoKS5yZXRyaWVzKCk7XFxuICB9XFxuICB0aGlzLnJ1bm5hYmxlKCkucmV0cmllcyhuKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogSW5zcGVjdCB0aGUgY29udGV4dCB2b2lkIG9mIGAuX3J1bm5hYmxlYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5Db250ZXh0LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XFxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcywgZnVuY3Rpb24oa2V5LCB2YWwpIHtcXG4gICAgcmV0dXJuIGtleSA9PT0gJ3J1bm5hYmxlJyB8fCBrZXkgPT09ICd0ZXN0JyA/IHVuZGVmaW5lZCA6IHZhbDtcXG4gIH0sIDIpO1xcbn07XFxuXFxufSx7fV0sNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgUnVubmFibGUgPSByZXF1aXJlKCcuL3J1bm5hYmxlJyk7XFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi91dGlscycpLmluaGVyaXRzO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgSG9va2AuXFxuICovXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBIb29rO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYEhvb2tgIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAgYW5kIGNhbGxiYWNrIGBmbmAuXFxuICpcXG4gKiBAcGFyYW0ge1N0cmluZ30gdGl0bGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcbmZ1bmN0aW9uIEhvb2sodGl0bGUsIGZuKSB7XFxuICBSdW5uYWJsZS5jYWxsKHRoaXMsIHRpdGxlLCBmbik7XFxuICB0aGlzLnR5cGUgPSAnaG9vayc7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgUnVubmFibGUucHJvdG90eXBlYC5cXG4gKi9cXG5pbmhlcml0cyhIb29rLCBSdW5uYWJsZSk7XFxuXFxuLyoqXFxuICogR2V0IG9yIHNldCB0aGUgdGVzdCBgZXJyYC5cXG4gKlxcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxcbiAqIEByZXR1cm4ge0Vycm9yfVxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuSG9vay5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICBlcnIgPSB0aGlzLl9lcnJvcjtcXG4gICAgdGhpcy5fZXJyb3IgPSBudWxsO1xcbiAgICByZXR1cm4gZXJyO1xcbiAgfVxcblxcbiAgdGhpcy5fZXJyb3IgPSBlcnI7XFxufTtcXG5cXG59LHtcXFwiLi9ydW5uYWJsZVxcXCI6MzUsXFxcIi4vdXRpbHNcXFwiOjM5fV0sODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgU3VpdGUgPSByZXF1aXJlKCcuLi9zdWl0ZScpO1xcbnZhciBUZXN0ID0gcmVxdWlyZSgnLi4vdGVzdCcpO1xcbnZhciBlc2NhcGVSZSA9IHJlcXVpcmUoJ2VzY2FwZS1zdHJpbmctcmVnZXhwJyk7XFxuXFxuLyoqXFxuICogQkRELXN0eWxlIGludGVyZmFjZTpcXG4gKlxcbiAqICAgICAgZGVzY3JpYmUoJ0FycmF5JywgZnVuY3Rpb24oKSB7XFxuICogICAgICAgIGRlc2NyaWJlKCcjaW5kZXhPZigpJywgZnVuY3Rpb24oKSB7XFxuICogICAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gLTEgd2hlbiBub3QgcHJlc2VudCcsIGZ1bmN0aW9uKCkge1xcbiAqICAgICAgICAgICAgLy8gLi4uXFxuICogICAgICAgICAgfSk7XFxuICpcXG4gKiAgICAgICAgICBpdCgnc2hvdWxkIHJldHVybiB0aGUgaW5kZXggd2hlbiBwcmVzZW50JywgZnVuY3Rpb24oKSB7XFxuICogICAgICAgICAgICAvLyAuLi5cXG4gKiAgICAgICAgICB9KTtcXG4gKiAgICAgICAgfSk7XFxuICogICAgICB9KTtcXG4gKlxcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlIFJvb3Qgc3VpdGUuXFxuICovXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzdWl0ZSkge1xcbiAgdmFyIHN1aXRlcyA9IFtzdWl0ZV07XFxuXFxuICBzdWl0ZS5vbigncHJlLXJlcXVpcmUnLCBmdW5jdGlvbihjb250ZXh0LCBmaWxlLCBtb2NoYSkge1xcbiAgICB2YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKShzdWl0ZXMsIGNvbnRleHQpO1xcblxcbiAgICBjb250ZXh0LmJlZm9yZSA9IGNvbW1vbi5iZWZvcmU7XFxuICAgIGNvbnRleHQuYWZ0ZXIgPSBjb21tb24uYWZ0ZXI7XFxuICAgIGNvbnRleHQuYmVmb3JlRWFjaCA9IGNvbW1vbi5iZWZvcmVFYWNoO1xcbiAgICBjb250ZXh0LmFmdGVyRWFjaCA9IGNvbW1vbi5hZnRlckVhY2g7XFxuICAgIGNvbnRleHQucnVuID0gbW9jaGEub3B0aW9ucy5kZWxheSAmJiBjb21tb24ucnVuV2l0aFN1aXRlKHN1aXRlKTtcXG4gICAgLyoqXFxuICAgICAqIERlc2NyaWJlIGEgXFxcInN1aXRlXFxcIiB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgXFxuICAgICAqIGFuZCBjYWxsYmFjayBgZm5gIGNvbnRhaW5pbmcgbmVzdGVkIHN1aXRlc1xcbiAgICAgKiBhbmQvb3IgdGVzdHMuXFxuICAgICAqL1xcblxcbiAgICBjb250ZXh0LmRlc2NyaWJlID0gY29udGV4dC5jb250ZXh0ID0gZnVuY3Rpb24odGl0bGUsIGZuKSB7XFxuICAgICAgdmFyIHN1aXRlID0gU3VpdGUuY3JlYXRlKHN1aXRlc1swXSwgdGl0bGUpO1xcbiAgICAgIHN1aXRlLmZpbGUgPSBmaWxlO1xcbiAgICAgIHN1aXRlcy51bnNoaWZ0KHN1aXRlKTtcXG4gICAgICBmbi5jYWxsKHN1aXRlKTtcXG4gICAgICBzdWl0ZXMuc2hpZnQoKTtcXG4gICAgICByZXR1cm4gc3VpdGU7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBQZW5kaW5nIGRlc2NyaWJlLlxcbiAgICAgKi9cXG5cXG4gICAgY29udGV4dC54ZGVzY3JpYmUgPSBjb250ZXh0Lnhjb250ZXh0ID0gY29udGV4dC5kZXNjcmliZS5za2lwID0gZnVuY3Rpb24odGl0bGUsIGZuKSB7XFxuICAgICAgdmFyIHN1aXRlID0gU3VpdGUuY3JlYXRlKHN1aXRlc1swXSwgdGl0bGUpO1xcbiAgICAgIHN1aXRlLnBlbmRpbmcgPSB0cnVlO1xcbiAgICAgIHN1aXRlcy51bnNoaWZ0KHN1aXRlKTtcXG4gICAgICBmbi5jYWxsKHN1aXRlKTtcXG4gICAgICBzdWl0ZXMuc2hpZnQoKTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIEV4Y2x1c2l2ZSBzdWl0ZS5cXG4gICAgICovXFxuXFxuICAgIGNvbnRleHQuZGVzY3JpYmUub25seSA9IGZ1bmN0aW9uKHRpdGxlLCBmbikge1xcbiAgICAgIHZhciBzdWl0ZSA9IGNvbnRleHQuZGVzY3JpYmUodGl0bGUsIGZuKTtcXG4gICAgICBtb2NoYS5ncmVwKHN1aXRlLmZ1bGxUaXRsZSgpKTtcXG4gICAgICByZXR1cm4gc3VpdGU7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBEZXNjcmliZSBhIHNwZWNpZmljYXRpb24gb3IgdGVzdC1jYXNlXFxuICAgICAqIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAgYW5kIGNhbGxiYWNrIGBmbmBcXG4gICAgICogYWN0aW5nIGFzIGEgdGh1bmsuXFxuICAgICAqL1xcblxcbiAgICB2YXIgaXQgPSBjb250ZXh0Lml0ID0gY29udGV4dC5zcGVjaWZ5ID0gZnVuY3Rpb24odGl0bGUsIGZuKSB7XFxuICAgICAgdmFyIHN1aXRlID0gc3VpdGVzWzBdO1xcbiAgICAgIGlmIChzdWl0ZS5wZW5kaW5nKSB7XFxuICAgICAgICBmbiA9IG51bGw7XFxuICAgICAgfVxcbiAgICAgIHZhciB0ZXN0ID0gbmV3IFRlc3QodGl0bGUsIGZuKTtcXG4gICAgICB0ZXN0LmZpbGUgPSBmaWxlO1xcbiAgICAgIHN1aXRlLmFkZFRlc3QodGVzdCk7XFxuICAgICAgcmV0dXJuIHRlc3Q7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBFeGNsdXNpdmUgdGVzdC1jYXNlLlxcbiAgICAgKi9cXG5cXG4gICAgY29udGV4dC5pdC5vbmx5ID0gZnVuY3Rpb24odGl0bGUsIGZuKSB7XFxuICAgICAgdmFyIHRlc3QgPSBpdCh0aXRsZSwgZm4pO1xcbiAgICAgIHZhciByZVN0cmluZyA9ICdeJyArIGVzY2FwZVJlKHRlc3QuZnVsbFRpdGxlKCkpICsgJyQnO1xcbiAgICAgIG1vY2hhLmdyZXAobmV3IFJlZ0V4cChyZVN0cmluZykpO1xcbiAgICAgIHJldHVybiB0ZXN0O1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogUGVuZGluZyB0ZXN0IGNhc2UuXFxuICAgICAqL1xcblxcbiAgICBjb250ZXh0LnhpdCA9IGNvbnRleHQueHNwZWNpZnkgPSBjb250ZXh0Lml0LnNraXAgPSBmdW5jdGlvbih0aXRsZSkge1xcbiAgICAgIGNvbnRleHQuaXQodGl0bGUpO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogTnVtYmVyIG9mIGF0dGVtcHRzIHRvIHJldHJ5LlxcbiAgICAgKi9cXG4gICAgY29udGV4dC5pdC5yZXRyaWVzID0gZnVuY3Rpb24obikge1xcbiAgICAgIGNvbnRleHQucmV0cmllcyhuKTtcXG4gICAgfTtcXG4gIH0pO1xcbn07XFxuXFxufSx7XFxcIi4uL3N1aXRlXFxcIjozNyxcXFwiLi4vdGVzdFxcXCI6MzgsXFxcIi4vY29tbW9uXFxcIjo5LFxcXCJlc2NhcGUtc3RyaW5nLXJlZ2V4cFxcXCI6Njh9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyoqXFxuICogRnVuY3Rpb25zIGNvbW1vbiB0byBtb3JlIHRoYW4gb25lIGludGVyZmFjZS5cXG4gKlxcbiAqIEBwYXJhbSB7U3VpdGVbXX0gc3VpdGVzXFxuICogQHBhcmFtIHtDb250ZXh0fSBjb250ZXh0XFxuICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyBjb21tb24gZnVuY3Rpb25zLlxcbiAqL1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3VpdGVzLCBjb250ZXh0KSB7XFxuICByZXR1cm4ge1xcbiAgICAvKipcXG4gICAgICogVGhpcyBpcyBvbmx5IHByZXNlbnQgaWYgZmxhZyAtLWRlbGF5IGlzIHBhc3NlZCBpbnRvIE1vY2hhLiBJdCB0cmlnZ2Vyc1xcbiAgICAgKiByb290IHN1aXRlIGV4ZWN1dGlvbi5cXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtTdWl0ZX0gc3VpdGUgVGhlIHJvb3Qgd3VpdGUuXFxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHdoaWNoIHJ1bnMgdGhlIHJvb3Qgc3VpdGVcXG4gICAgICovXFxuICAgIHJ1bldpdGhTdWl0ZTogZnVuY3Rpb24gcnVuV2l0aFN1aXRlKHN1aXRlKSB7XFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJ1bigpIHtcXG4gICAgICAgIHN1aXRlLnJ1bigpO1xcbiAgICAgIH07XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBFeGVjdXRlIGJlZm9yZSBydW5uaW5nIHRlc3RzLlxcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAgICAgKi9cXG4gICAgYmVmb3JlOiBmdW5jdGlvbihuYW1lLCBmbikge1xcbiAgICAgIHN1aXRlc1swXS5iZWZvcmVBbGwobmFtZSwgZm4pO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogRXhlY3V0ZSBhZnRlciBydW5uaW5nIHRlc3RzLlxcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAgICAgKi9cXG4gICAgYWZ0ZXI6IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XFxuICAgICAgc3VpdGVzWzBdLmFmdGVyQWxsKG5hbWUsIGZuKTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIEV4ZWN1dGUgYmVmb3JlIGVhY2ggdGVzdCBjYXNlLlxcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAgICAgKi9cXG4gICAgYmVmb3JlRWFjaDogZnVuY3Rpb24obmFtZSwgZm4pIHtcXG4gICAgICBzdWl0ZXNbMF0uYmVmb3JlRWFjaChuYW1lLCBmbik7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBFeGVjdXRlIGFmdGVyIGVhY2ggdGVzdCBjYXNlLlxcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAgICAgKi9cXG4gICAgYWZ0ZXJFYWNoOiBmdW5jdGlvbihuYW1lLCBmbikge1xcbiAgICAgIHN1aXRlc1swXS5hZnRlckVhY2gobmFtZSwgZm4pO1xcbiAgICB9LFxcblxcbiAgICB0ZXN0OiB7XFxuICAgICAgLyoqXFxuICAgICAgICogUGVuZGluZyB0ZXN0IGNhc2UuXFxuICAgICAgICpcXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcXG4gICAgICAgKi9cXG4gICAgICBza2lwOiBmdW5jdGlvbih0aXRsZSkge1xcbiAgICAgICAgY29udGV4dC50ZXN0KHRpdGxlKTtcXG4gICAgICB9LFxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIE51bWJlciBvZiByZXRyeSBhdHRlbXB0c1xcbiAgICAgICAqXFxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5cXG4gICAgICAgKi9cXG4gICAgICByZXRyaWVzOiBmdW5jdGlvbihuKSB7XFxuICAgICAgICBjb250ZXh0LnJldHJpZXMobik7XFxuICAgICAgfVxcbiAgICB9XFxuICB9O1xcbn07XFxuXFxufSx7fV0sMTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIFN1aXRlID0gcmVxdWlyZSgnLi4vc3VpdGUnKTtcXG52YXIgVGVzdCA9IHJlcXVpcmUoJy4uL3Rlc3QnKTtcXG5cXG4vKipcXG4gKiBUREQtc3R5bGUgaW50ZXJmYWNlOlxcbiAqXFxuICogICAgIGV4cG9ydHMuQXJyYXkgPSB7XFxuICogICAgICAgJyNpbmRleE9mKCknOiB7XFxuICogICAgICAgICAnc2hvdWxkIHJldHVybiAtMSB3aGVuIHRoZSB2YWx1ZSBpcyBub3QgcHJlc2VudCc6IGZ1bmN0aW9uKCkge1xcbiAqXFxuICogICAgICAgICB9LFxcbiAqXFxuICogICAgICAgICAnc2hvdWxkIHJldHVybiB0aGUgY29ycmVjdCBpbmRleCB3aGVuIHRoZSB2YWx1ZSBpcyBwcmVzZW50JzogZnVuY3Rpb24oKSB7XFxuICpcXG4gKiAgICAgICAgIH1cXG4gKiAgICAgICB9XFxuICogICAgIH07XFxuICpcXG4gKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZSBSb290IHN1aXRlLlxcbiAqL1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3VpdGUpIHtcXG4gIHZhciBzdWl0ZXMgPSBbc3VpdGVdO1xcblxcbiAgc3VpdGUub24oJ3JlcXVpcmUnLCB2aXNpdCk7XFxuXFxuICBmdW5jdGlvbiB2aXNpdChvYmosIGZpbGUpIHtcXG4gICAgdmFyIHN1aXRlO1xcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XFxuICAgICAgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgdmFyIGZuID0gb2JqW2tleV07XFxuICAgICAgICBzd2l0Y2ggKGtleSkge1xcbiAgICAgICAgICBjYXNlICdiZWZvcmUnOlxcbiAgICAgICAgICAgIHN1aXRlc1swXS5iZWZvcmVBbGwoZm4pO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICBjYXNlICdhZnRlcic6XFxuICAgICAgICAgICAgc3VpdGVzWzBdLmFmdGVyQWxsKGZuKTtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgY2FzZSAnYmVmb3JlRWFjaCc6XFxuICAgICAgICAgICAgc3VpdGVzWzBdLmJlZm9yZUVhY2goZm4pO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICBjYXNlICdhZnRlckVhY2gnOlxcbiAgICAgICAgICAgIHN1aXRlc1swXS5hZnRlckVhY2goZm4pO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICAgIHZhciB0ZXN0ID0gbmV3IFRlc3Qoa2V5LCBmbik7XFxuICAgICAgICAgICAgdGVzdC5maWxlID0gZmlsZTtcXG4gICAgICAgICAgICBzdWl0ZXNbMF0uYWRkVGVzdCh0ZXN0KTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc3VpdGUgPSBTdWl0ZS5jcmVhdGUoc3VpdGVzWzBdLCBrZXkpO1xcbiAgICAgICAgc3VpdGVzLnVuc2hpZnQoc3VpdGUpO1xcbiAgICAgICAgdmlzaXQob2JqW2tleV0sIGZpbGUpO1xcbiAgICAgICAgc3VpdGVzLnNoaWZ0KCk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxufTtcXG5cXG59LHtcXFwiLi4vc3VpdGVcXFwiOjM3LFxcXCIuLi90ZXN0XFxcIjozOH1dLDExOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5leHBvcnRzLmJkZCA9IHJlcXVpcmUoJy4vYmRkJyk7XFxuZXhwb3J0cy50ZGQgPSByZXF1aXJlKCcuL3RkZCcpO1xcbmV4cG9ydHMucXVuaXQgPSByZXF1aXJlKCcuL3F1bml0Jyk7XFxuZXhwb3J0cy5leHBvcnRzID0gcmVxdWlyZSgnLi9leHBvcnRzJyk7XFxuXFxufSx7XFxcIi4vYmRkXFxcIjo4LFxcXCIuL2V4cG9ydHNcXFwiOjEwLFxcXCIuL3F1bml0XFxcIjoxMixcXFwiLi90ZGRcXFwiOjEzfV0sMTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIFN1aXRlID0gcmVxdWlyZSgnLi4vc3VpdGUnKTtcXG52YXIgVGVzdCA9IHJlcXVpcmUoJy4uL3Rlc3QnKTtcXG52YXIgZXNjYXBlUmUgPSByZXF1aXJlKCdlc2NhcGUtc3RyaW5nLXJlZ2V4cCcpO1xcblxcbi8qKlxcbiAqIFFVbml0LXN0eWxlIGludGVyZmFjZTpcXG4gKlxcbiAqICAgICBzdWl0ZSgnQXJyYXknKTtcXG4gKlxcbiAqICAgICB0ZXN0KCcjbGVuZ3RoJywgZnVuY3Rpb24oKSB7XFxuICogICAgICAgdmFyIGFyciA9IFsxLDIsM107XFxuICogICAgICAgb2soYXJyLmxlbmd0aCA9PSAzKTtcXG4gKiAgICAgfSk7XFxuICpcXG4gKiAgICAgdGVzdCgnI2luZGV4T2YoKScsIGZ1bmN0aW9uKCkge1xcbiAqICAgICAgIHZhciBhcnIgPSBbMSwyLDNdO1xcbiAqICAgICAgIG9rKGFyci5pbmRleE9mKDEpID09IDApO1xcbiAqICAgICAgIG9rKGFyci5pbmRleE9mKDIpID09IDEpO1xcbiAqICAgICAgIG9rKGFyci5pbmRleE9mKDMpID09IDIpO1xcbiAqICAgICB9KTtcXG4gKlxcbiAqICAgICBzdWl0ZSgnU3RyaW5nJyk7XFxuICpcXG4gKiAgICAgdGVzdCgnI2xlbmd0aCcsIGZ1bmN0aW9uKCkge1xcbiAqICAgICAgIG9rKCdmb28nLmxlbmd0aCA9PSAzKTtcXG4gKiAgICAgfSk7XFxuICpcXG4gKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZSBSb290IHN1aXRlLlxcbiAqL1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3VpdGUpIHtcXG4gIHZhciBzdWl0ZXMgPSBbc3VpdGVdO1xcblxcbiAgc3VpdGUub24oJ3ByZS1yZXF1aXJlJywgZnVuY3Rpb24oY29udGV4dCwgZmlsZSwgbW9jaGEpIHtcXG4gICAgdmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJykoc3VpdGVzLCBjb250ZXh0KTtcXG5cXG4gICAgY29udGV4dC5iZWZvcmUgPSBjb21tb24uYmVmb3JlO1xcbiAgICBjb250ZXh0LmFmdGVyID0gY29tbW9uLmFmdGVyO1xcbiAgICBjb250ZXh0LmJlZm9yZUVhY2ggPSBjb21tb24uYmVmb3JlRWFjaDtcXG4gICAgY29udGV4dC5hZnRlckVhY2ggPSBjb21tb24uYWZ0ZXJFYWNoO1xcbiAgICBjb250ZXh0LnJ1biA9IG1vY2hhLm9wdGlvbnMuZGVsYXkgJiYgY29tbW9uLnJ1bldpdGhTdWl0ZShzdWl0ZSk7XFxuICAgIC8qKlxcbiAgICAgKiBEZXNjcmliZSBhIFxcXCJzdWl0ZVxcXCIgd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYC5cXG4gICAgICovXFxuXFxuICAgIGNvbnRleHQuc3VpdGUgPSBmdW5jdGlvbih0aXRsZSkge1xcbiAgICAgIGlmIChzdWl0ZXMubGVuZ3RoID4gMSkge1xcbiAgICAgICAgc3VpdGVzLnNoaWZ0KCk7XFxuICAgICAgfVxcbiAgICAgIHZhciBzdWl0ZSA9IFN1aXRlLmNyZWF0ZShzdWl0ZXNbMF0sIHRpdGxlKTtcXG4gICAgICBzdWl0ZS5maWxlID0gZmlsZTtcXG4gICAgICBzdWl0ZXMudW5zaGlmdChzdWl0ZSk7XFxuICAgICAgcmV0dXJuIHN1aXRlO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogRXhjbHVzaXZlIHRlc3QtY2FzZS5cXG4gICAgICovXFxuXFxuICAgIGNvbnRleHQuc3VpdGUub25seSA9IGZ1bmN0aW9uKHRpdGxlLCBmbikge1xcbiAgICAgIHZhciBzdWl0ZSA9IGNvbnRleHQuc3VpdGUodGl0bGUsIGZuKTtcXG4gICAgICBtb2NoYS5ncmVwKHN1aXRlLmZ1bGxUaXRsZSgpKTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIERlc2NyaWJlIGEgc3BlY2lmaWNhdGlvbiBvciB0ZXN0LWNhc2VcXG4gICAgICogd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYCBhbmQgY2FsbGJhY2sgYGZuYFxcbiAgICAgKiBhY3RpbmcgYXMgYSB0aHVuay5cXG4gICAgICovXFxuXFxuICAgIGNvbnRleHQudGVzdCA9IGZ1bmN0aW9uKHRpdGxlLCBmbikge1xcbiAgICAgIHZhciB0ZXN0ID0gbmV3IFRlc3QodGl0bGUsIGZuKTtcXG4gICAgICB0ZXN0LmZpbGUgPSBmaWxlO1xcbiAgICAgIHN1aXRlc1swXS5hZGRUZXN0KHRlc3QpO1xcbiAgICAgIHJldHVybiB0ZXN0O1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogRXhjbHVzaXZlIHRlc3QtY2FzZS5cXG4gICAgICovXFxuXFxuICAgIGNvbnRleHQudGVzdC5vbmx5ID0gZnVuY3Rpb24odGl0bGUsIGZuKSB7XFxuICAgICAgdmFyIHRlc3QgPSBjb250ZXh0LnRlc3QodGl0bGUsIGZuKTtcXG4gICAgICB2YXIgcmVTdHJpbmcgPSAnXicgKyBlc2NhcGVSZSh0ZXN0LmZ1bGxUaXRsZSgpKSArICckJztcXG4gICAgICBtb2NoYS5ncmVwKG5ldyBSZWdFeHAocmVTdHJpbmcpKTtcXG4gICAgfTtcXG5cXG4gICAgY29udGV4dC50ZXN0LnNraXAgPSBjb21tb24udGVzdC5za2lwO1xcbiAgICBjb250ZXh0LnRlc3QucmV0cmllcyA9IGNvbW1vbi50ZXN0LnJldHJpZXM7XFxuICB9KTtcXG59O1xcblxcbn0se1xcXCIuLi9zdWl0ZVxcXCI6MzcsXFxcIi4uL3Rlc3RcXFwiOjM4LFxcXCIuL2NvbW1vblxcXCI6OSxcXFwiZXNjYXBlLXN0cmluZy1yZWdleHBcXFwiOjY4fV0sMTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIFN1aXRlID0gcmVxdWlyZSgnLi4vc3VpdGUnKTtcXG52YXIgVGVzdCA9IHJlcXVpcmUoJy4uL3Rlc3QnKTtcXG52YXIgZXNjYXBlUmUgPSByZXF1aXJlKCdlc2NhcGUtc3RyaW5nLXJlZ2V4cCcpO1xcblxcbi8qKlxcbiAqIFRERC1zdHlsZSBpbnRlcmZhY2U6XFxuICpcXG4gKiAgICAgIHN1aXRlKCdBcnJheScsIGZ1bmN0aW9uKCkge1xcbiAqICAgICAgICBzdWl0ZSgnI2luZGV4T2YoKScsIGZ1bmN0aW9uKCkge1xcbiAqICAgICAgICAgIHN1aXRlU2V0dXAoZnVuY3Rpb24oKSB7XFxuICpcXG4gKiAgICAgICAgICB9KTtcXG4gKlxcbiAqICAgICAgICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gLTEgd2hlbiBub3QgcHJlc2VudCcsIGZ1bmN0aW9uKCkge1xcbiAqXFxuICogICAgICAgICAgfSk7XFxuICpcXG4gKiAgICAgICAgICB0ZXN0KCdzaG91bGQgcmV0dXJuIHRoZSBpbmRleCB3aGVuIHByZXNlbnQnLCBmdW5jdGlvbigpIHtcXG4gKlxcbiAqICAgICAgICAgIH0pO1xcbiAqXFxuICogICAgICAgICAgc3VpdGVUZWFyZG93bihmdW5jdGlvbigpIHtcXG4gKlxcbiAqICAgICAgICAgIH0pO1xcbiAqICAgICAgICB9KTtcXG4gKiAgICAgIH0pO1xcbiAqXFxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGUgUm9vdCBzdWl0ZS5cXG4gKi9cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHN1aXRlKSB7XFxuICB2YXIgc3VpdGVzID0gW3N1aXRlXTtcXG5cXG4gIHN1aXRlLm9uKCdwcmUtcmVxdWlyZScsIGZ1bmN0aW9uKGNvbnRleHQsIGZpbGUsIG1vY2hhKSB7XFxuICAgIHZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpKHN1aXRlcywgY29udGV4dCk7XFxuXFxuICAgIGNvbnRleHQuc2V0dXAgPSBjb21tb24uYmVmb3JlRWFjaDtcXG4gICAgY29udGV4dC50ZWFyZG93biA9IGNvbW1vbi5hZnRlckVhY2g7XFxuICAgIGNvbnRleHQuc3VpdGVTZXR1cCA9IGNvbW1vbi5iZWZvcmU7XFxuICAgIGNvbnRleHQuc3VpdGVUZWFyZG93biA9IGNvbW1vbi5hZnRlcjtcXG4gICAgY29udGV4dC5ydW4gPSBtb2NoYS5vcHRpb25zLmRlbGF5ICYmIGNvbW1vbi5ydW5XaXRoU3VpdGUoc3VpdGUpO1xcblxcbiAgICAvKipcXG4gICAgICogRGVzY3JpYmUgYSBcXFwic3VpdGVcXFwiIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAgYW5kIGNhbGxiYWNrIGBmbmAgY29udGFpbmluZ1xcbiAgICAgKiBuZXN0ZWQgc3VpdGVzIGFuZC9vciB0ZXN0cy5cXG4gICAgICovXFxuICAgIGNvbnRleHQuc3VpdGUgPSBmdW5jdGlvbih0aXRsZSwgZm4pIHtcXG4gICAgICB2YXIgc3VpdGUgPSBTdWl0ZS5jcmVhdGUoc3VpdGVzWzBdLCB0aXRsZSk7XFxuICAgICAgc3VpdGUuZmlsZSA9IGZpbGU7XFxuICAgICAgc3VpdGVzLnVuc2hpZnQoc3VpdGUpO1xcbiAgICAgIGZuLmNhbGwoc3VpdGUpO1xcbiAgICAgIHN1aXRlcy5zaGlmdCgpO1xcbiAgICAgIHJldHVybiBzdWl0ZTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIFBlbmRpbmcgc3VpdGUuXFxuICAgICAqL1xcbiAgICBjb250ZXh0LnN1aXRlLnNraXAgPSBmdW5jdGlvbih0aXRsZSwgZm4pIHtcXG4gICAgICB2YXIgc3VpdGUgPSBTdWl0ZS5jcmVhdGUoc3VpdGVzWzBdLCB0aXRsZSk7XFxuICAgICAgc3VpdGUucGVuZGluZyA9IHRydWU7XFxuICAgICAgc3VpdGVzLnVuc2hpZnQoc3VpdGUpO1xcbiAgICAgIGZuLmNhbGwoc3VpdGUpO1xcbiAgICAgIHN1aXRlcy5zaGlmdCgpO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogRXhjbHVzaXZlIHRlc3QtY2FzZS5cXG4gICAgICovXFxuICAgIGNvbnRleHQuc3VpdGUub25seSA9IGZ1bmN0aW9uKHRpdGxlLCBmbikge1xcbiAgICAgIHZhciBzdWl0ZSA9IGNvbnRleHQuc3VpdGUodGl0bGUsIGZuKTtcXG4gICAgICBtb2NoYS5ncmVwKHN1aXRlLmZ1bGxUaXRsZSgpKTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIERlc2NyaWJlIGEgc3BlY2lmaWNhdGlvbiBvciB0ZXN0LWNhc2Ugd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYCBhbmRcXG4gICAgICogY2FsbGJhY2sgYGZuYCBhY3RpbmcgYXMgYSB0aHVuay5cXG4gICAgICovXFxuICAgIGNvbnRleHQudGVzdCA9IGZ1bmN0aW9uKHRpdGxlLCBmbikge1xcbiAgICAgIHZhciBzdWl0ZSA9IHN1aXRlc1swXTtcXG4gICAgICBpZiAoc3VpdGUucGVuZGluZykge1xcbiAgICAgICAgZm4gPSBudWxsO1xcbiAgICAgIH1cXG4gICAgICB2YXIgdGVzdCA9IG5ldyBUZXN0KHRpdGxlLCBmbik7XFxuICAgICAgdGVzdC5maWxlID0gZmlsZTtcXG4gICAgICBzdWl0ZS5hZGRUZXN0KHRlc3QpO1xcbiAgICAgIHJldHVybiB0ZXN0O1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogRXhjbHVzaXZlIHRlc3QtY2FzZS5cXG4gICAgICovXFxuXFxuICAgIGNvbnRleHQudGVzdC5vbmx5ID0gZnVuY3Rpb24odGl0bGUsIGZuKSB7XFxuICAgICAgdmFyIHRlc3QgPSBjb250ZXh0LnRlc3QodGl0bGUsIGZuKTtcXG4gICAgICB2YXIgcmVTdHJpbmcgPSAnXicgKyBlc2NhcGVSZSh0ZXN0LmZ1bGxUaXRsZSgpKSArICckJztcXG4gICAgICBtb2NoYS5ncmVwKG5ldyBSZWdFeHAocmVTdHJpbmcpKTtcXG4gICAgfTtcXG5cXG4gICAgY29udGV4dC50ZXN0LnNraXAgPSBjb21tb24udGVzdC5za2lwO1xcbiAgICBjb250ZXh0LnRlc3QucmV0cmllcyA9IGNvbW1vbi50ZXN0LnJldHJpZXM7XFxuICB9KTtcXG59O1xcblxcbn0se1xcXCIuLi9zdWl0ZVxcXCI6MzcsXFxcIi4uL3Rlc3RcXFwiOjM4LFxcXCIuL2NvbW1vblxcXCI6OSxcXFwiZXNjYXBlLXN0cmluZy1yZWdleHBcXFwiOjY4fV0sMTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsX19kaXJuYW1lKXtcXG4vKiFcXG4gKiBtb2NoYVxcbiAqIENvcHlyaWdodChjKSAyMDExIFRKIEhvbG93YXljaHVrIDx0akB2aXNpb24tbWVkaWEuY2E+XFxuICogTUlUIExpY2Vuc2VkXFxuICovXFxuXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgZXNjYXBlUmUgPSByZXF1aXJlKCdlc2NhcGUtc3RyaW5nLXJlZ2V4cCcpO1xcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xcbnZhciByZXBvcnRlcnMgPSByZXF1aXJlKCcuL3JlcG9ydGVycycpO1xcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYE1vY2hhYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBNb2NoYTtcXG5cXG4vKipcXG4gKiBUbyByZXF1aXJlIGxvY2FsIFVJcyBhbmQgcmVwb3J0ZXJzIHdoZW4gcnVubmluZyBpbiBub2RlLlxcbiAqL1xcblxcbmlmICghcHJvY2Vzcy5icm93c2VyKSB7XFxuICB2YXIgY3dkID0gcHJvY2Vzcy5jd2QoKTtcXG4gIG1vZHVsZS5wYXRocy5wdXNoKGN3ZCwgcGF0aC5qb2luKGN3ZCwgJ25vZGVfbW9kdWxlcycpKTtcXG59XFxuXFxuLyoqXFxuICogRXhwb3NlIGludGVybmFscy5cXG4gKi9cXG5cXG5leHBvcnRzLnV0aWxzID0gdXRpbHM7XFxuZXhwb3J0cy5pbnRlcmZhY2VzID0gcmVxdWlyZSgnLi9pbnRlcmZhY2VzJyk7XFxuZXhwb3J0cy5yZXBvcnRlcnMgPSByZXBvcnRlcnM7XFxuZXhwb3J0cy5SdW5uYWJsZSA9IHJlcXVpcmUoJy4vcnVubmFibGUnKTtcXG5leHBvcnRzLkNvbnRleHQgPSByZXF1aXJlKCcuL2NvbnRleHQnKTtcXG5leHBvcnRzLlJ1bm5lciA9IHJlcXVpcmUoJy4vcnVubmVyJyk7XFxuZXhwb3J0cy5TdWl0ZSA9IHJlcXVpcmUoJy4vc3VpdGUnKTtcXG5leHBvcnRzLkhvb2sgPSByZXF1aXJlKCcuL2hvb2snKTtcXG5leHBvcnRzLlRlc3QgPSByZXF1aXJlKCcuL3Rlc3QnKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gaW1hZ2UgYG5hbWVgIHBhdGguXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5mdW5jdGlvbiBpbWFnZShuYW1lKSB7XFxuICByZXR1cm4gcGF0aC5qb2luKF9fZGlybmFtZSwgJy4uL2ltYWdlcycsIG5hbWUgKyAnLnBuZycpO1xcbn1cXG5cXG4vKipcXG4gKiBTZXQgdXAgbW9jaGEgd2l0aCBgb3B0aW9uc2AuXFxuICpcXG4gKiBPcHRpb25zOlxcbiAqXFxuICogICAtIGB1aWAgbmFtZSBcXFwiYmRkXFxcIiwgXFxcInRkZFxcXCIsIFxcXCJleHBvcnRzXFxcIiBldGNcXG4gKiAgIC0gYHJlcG9ydGVyYCByZXBvcnRlciBpbnN0YW5jZSwgZGVmYXVsdHMgdG8gYG1vY2hhLnJlcG9ydGVycy5zcGVjYFxcbiAqICAgLSBgZ2xvYmFsc2AgYXJyYXkgb2YgYWNjZXB0ZWQgZ2xvYmFsc1xcbiAqICAgLSBgdGltZW91dGAgdGltZW91dCBpbiBtaWxsaXNlY29uZHNcXG4gKiAgIC0gYHJldHJpZXNgIG51bWJlciBvZiB0aW1lcyB0byByZXRyeSBmYWlsZWQgdGVzdHNcXG4gKiAgIC0gYGJhaWxgIGJhaWwgb24gdGhlIGZpcnN0IHRlc3QgZmFpbHVyZVxcbiAqICAgLSBgc2xvd2AgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIGNvbnNpZGVyaW5nIGEgdGVzdCBzbG93XFxuICogICAtIGBpZ25vcmVMZWFrc2AgaWdub3JlIGdsb2JhbCBsZWFrc1xcbiAqICAgLSBgZnVsbFRyYWNlYCBkaXNwbGF5IHRoZSBmdWxsIHN0YWNrLXRyYWNlIG9uIGZhaWxpbmdcXG4gKiAgIC0gYGdyZXBgIHN0cmluZyBvciByZWdleHAgdG8gZmlsdGVyIHRlc3RzIHdpdGhcXG4gKlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5mdW5jdGlvbiBNb2NoYShvcHRpb25zKSB7XFxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG4gIHRoaXMuZmlsZXMgPSBbXTtcXG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XFxuICBpZiAob3B0aW9ucy5ncmVwKSB7XFxuICAgIHRoaXMuZ3JlcChuZXcgUmVnRXhwKG9wdGlvbnMuZ3JlcCkpO1xcbiAgfVxcbiAgaWYgKG9wdGlvbnMuZmdyZXApIHtcXG4gICAgdGhpcy5ncmVwKG9wdGlvbnMuZmdyZXApO1xcbiAgfVxcbiAgdGhpcy5zdWl0ZSA9IG5ldyBleHBvcnRzLlN1aXRlKCcnLCBuZXcgZXhwb3J0cy5Db250ZXh0KCkpO1xcbiAgdGhpcy51aShvcHRpb25zLnVpKTtcXG4gIHRoaXMuYmFpbChvcHRpb25zLmJhaWwpO1xcbiAgdGhpcy5yZXBvcnRlcihvcHRpb25zLnJlcG9ydGVyLCBvcHRpb25zLnJlcG9ydGVyT3B0aW9ucyk7XFxuICBpZiAodHlwZW9mIG9wdGlvbnMudGltZW91dCAhPT0gJ3VuZGVmaW5lZCcgJiYgb3B0aW9ucy50aW1lb3V0ICE9PSBudWxsKSB7XFxuICAgIHRoaXMudGltZW91dChvcHRpb25zLnRpbWVvdXQpO1xcbiAgfVxcbiAgaWYgKHR5cGVvZiBvcHRpb25zLnJldHJpZXMgIT09ICd1bmRlZmluZWQnICYmIG9wdGlvbnMucmV0cmllcyAhPT0gbnVsbCkge1xcbiAgICB0aGlzLnJldHJpZXMob3B0aW9ucy5yZXRyaWVzKTtcXG4gIH1cXG4gIHRoaXMudXNlQ29sb3JzKG9wdGlvbnMudXNlQ29sb3JzKTtcXG4gIGlmIChvcHRpb25zLmVuYWJsZVRpbWVvdXRzICE9PSBudWxsKSB7XFxuICAgIHRoaXMuZW5hYmxlVGltZW91dHMob3B0aW9ucy5lbmFibGVUaW1lb3V0cyk7XFxuICB9XFxuICBpZiAob3B0aW9ucy5zbG93KSB7XFxuICAgIHRoaXMuc2xvdyhvcHRpb25zLnNsb3cpO1xcbiAgfVxcblxcbiAgdGhpcy5zdWl0ZS5vbigncHJlLXJlcXVpcmUnLCBmdW5jdGlvbihjb250ZXh0KSB7XFxuICAgIGV4cG9ydHMuYWZ0ZXJFYWNoID0gY29udGV4dC5hZnRlckVhY2ggfHwgY29udGV4dC50ZWFyZG93bjtcXG4gICAgZXhwb3J0cy5hZnRlciA9IGNvbnRleHQuYWZ0ZXIgfHwgY29udGV4dC5zdWl0ZVRlYXJkb3duO1xcbiAgICBleHBvcnRzLmJlZm9yZUVhY2ggPSBjb250ZXh0LmJlZm9yZUVhY2ggfHwgY29udGV4dC5zZXR1cDtcXG4gICAgZXhwb3J0cy5iZWZvcmUgPSBjb250ZXh0LmJlZm9yZSB8fCBjb250ZXh0LnN1aXRlU2V0dXA7XFxuICAgIGV4cG9ydHMuZGVzY3JpYmUgPSBjb250ZXh0LmRlc2NyaWJlIHx8IGNvbnRleHQuc3VpdGU7XFxuICAgIGV4cG9ydHMuaXQgPSBjb250ZXh0Lml0IHx8IGNvbnRleHQudGVzdDtcXG4gICAgZXhwb3J0cy5zZXR1cCA9IGNvbnRleHQuc2V0dXAgfHwgY29udGV4dC5iZWZvcmVFYWNoO1xcbiAgICBleHBvcnRzLnN1aXRlU2V0dXAgPSBjb250ZXh0LnN1aXRlU2V0dXAgfHwgY29udGV4dC5iZWZvcmU7XFxuICAgIGV4cG9ydHMuc3VpdGVUZWFyZG93biA9IGNvbnRleHQuc3VpdGVUZWFyZG93biB8fCBjb250ZXh0LmFmdGVyO1xcbiAgICBleHBvcnRzLnN1aXRlID0gY29udGV4dC5zdWl0ZSB8fCBjb250ZXh0LmRlc2NyaWJlO1xcbiAgICBleHBvcnRzLnRlYXJkb3duID0gY29udGV4dC50ZWFyZG93biB8fCBjb250ZXh0LmFmdGVyRWFjaDtcXG4gICAgZXhwb3J0cy50ZXN0ID0gY29udGV4dC50ZXN0IHx8IGNvbnRleHQuaXQ7XFxuICAgIGV4cG9ydHMucnVuID0gY29udGV4dC5ydW47XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogRW5hYmxlIG9yIGRpc2FibGUgYmFpbGluZyBvbiB0aGUgZmlyc3QgZmFpbHVyZS5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtib29sZWFufSBbYmFpbF1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuYmFpbCA9IGZ1bmN0aW9uKGJhaWwpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICBiYWlsID0gdHJ1ZTtcXG4gIH1cXG4gIHRoaXMuc3VpdGUuYmFpbChiYWlsKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogQWRkIHRlc3QgYGZpbGVgLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5hZGRGaWxlID0gZnVuY3Rpb24oZmlsZSkge1xcbiAgdGhpcy5maWxlcy5wdXNoKGZpbGUpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgcmVwb3J0ZXIgdG8gYHJlcG9ydGVyYCwgZGVmYXVsdHMgdG8gXFxcInNwZWNcXFwiLlxcbiAqXFxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHJlcG9ydGVyIG5hbWUgb3IgY29uc3RydWN0b3JcXG4gKiBAcGFyYW0ge09iamVjdH0gcmVwb3J0ZXJPcHRpb25zIG9wdGlvbmFsIG9wdGlvbnNcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7c3RyaW5nfEZ1bmN0aW9ufSByZXBvcnRlciBuYW1lIG9yIGNvbnN0cnVjdG9yXFxuICogQHBhcmFtIHtPYmplY3R9IHJlcG9ydGVyT3B0aW9ucyBvcHRpb25hbCBvcHRpb25zXFxuICovXFxuTW9jaGEucHJvdG90eXBlLnJlcG9ydGVyID0gZnVuY3Rpb24ocmVwb3J0ZXIsIHJlcG9ydGVyT3B0aW9ucykge1xcbiAgaWYgKHR5cGVvZiByZXBvcnRlciA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICB0aGlzLl9yZXBvcnRlciA9IHJlcG9ydGVyO1xcbiAgfSBlbHNlIHtcXG4gICAgcmVwb3J0ZXIgPSByZXBvcnRlciB8fCAnc3BlYyc7XFxuICAgIHZhciBfcmVwb3J0ZXI7XFxuICAgIC8vIFRyeSB0byBsb2FkIGEgYnVpbHQtaW4gcmVwb3J0ZXIuXFxuICAgIGlmIChyZXBvcnRlcnNbcmVwb3J0ZXJdKSB7XFxuICAgICAgX3JlcG9ydGVyID0gcmVwb3J0ZXJzW3JlcG9ydGVyXTtcXG4gICAgfVxcbiAgICAvLyBUcnkgdG8gbG9hZCByZXBvcnRlcnMgZnJvbSBwcm9jZXNzLmN3ZCgpIGFuZCBub2RlX21vZHVsZXNcXG4gICAgaWYgKCFfcmVwb3J0ZXIpIHtcXG4gICAgICB0cnkge1xcbiAgICAgICAgX3JlcG9ydGVyID0gcmVxdWlyZShyZXBvcnRlcik7XFxuICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICBlcnIubWVzc2FnZS5pbmRleE9mKCdDYW5ub3QgZmluZCBtb2R1bGUnKSAhPT0gLTFcXG4gICAgICAgICAgPyBjb25zb2xlLndhcm4oJ1xcXCInICsgcmVwb3J0ZXIgKyAnXFxcIiByZXBvcnRlciBub3QgZm91bmQnKVxcbiAgICAgICAgICA6IGNvbnNvbGUud2FybignXFxcIicgKyByZXBvcnRlciArICdcXFwiIHJlcG9ydGVyIGJsZXcgdXAgd2l0aCBlcnJvcjpcXFxcbicgKyBlcnIuc3RhY2spO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBpZiAoIV9yZXBvcnRlciAmJiByZXBvcnRlciA9PT0gJ3RlYW1jaXR5Jykge1xcbiAgICAgIGNvbnNvbGUud2FybignVGhlIFRlYW1jaXR5IHJlcG9ydGVyIHdhcyBtb3ZlZCB0byBhIHBhY2thZ2UgbmFtZWQgJ1xcbiAgICAgICAgKyAnbW9jaGEtdGVhbWNpdHktcmVwb3J0ZXIgJ1xcbiAgICAgICAgKyAnKGh0dHBzOi8vbnBtanMub3JnL3BhY2thZ2UvbW9jaGEtdGVhbWNpdHktcmVwb3J0ZXIpLicpO1xcbiAgICB9XFxuICAgIGlmICghX3JlcG9ydGVyKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJlcG9ydGVyIFxcXCInICsgcmVwb3J0ZXIgKyAnXFxcIicpO1xcbiAgICB9XFxuICAgIHRoaXMuX3JlcG9ydGVyID0gX3JlcG9ydGVyO1xcbiAgfVxcbiAgdGhpcy5vcHRpb25zLnJlcG9ydGVyT3B0aW9ucyA9IHJlcG9ydGVyT3B0aW9ucztcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IHRlc3QgVUkgYG5hbWVgLCBkZWZhdWx0cyB0byBcXFwiYmRkXFxcIi5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtzdHJpbmd9IGJkZFxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS51aSA9IGZ1bmN0aW9uKG5hbWUpIHtcXG4gIG5hbWUgPSBuYW1lIHx8ICdiZGQnO1xcbiAgdGhpcy5fdWkgPSBleHBvcnRzLmludGVyZmFjZXNbbmFtZV07XFxuICBpZiAoIXRoaXMuX3VpKSB7XFxuICAgIHRyeSB7XFxuICAgICAgdGhpcy5fdWkgPSByZXF1aXJlKG5hbWUpO1xcbiAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW50ZXJmYWNlIFxcXCInICsgbmFtZSArICdcXFwiJyk7XFxuICAgIH1cXG4gIH1cXG4gIHRoaXMuX3VpID0gdGhpcy5fdWkodGhpcy5zdWl0ZSk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIExvYWQgcmVnaXN0ZXJlZCBmaWxlcy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5sb2FkRmlsZXMgPSBmdW5jdGlvbihmbikge1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHN1aXRlID0gdGhpcy5zdWl0ZTtcXG4gIHRoaXMuZmlsZXMuZm9yRWFjaChmdW5jdGlvbihmaWxlKSB7XFxuICAgIGZpbGUgPSBwYXRoLnJlc29sdmUoZmlsZSk7XFxuICAgIHN1aXRlLmVtaXQoJ3ByZS1yZXF1aXJlJywgZ2xvYmFsLCBmaWxlLCBzZWxmKTtcXG4gICAgc3VpdGUuZW1pdCgncmVxdWlyZScsIHJlcXVpcmUoZmlsZSksIGZpbGUsIHNlbGYpO1xcbiAgICBzdWl0ZS5lbWl0KCdwb3N0LXJlcXVpcmUnLCBnbG9iYWwsIGZpbGUsIHNlbGYpO1xcbiAgfSk7XFxuICBmbiAmJiBmbigpO1xcbn07XFxuXFxuLyoqXFxuICogRW5hYmxlIGdyb3dsIHN1cHBvcnQuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuX2dyb3dsID0gZnVuY3Rpb24ocnVubmVyLCByZXBvcnRlcikge1xcbiAgdmFyIG5vdGlmeSA9IHJlcXVpcmUoJ2dyb3dsJyk7XFxuXFxuICBydW5uZXIub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgc3RhdHMgPSByZXBvcnRlci5zdGF0cztcXG4gICAgaWYgKHN0YXRzLmZhaWx1cmVzKSB7XFxuICAgICAgdmFyIG1zZyA9IHN0YXRzLmZhaWx1cmVzICsgJyBvZiAnICsgcnVubmVyLnRvdGFsICsgJyB0ZXN0cyBmYWlsZWQnO1xcbiAgICAgIG5vdGlmeShtc2csIHsgbmFtZTogJ21vY2hhJywgdGl0bGU6ICdGYWlsZWQnLCBpbWFnZTogaW1hZ2UoJ2Vycm9yJykgfSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgbm90aWZ5KHN0YXRzLnBhc3NlcyArICcgdGVzdHMgcGFzc2VkIGluICcgKyBzdGF0cy5kdXJhdGlvbiArICdtcycsIHtcXG4gICAgICAgIG5hbWU6ICdtb2NoYScsXFxuICAgICAgICB0aXRsZTogJ1Bhc3NlZCcsXFxuICAgICAgICBpbWFnZTogaW1hZ2UoJ29rJylcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfSk7XFxufTtcXG5cXG4vKipcXG4gKiBBZGQgcmVnZXhwIHRvIGdyZXAsIGlmIGByZWAgaXMgYSBzdHJpbmcgaXQgaXMgZXNjYXBlZC5cXG4gKlxcbiAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gcmVcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gcmVcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuZ3JlcCA9IGZ1bmN0aW9uKHJlKSB7XFxuICB0aGlzLm9wdGlvbnMuZ3JlcCA9IHR5cGVvZiByZSA9PT0gJ3N0cmluZycgPyBuZXcgUmVnRXhwKGVzY2FwZVJlKHJlKSkgOiByZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogSW52ZXJ0IGAuZ3JlcCgpYCBtYXRjaGVzLlxcbiAqXFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24oKSB7XFxuICB0aGlzLm9wdGlvbnMuaW52ZXJ0ID0gdHJ1ZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogSWdub3JlIGdsb2JhbCBsZWFrcy5cXG4gKlxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlXFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlnbm9yZVxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5pZ25vcmVMZWFrcyA9IGZ1bmN0aW9uKGlnbm9yZSkge1xcbiAgdGhpcy5vcHRpb25zLmlnbm9yZUxlYWtzID0gQm9vbGVhbihpZ25vcmUpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBFbmFibGUgZ2xvYmFsIGxlYWsgY2hlY2tpbmcuXFxuICpcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5jaGVja0xlYWtzID0gZnVuY3Rpb24oKSB7XFxuICB0aGlzLm9wdGlvbnMuaWdub3JlTGVha3MgPSBmYWxzZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogRGlzcGxheSBsb25nIHN0YWNrLXRyYWNlIG9uIGZhaWxpbmdcXG4gKlxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuTW9jaGEucHJvdG90eXBlLmZ1bGxUcmFjZSA9IGZ1bmN0aW9uKCkge1xcbiAgdGhpcy5vcHRpb25zLmZ1bGxTdGFja1RyYWNlID0gdHJ1ZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogRW5hYmxlIGdyb3dsIHN1cHBvcnQuXFxuICpcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5ncm93bCA9IGZ1bmN0aW9uKCkge1xcbiAgdGhpcy5vcHRpb25zLmdyb3dsID0gdHJ1ZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogSWdub3JlIGBnbG9iYWxzYCBhcnJheSBvciBzdHJpbmcuXFxuICpcXG4gKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gZ2xvYmFsc1xcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGdsb2JhbHNcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuZ2xvYmFscyA9IGZ1bmN0aW9uKGdsb2JhbHMpIHtcXG4gIHRoaXMub3B0aW9ucy5nbG9iYWxzID0gKHRoaXMub3B0aW9ucy5nbG9iYWxzIHx8IFtdKS5jb25jYXQoZ2xvYmFscyk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIEVtaXQgY29sb3Igb3V0cHV0LlxcbiAqXFxuICogQHBhcmFtIHtCb29sZWFufSBjb2xvcnNcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29sb3JzXFxuICogQHJldHVybiB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLnVzZUNvbG9ycyA9IGZ1bmN0aW9uKGNvbG9ycykge1xcbiAgaWYgKGNvbG9ycyAhPT0gdW5kZWZpbmVkKSB7XFxuICAgIHRoaXMub3B0aW9ucy51c2VDb2xvcnMgPSBjb2xvcnM7XFxuICB9XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFVzZSBpbmxpbmUgZGlmZnMgcmF0aGVyIHRoYW4gKy8tLlxcbiAqXFxuICogQHBhcmFtIHtCb29sZWFufSBpbmxpbmVEaWZmc1xcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtib29sZWFufSBpbmxpbmVEaWZmc1xcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS51c2VJbmxpbmVEaWZmcyA9IGZ1bmN0aW9uKGlubGluZURpZmZzKSB7XFxuICB0aGlzLm9wdGlvbnMudXNlSW5saW5lRGlmZnMgPSBpbmxpbmVEaWZmcyAhPT0gdW5kZWZpbmVkICYmIGlubGluZURpZmZzO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgdGhlIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzLlxcbiAqXFxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXRcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0XFxuICogQHJldHVybiB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbih0aW1lb3V0KSB7XFxuICB0aGlzLnN1aXRlLnRpbWVvdXQodGltZW91dCk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCB0aGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJldHJ5IGZhaWxlZCB0ZXN0cy5cXG4gKlxcbiAqIEBwYXJhbSB7TnVtYmVyfSByZXRyeSB0aW1lc1xcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuTW9jaGEucHJvdG90eXBlLnJldHJpZXMgPSBmdW5jdGlvbihuKSB7XFxuICB0aGlzLnN1aXRlLnJldHJpZXMobik7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCBzbG93bmVzcyB0aHJlc2hvbGQgaW4gbWlsbGlzZWNvbmRzLlxcbiAqXFxuICogQHBhcmFtIHtOdW1iZXJ9IHNsb3dcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBzbG93XFxuICogQHJldHVybiB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLnNsb3cgPSBmdW5jdGlvbihzbG93KSB7XFxuICB0aGlzLnN1aXRlLnNsb3coc2xvdyk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIEVuYWJsZSB0aW1lb3V0cy5cXG4gKlxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5hYmxlZFxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXFxuICogQHJldHVybiB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLmVuYWJsZVRpbWVvdXRzID0gZnVuY3Rpb24oZW5hYmxlZCkge1xcbiAgdGhpcy5zdWl0ZS5lbmFibGVUaW1lb3V0cyhhcmd1bWVudHMubGVuZ3RoICYmIGVuYWJsZWQgIT09IHVuZGVmaW5lZCA/IGVuYWJsZWQgOiB0cnVlKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogTWFrZXMgYWxsIHRlc3RzIGFzeW5jIChhY2NlcHRpbmcgYSBjYWxsYmFjaylcXG4gKlxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuTW9jaGEucHJvdG90eXBlLmFzeW5jT25seSA9IGZ1bmN0aW9uKCkge1xcbiAgdGhpcy5vcHRpb25zLmFzeW5jT25seSA9IHRydWU7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIERpc2FibGUgc3ludGF4IGhpZ2hsaWdodGluZyAoaW4gYnJvd3NlcikuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5ub0hpZ2hsaWdodGluZyA9IGZ1bmN0aW9uKCkge1xcbiAgdGhpcy5vcHRpb25zLm5vSGlnaGxpZ2h0aW5nID0gdHJ1ZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogRW5hYmxlIHVuY2F1Z2h0IGVycm9ycyB0byBwcm9wYWdhdGUgKGluIGJyb3dzZXIpLlxcbiAqXFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuYWxsb3dVbmNhdWdodCA9IGZ1bmN0aW9uKCkge1xcbiAgdGhpcy5vcHRpb25zLmFsbG93VW5jYXVnaHQgPSB0cnVlO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBEZWxheSByb290IHN1aXRlIGV4ZWN1dGlvbi5cXG4gKiBAcmV0dXJucyB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24gZGVsYXkoKSB7XFxuICB0aGlzLm9wdGlvbnMuZGVsYXkgPSB0cnVlO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gdGVzdHMgYW5kIGludm9rZSBgZm4oKWAgd2hlbiBjb21wbGV0ZS5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAcmV0dXJuIHtSdW5uZXJ9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKGZuKSB7XFxuICBpZiAodGhpcy5maWxlcy5sZW5ndGgpIHtcXG4gICAgdGhpcy5sb2FkRmlsZXMoKTtcXG4gIH1cXG4gIHZhciBzdWl0ZSA9IHRoaXMuc3VpdGU7XFxuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcXG4gIG9wdGlvbnMuZmlsZXMgPSB0aGlzLmZpbGVzO1xcbiAgdmFyIHJ1bm5lciA9IG5ldyBleHBvcnRzLlJ1bm5lcihzdWl0ZSwgb3B0aW9ucy5kZWxheSk7XFxuICB2YXIgcmVwb3J0ZXIgPSBuZXcgdGhpcy5fcmVwb3J0ZXIocnVubmVyLCBvcHRpb25zKTtcXG4gIHJ1bm5lci5pZ25vcmVMZWFrcyA9IG9wdGlvbnMuaWdub3JlTGVha3MgIT09IGZhbHNlO1xcbiAgcnVubmVyLmZ1bGxTdGFja1RyYWNlID0gb3B0aW9ucy5mdWxsU3RhY2tUcmFjZTtcXG4gIHJ1bm5lci5hc3luY09ubHkgPSBvcHRpb25zLmFzeW5jT25seTtcXG4gIHJ1bm5lci5hbGxvd1VuY2F1Z2h0ID0gb3B0aW9ucy5hbGxvd1VuY2F1Z2h0O1xcbiAgaWYgKG9wdGlvbnMuZ3JlcCkge1xcbiAgICBydW5uZXIuZ3JlcChvcHRpb25zLmdyZXAsIG9wdGlvbnMuaW52ZXJ0KTtcXG4gIH1cXG4gIGlmIChvcHRpb25zLmdsb2JhbHMpIHtcXG4gICAgcnVubmVyLmdsb2JhbHMob3B0aW9ucy5nbG9iYWxzKTtcXG4gIH1cXG4gIGlmIChvcHRpb25zLmdyb3dsKSB7XFxuICAgIHRoaXMuX2dyb3dsKHJ1bm5lciwgcmVwb3J0ZXIpO1xcbiAgfVxcbiAgaWYgKG9wdGlvbnMudXNlQ29sb3JzICE9PSB1bmRlZmluZWQpIHtcXG4gICAgZXhwb3J0cy5yZXBvcnRlcnMuQmFzZS51c2VDb2xvcnMgPSBvcHRpb25zLnVzZUNvbG9ycztcXG4gIH1cXG4gIGV4cG9ydHMucmVwb3J0ZXJzLkJhc2UuaW5saW5lRGlmZnMgPSBvcHRpb25zLnVzZUlubGluZURpZmZzO1xcblxcbiAgZnVuY3Rpb24gZG9uZShmYWlsdXJlcykge1xcbiAgICBpZiAocmVwb3J0ZXIuZG9uZSkge1xcbiAgICAgIHJlcG9ydGVyLmRvbmUoZmFpbHVyZXMsIGZuKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBmbiAmJiBmbihmYWlsdXJlcyk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBydW5uZXIucnVuKGRvbmUpO1xcbn07XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSxcXFwiL2xpYlxcXCIpXFxufSx7XFxcIi4vY29udGV4dFxcXCI6NixcXFwiLi9ob29rXFxcIjo3LFxcXCIuL2ludGVyZmFjZXNcXFwiOjExLFxcXCIuL3JlcG9ydGVyc1xcXCI6MjIsXFxcIi4vcnVubmFibGVcXFwiOjM1LFxcXCIuL3J1bm5lclxcXCI6MzYsXFxcIi4vc3VpdGVcXFwiOjM3LFxcXCIuL3Rlc3RcXFwiOjM4LFxcXCIuL3V0aWxzXFxcIjozOSxcXFwiX3Byb2Nlc3NcXFwiOjUxLFxcXCJlc2NhcGUtc3RyaW5nLXJlZ2V4cFxcXCI6NjgsXFxcImdyb3dsXFxcIjo2OSxcXFwicGF0aFxcXCI6NDF9XSwxNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyoqXFxuICogSGVscGVycy5cXG4gKi9cXG5cXG52YXIgcyA9IDEwMDA7XFxudmFyIG0gPSBzICogNjA7XFxudmFyIGggPSBtICogNjA7XFxudmFyIGQgPSBoICogMjQ7XFxudmFyIHkgPSBkICogMzY1LjI1O1xcblxcbi8qKlxcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXFxuICpcXG4gKiBPcHRpb25zOlxcbiAqXFxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsXFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcXG4gKiBAcmV0dXJuIHtzdHJpbmd8bnVtYmVyfVxcbiAqL1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XFxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcXG4gIH1cXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb2NoYWpzL21vY2hhL3B1bGwvMTAzNVxcbiAgcmV0dXJuIG9wdGlvbnNbJ2xvbmcnXSA/IGxvbmdGb3JtYXQodmFsKSA6IHNob3J0Rm9ybWF0KHZhbCk7XFxufTtcXG5cXG4vKipcXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXFxuICogQHJldHVybiB7bnVtYmVyfVxcbiAqL1xcbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xcbiAgdmFyIG1hdGNoID0gKC9eKCg/OlxcXFxkKyk/XFxcXC4/XFxcXGQrKSAqKG1zfHNlY29uZHM/fHN8bWludXRlcz98bXxob3Vycz98aHxkYXlzP3xkfHllYXJzP3x5KT8kL2kpLmV4ZWMoc3RyKTtcXG4gIGlmICghbWF0Y2gpIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcXG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XFxuICBzd2l0Y2ggKHR5cGUpIHtcXG4gICAgY2FzZSAneWVhcnMnOlxcbiAgICBjYXNlICd5ZWFyJzpcXG4gICAgY2FzZSAneSc6XFxuICAgICAgcmV0dXJuIG4gKiB5O1xcbiAgICBjYXNlICdkYXlzJzpcXG4gICAgY2FzZSAnZGF5JzpcXG4gICAgY2FzZSAnZCc6XFxuICAgICAgcmV0dXJuIG4gKiBkO1xcbiAgICBjYXNlICdob3Vycyc6XFxuICAgIGNhc2UgJ2hvdXInOlxcbiAgICBjYXNlICdoJzpcXG4gICAgICByZXR1cm4gbiAqIGg7XFxuICAgIGNhc2UgJ21pbnV0ZXMnOlxcbiAgICBjYXNlICdtaW51dGUnOlxcbiAgICBjYXNlICdtJzpcXG4gICAgICByZXR1cm4gbiAqIG07XFxuICAgIGNhc2UgJ3NlY29uZHMnOlxcbiAgICBjYXNlICdzZWNvbmQnOlxcbiAgICBjYXNlICdzJzpcXG4gICAgICByZXR1cm4gbiAqIHM7XFxuICAgIGNhc2UgJ21zJzpcXG4gICAgICByZXR1cm4gbjtcXG4gICAgZGVmYXVsdDpcXG4gICAgICAvLyBObyBkZWZhdWx0IGNhc2VcXG4gIH1cXG59XFxuXFxuLyoqXFxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IG1zXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmZ1bmN0aW9uIHNob3J0Rm9ybWF0KG1zKSB7XFxuICBpZiAobXMgPj0gZCkge1xcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xcbiAgfVxcbiAgaWYgKG1zID49IGgpIHtcXG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcXG4gIH1cXG4gIGlmIChtcyA+PSBtKSB7XFxuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XFxuICB9XFxuICBpZiAobXMgPj0gcykge1xcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xcbiAgfVxcbiAgcmV0dXJuIG1zICsgJ21zJztcXG59XFxuXFxuLyoqXFxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gbXNcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZnVuY3Rpb24gbG9uZ0Zvcm1hdChtcykge1xcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpXFxuICAgIHx8IHBsdXJhbChtcywgaCwgJ2hvdXInKVxcbiAgICB8fCBwbHVyYWwobXMsIG0sICdtaW51dGUnKVxcbiAgICB8fCBwbHVyYWwobXMsIHMsICdzZWNvbmQnKVxcbiAgICB8fCBtcyArICcgbXMnO1xcbn1cXG5cXG4vKipcXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtc1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcXG4gKi9cXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcXG4gIGlmIChtcyA8IG4pIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgaWYgKG1zIDwgbiAqIDEuNSkge1xcbiAgICByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcXG4gIH1cXG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XFxufVxcblxcbn0se31dLDE2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYFBlbmRpbmdgLlxcbiAqL1xcblxcbm1vZHVsZS5leHBvcnRzID0gUGVuZGluZztcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBQZW5kaW5nYCBlcnJvciB3aXRoIHRoZSBnaXZlbiBtZXNzYWdlLlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcXG4gKi9cXG5mdW5jdGlvbiBQZW5kaW5nKG1lc3NhZ2UpIHtcXG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XFxufVxcblxcbn0se31dLDE3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciB0dHkgPSByZXF1aXJlKCd0dHknKTtcXG52YXIgZGlmZiA9IHJlcXVpcmUoJ2RpZmYnKTtcXG52YXIgbXMgPSByZXF1aXJlKCcuLi9tcycpO1xcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XFxudmFyIHN1cHBvcnRzQ29sb3IgPSBwcm9jZXNzLmJyb3dzZXIgPyBudWxsIDogcmVxdWlyZSgnc3VwcG9ydHMtY29sb3InKTtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYEJhc2VgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEJhc2U7XFxuXFxuLyoqXFxuICogU2F2ZSB0aW1lciByZWZlcmVuY2VzIHRvIGF2b2lkIFNpbm9uIGludGVyZmVyaW5nLlxcbiAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL21vY2hhanMvbW9jaGEvaXNzdWVzLzIzN1xcbiAqL1xcblxcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzLCBuby1uYXRpdmUtcmVhc3NpZ24gKi9cXG52YXIgRGF0ZSA9IGdsb2JhbC5EYXRlO1xcbnZhciBzZXRUaW1lb3V0ID0gZ2xvYmFsLnNldFRpbWVvdXQ7XFxudmFyIHNldEludGVydmFsID0gZ2xvYmFsLnNldEludGVydmFsO1xcbnZhciBjbGVhclRpbWVvdXQgPSBnbG9iYWwuY2xlYXJUaW1lb3V0O1xcbnZhciBjbGVhckludGVydmFsID0gZ2xvYmFsLmNsZWFySW50ZXJ2YWw7XFxuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycywgbm8tbmF0aXZlLXJlYXNzaWduICovXFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgYm90aCBzdGRpbyBzdHJlYW1zIGFyZSBhc3NvY2lhdGVkIHdpdGggYSB0dHkuXFxuICovXFxuXFxudmFyIGlzYXR0eSA9IHR0eS5pc2F0dHkoMSkgJiYgdHR5LmlzYXR0eSgyKTtcXG5cXG4vKipcXG4gKiBFbmFibGUgY29sb3JpbmcgYnkgZGVmYXVsdCwgZXhjZXB0IGluIHRoZSBicm93c2VyIGludGVyZmFjZS5cXG4gKi9cXG5cXG5leHBvcnRzLnVzZUNvbG9ycyA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgKHN1cHBvcnRzQ29sb3IgfHwgKHByb2Nlc3MuZW52Lk1PQ0hBX0NPTE9SUyAhPT0gdW5kZWZpbmVkKSk7XFxuXFxuLyoqXFxuICogSW5saW5lIGRpZmZzIGluc3RlYWQgb2YgKy8tXFxuICovXFxuXFxuZXhwb3J0cy5pbmxpbmVEaWZmcyA9IGZhbHNlO1xcblxcbi8qKlxcbiAqIERlZmF1bHQgY29sb3IgbWFwLlxcbiAqL1xcblxcbmV4cG9ydHMuY29sb3JzID0ge1xcbiAgcGFzczogOTAsXFxuICBmYWlsOiAzMSxcXG4gICdicmlnaHQgcGFzcyc6IDkyLFxcbiAgJ2JyaWdodCBmYWlsJzogOTEsXFxuICAnYnJpZ2h0IHllbGxvdyc6IDkzLFxcbiAgcGVuZGluZzogMzYsXFxuICBzdWl0ZTogMCxcXG4gICdlcnJvciB0aXRsZSc6IDAsXFxuICAnZXJyb3IgbWVzc2FnZSc6IDMxLFxcbiAgJ2Vycm9yIHN0YWNrJzogOTAsXFxuICBjaGVja21hcms6IDMyLFxcbiAgZmFzdDogOTAsXFxuICBtZWRpdW06IDMzLFxcbiAgc2xvdzogMzEsXFxuICBncmVlbjogMzIsXFxuICBsaWdodDogOTAsXFxuICAnZGlmZiBndXR0ZXInOiA5MCxcXG4gICdkaWZmIGFkZGVkJzogMzIsXFxuICAnZGlmZiByZW1vdmVkJzogMzFcXG59O1xcblxcbi8qKlxcbiAqIERlZmF1bHQgc3ltYm9sIG1hcC5cXG4gKi9cXG5cXG5leHBvcnRzLnN5bWJvbHMgPSB7XFxuICBvazogJ+KckycsXFxuICBlcnI6ICfinJYnLFxcbiAgZG90OiAn4oCkJ1xcbn07XFxuXFxuLy8gV2l0aCBub2RlLmpzIG9uIFdpbmRvd3M6IHVzZSBzeW1ib2xzIGF2YWlsYWJsZSBpbiB0ZXJtaW5hbCBkZWZhdWx0IGZvbnRzXFxuaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcXG4gIGV4cG9ydHMuc3ltYm9scy5vayA9ICdcXFxcdTIyMUEnO1xcbiAgZXhwb3J0cy5zeW1ib2xzLmVyciA9ICdcXFxcdTAwRDcnO1xcbiAgZXhwb3J0cy5zeW1ib2xzLmRvdCA9ICcuJztcXG59XFxuXFxuLyoqXFxuICogQ29sb3IgYHN0cmAgd2l0aCB0aGUgZ2l2ZW4gYHR5cGVgLFxcbiAqIGFsbG93aW5nIGNvbG9ycyB0byBiZSBkaXNhYmxlZCxcXG4gKiBhcyB3ZWxsIGFzIHVzZXItZGVmaW5lZCBjb2xvclxcbiAqIHNjaGVtZXMuXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICogQGFwaSBwcml2YXRlXFxuICovXFxudmFyIGNvbG9yID0gZXhwb3J0cy5jb2xvciA9IGZ1bmN0aW9uKHR5cGUsIHN0cikge1xcbiAgaWYgKCFleHBvcnRzLnVzZUNvbG9ycykge1xcbiAgICByZXR1cm4gU3RyaW5nKHN0cik7XFxuICB9XFxuICByZXR1cm4gJ1xcXFx1MDAxYlsnICsgZXhwb3J0cy5jb2xvcnNbdHlwZV0gKyAnbScgKyBzdHIgKyAnXFxcXHUwMDFiWzBtJztcXG59O1xcblxcbi8qKlxcbiAqIEV4cG9zZSB0ZXJtIHdpbmRvdyBzaXplLCB3aXRoIHNvbWUgZGVmYXVsdHMgZm9yIHdoZW4gc3RkZXJyIGlzIG5vdCBhIHR0eS5cXG4gKi9cXG5cXG5leHBvcnRzLndpbmRvdyA9IHtcXG4gIHdpZHRoOiA3NVxcbn07XFxuXFxuaWYgKGlzYXR0eSkge1xcbiAgZXhwb3J0cy53aW5kb3cud2lkdGggPSBwcm9jZXNzLnN0ZG91dC5nZXRXaW5kb3dTaXplXFxuICAgICAgPyBwcm9jZXNzLnN0ZG91dC5nZXRXaW5kb3dTaXplKDEpWzBdXFxuICAgICAgOiB0dHkuZ2V0V2luZG93U2l6ZSgpWzFdO1xcbn1cXG5cXG4vKipcXG4gKiBFeHBvc2Ugc29tZSBiYXNpYyBjdXJzb3IgaW50ZXJhY3Rpb25zIHRoYXQgYXJlIGNvbW1vbiBhbW9uZyByZXBvcnRlcnMuXFxuICovXFxuXFxuZXhwb3J0cy5jdXJzb3IgPSB7XFxuICBoaWRlOiBmdW5jdGlvbigpIHtcXG4gICAgaXNhdHR5ICYmIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXFxcdTAwMWJbPzI1bCcpO1xcbiAgfSxcXG5cXG4gIHNob3c6IGZ1bmN0aW9uKCkge1xcbiAgICBpc2F0dHkgJiYgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFx1MDAxYls/MjVoJyk7XFxuICB9LFxcblxcbiAgZGVsZXRlTGluZTogZnVuY3Rpb24oKSB7XFxuICAgIGlzYXR0eSAmJiBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxcXHUwMDFiWzJLJyk7XFxuICB9LFxcblxcbiAgYmVnaW5uaW5nT2ZMaW5lOiBmdW5jdGlvbigpIHtcXG4gICAgaXNhdHR5ICYmIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXFxcdTAwMWJbMEcnKTtcXG4gIH0sXFxuXFxuICBDUjogZnVuY3Rpb24oKSB7XFxuICAgIGlmIChpc2F0dHkpIHtcXG4gICAgICBleHBvcnRzLmN1cnNvci5kZWxldGVMaW5lKCk7XFxuICAgICAgZXhwb3J0cy5jdXJzb3IuYmVnaW5uaW5nT2ZMaW5lKCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFxyJyk7XFxuICAgIH1cXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIE91dHV0IHRoZSBnaXZlbiBgZmFpbHVyZXNgIGFzIGEgbGlzdC5cXG4gKlxcbiAqIEBwYXJhbSB7QXJyYXl9IGZhaWx1cmVzXFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5cXG5leHBvcnRzLmxpc3QgPSBmdW5jdGlvbihmYWlsdXJlcykge1xcbiAgY29uc29sZS5sb2coKTtcXG4gIGZhaWx1cmVzLmZvckVhY2goZnVuY3Rpb24odGVzdCwgaSkge1xcbiAgICAvLyBmb3JtYXRcXG4gICAgdmFyIGZtdCA9IGNvbG9yKCdlcnJvciB0aXRsZScsICcgICVzKSAlczpcXFxcbicpXFxuICAgICAgKyBjb2xvcignZXJyb3IgbWVzc2FnZScsICcgICAgICVzJylcXG4gICAgICArIGNvbG9yKCdlcnJvciBzdGFjaycsICdcXFxcbiVzXFxcXG4nKTtcXG5cXG4gICAgLy8gbXNnXFxuICAgIHZhciBtc2c7XFxuICAgIHZhciBlcnIgPSB0ZXN0LmVycjtcXG4gICAgdmFyIG1lc3NhZ2U7XFxuICAgIGlmIChlcnIubWVzc2FnZSkge1xcbiAgICAgIG1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXJyLmluc3BlY3QgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICBtZXNzYWdlID0gZXJyLmluc3BlY3QoKSArICcnO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIG1lc3NhZ2UgPSAnJztcXG4gICAgfVxcbiAgICB2YXIgc3RhY2sgPSBlcnIuc3RhY2sgfHwgbWVzc2FnZTtcXG4gICAgdmFyIGluZGV4ID0gc3RhY2suaW5kZXhPZihtZXNzYWdlKTtcXG4gICAgdmFyIGFjdHVhbCA9IGVyci5hY3R1YWw7XFxuICAgIHZhciBleHBlY3RlZCA9IGVyci5leHBlY3RlZDtcXG4gICAgdmFyIGVzY2FwZSA9IHRydWU7XFxuXFxuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcXG4gICAgICBtc2cgPSBtZXNzYWdlO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGluZGV4ICs9IG1lc3NhZ2UubGVuZ3RoO1xcbiAgICAgIG1zZyA9IHN0YWNrLnNsaWNlKDAsIGluZGV4KTtcXG4gICAgICAvLyByZW1vdmUgbXNnIGZyb20gc3RhY2tcXG4gICAgICBzdGFjayA9IHN0YWNrLnNsaWNlKGluZGV4ICsgMSk7XFxuICAgIH1cXG5cXG4gICAgLy8gdW5jYXVnaHRcXG4gICAgaWYgKGVyci51bmNhdWdodCkge1xcbiAgICAgIG1zZyA9ICdVbmNhdWdodCAnICsgbXNnO1xcbiAgICB9XFxuICAgIC8vIGV4cGxpY2l0bHkgc2hvdyBkaWZmXFxuICAgIGlmIChlcnIuc2hvd0RpZmYgIT09IGZhbHNlICYmIHNhbWVUeXBlKGFjdHVhbCwgZXhwZWN0ZWQpICYmIGV4cGVjdGVkICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICBlc2NhcGUgPSBmYWxzZTtcXG4gICAgICBpZiAoISh1dGlscy5pc1N0cmluZyhhY3R1YWwpICYmIHV0aWxzLmlzU3RyaW5nKGV4cGVjdGVkKSkpIHtcXG4gICAgICAgIGVyci5hY3R1YWwgPSBhY3R1YWwgPSB1dGlscy5zdHJpbmdpZnkoYWN0dWFsKTtcXG4gICAgICAgIGVyci5leHBlY3RlZCA9IGV4cGVjdGVkID0gdXRpbHMuc3RyaW5naWZ5KGV4cGVjdGVkKTtcXG4gICAgICB9XFxuXFxuICAgICAgZm10ID0gY29sb3IoJ2Vycm9yIHRpdGxlJywgJyAgJXMpICVzOlxcXFxuJXMnKSArIGNvbG9yKCdlcnJvciBzdGFjaycsICdcXFxcbiVzXFxcXG4nKTtcXG4gICAgICB2YXIgbWF0Y2ggPSBtZXNzYWdlLm1hdGNoKC9eKFteOl0rKTogZXhwZWN0ZWQvKTtcXG4gICAgICBtc2cgPSAnXFxcXG4gICAgICAnICsgY29sb3IoJ2Vycm9yIG1lc3NhZ2UnLCBtYXRjaCA/IG1hdGNoWzFdIDogbXNnKTtcXG5cXG4gICAgICBpZiAoZXhwb3J0cy5pbmxpbmVEaWZmcykge1xcbiAgICAgICAgbXNnICs9IGlubGluZURpZmYoZXJyLCBlc2NhcGUpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBtc2cgKz0gdW5pZmllZERpZmYoZXJyLCBlc2NhcGUpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvLyBpbmRlbnQgc3RhY2sgdHJhY2VcXG4gICAgc3RhY2sgPSBzdGFjay5yZXBsYWNlKC9eL2dtLCAnICAnKTtcXG5cXG4gICAgY29uc29sZS5sb2coZm10LCAoaSArIDEpLCB0ZXN0LmZ1bGxUaXRsZSgpLCBtc2csIHN0YWNrKTtcXG4gIH0pO1xcbn07XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgQmFzZWAgcmVwb3J0ZXIuXFxuICpcXG4gKiBBbGwgb3RoZXIgcmVwb3J0ZXJzIGdlbmVyYWxseVxcbiAqIGluaGVyaXQgZnJvbSB0aGlzIHJlcG9ydGVyLCBwcm92aWRpbmdcXG4gKiBzdGF0cyBzdWNoIGFzIHRlc3QgZHVyYXRpb24sIG51bWJlclxcbiAqIG9mIHRlc3RzIHBhc3NlZCAvIGZhaWxlZCBldGMuXFxuICpcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5cXG5mdW5jdGlvbiBCYXNlKHJ1bm5lcikge1xcbiAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cyA9IHsgc3VpdGVzOiAwLCB0ZXN0czogMCwgcGFzc2VzOiAwLCBwZW5kaW5nOiAwLCBmYWlsdXJlczogMCB9O1xcbiAgdmFyIGZhaWx1cmVzID0gdGhpcy5mYWlsdXJlcyA9IFtdO1xcblxcbiAgaWYgKCFydW5uZXIpIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgdGhpcy5ydW5uZXIgPSBydW5uZXI7XFxuXFxuICBydW5uZXIuc3RhdHMgPSBzdGF0cztcXG5cXG4gIHJ1bm5lci5vbignc3RhcnQnLCBmdW5jdGlvbigpIHtcXG4gICAgc3RhdHMuc3RhcnQgPSBuZXcgRGF0ZSgpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3N1aXRlJywgZnVuY3Rpb24oc3VpdGUpIHtcXG4gICAgc3RhdHMuc3VpdGVzID0gc3RhdHMuc3VpdGVzIHx8IDA7XFxuICAgIHN1aXRlLnJvb3QgfHwgc3RhdHMuc3VpdGVzKys7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigndGVzdCBlbmQnLCBmdW5jdGlvbigpIHtcXG4gICAgc3RhdHMudGVzdHMgPSBzdGF0cy50ZXN0cyB8fCAwO1xcbiAgICBzdGF0cy50ZXN0cysrO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Bhc3MnLCBmdW5jdGlvbih0ZXN0KSB7XFxuICAgIHN0YXRzLnBhc3NlcyA9IHN0YXRzLnBhc3NlcyB8fCAwO1xcblxcbiAgICBpZiAodGVzdC5kdXJhdGlvbiA+IHRlc3Quc2xvdygpKSB7XFxuICAgICAgdGVzdC5zcGVlZCA9ICdzbG93JztcXG4gICAgfSBlbHNlIGlmICh0ZXN0LmR1cmF0aW9uID4gdGVzdC5zbG93KCkgLyAyKSB7XFxuICAgICAgdGVzdC5zcGVlZCA9ICdtZWRpdW0nO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRlc3Quc3BlZWQgPSAnZmFzdCc7XFxuICAgIH1cXG5cXG4gICAgc3RhdHMucGFzc2VzKys7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZmFpbCcsIGZ1bmN0aW9uKHRlc3QsIGVycikge1xcbiAgICBzdGF0cy5mYWlsdXJlcyA9IHN0YXRzLmZhaWx1cmVzIHx8IDA7XFxuICAgIHN0YXRzLmZhaWx1cmVzKys7XFxuICAgIHRlc3QuZXJyID0gZXJyO1xcbiAgICBmYWlsdXJlcy5wdXNoKHRlc3QpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xcbiAgICBzdGF0cy5lbmQgPSBuZXcgRGF0ZSgpO1xcbiAgICBzdGF0cy5kdXJhdGlvbiA9IG5ldyBEYXRlKCkgLSBzdGF0cy5zdGFydDtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwZW5kaW5nJywgZnVuY3Rpb24oKSB7XFxuICAgIHN0YXRzLnBlbmRpbmcrKztcXG4gIH0pO1xcbn1cXG5cXG4vKipcXG4gKiBPdXRwdXQgY29tbW9uIGVwaWxvZ3VlIHVzZWQgYnkgbWFueSBvZlxcbiAqIHRoZSBidW5kbGVkIHJlcG9ydGVycy5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuQmFzZS5wcm90b3R5cGUuZXBpbG9ndWUgPSBmdW5jdGlvbigpIHtcXG4gIHZhciBzdGF0cyA9IHRoaXMuc3RhdHM7XFxuICB2YXIgZm10O1xcblxcbiAgY29uc29sZS5sb2coKTtcXG5cXG4gIC8vIHBhc3Nlc1xcbiAgZm10ID0gY29sb3IoJ2JyaWdodCBwYXNzJywgJyAnKVxcbiAgICArIGNvbG9yKCdncmVlbicsICcgJWQgcGFzc2luZycpXFxuICAgICsgY29sb3IoJ2xpZ2h0JywgJyAoJXMpJyk7XFxuXFxuICBjb25zb2xlLmxvZyhmbXQsXFxuICAgIHN0YXRzLnBhc3NlcyB8fCAwLFxcbiAgICBtcyhzdGF0cy5kdXJhdGlvbikpO1xcblxcbiAgLy8gcGVuZGluZ1xcbiAgaWYgKHN0YXRzLnBlbmRpbmcpIHtcXG4gICAgZm10ID0gY29sb3IoJ3BlbmRpbmcnLCAnICcpXFxuICAgICAgKyBjb2xvcigncGVuZGluZycsICcgJWQgcGVuZGluZycpO1xcblxcbiAgICBjb25zb2xlLmxvZyhmbXQsIHN0YXRzLnBlbmRpbmcpO1xcbiAgfVxcblxcbiAgLy8gZmFpbHVyZXNcXG4gIGlmIChzdGF0cy5mYWlsdXJlcykge1xcbiAgICBmbXQgPSBjb2xvcignZmFpbCcsICcgICVkIGZhaWxpbmcnKTtcXG5cXG4gICAgY29uc29sZS5sb2coZm10LCBzdGF0cy5mYWlsdXJlcyk7XFxuXFxuICAgIEJhc2UubGlzdCh0aGlzLmZhaWx1cmVzKTtcXG4gICAgY29uc29sZS5sb2coKTtcXG4gIH1cXG5cXG4gIGNvbnNvbGUubG9nKCk7XFxufTtcXG5cXG4vKipcXG4gKiBQYWQgdGhlIGdpdmVuIGBzdHJgIHRvIGBsZW5gLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxcbiAqIEBwYXJhbSB7c3RyaW5nfSBsZW5cXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZnVuY3Rpb24gcGFkKHN0ciwgbGVuKSB7XFxuICBzdHIgPSBTdHJpbmcoc3RyKTtcXG4gIHJldHVybiBBcnJheShsZW4gLSBzdHIubGVuZ3RoICsgMSkuam9pbignICcpICsgc3RyO1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm5zIGFuIGlubGluZSBkaWZmIGJldHdlZW4gMiBzdHJpbmdzIHdpdGggY29sb3VyZWQgQU5TSSBvdXRwdXRcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciB3aXRoIGFjdHVhbC9leHBlY3RlZFxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZXNjYXBlXFxuICogQHJldHVybiB7c3RyaW5nfSBEaWZmXFxuICovXFxuZnVuY3Rpb24gaW5saW5lRGlmZihlcnIsIGVzY2FwZSkge1xcbiAgdmFyIG1zZyA9IGVycm9yRGlmZihlcnIsICdXb3Jkc1dpdGhTcGFjZScsIGVzY2FwZSk7XFxuXFxuICAvLyBsaW5lbm9zXFxuICB2YXIgbGluZXMgPSBtc2cuc3BsaXQoJ1xcXFxuJyk7XFxuICBpZiAobGluZXMubGVuZ3RoID4gNCkge1xcbiAgICB2YXIgd2lkdGggPSBTdHJpbmcobGluZXMubGVuZ3RoKS5sZW5ndGg7XFxuICAgIG1zZyA9IGxpbmVzLm1hcChmdW5jdGlvbihzdHIsIGkpIHtcXG4gICAgICByZXR1cm4gcGFkKCsraSwgd2lkdGgpICsgJyB8JyArICcgJyArIHN0cjtcXG4gICAgfSkuam9pbignXFxcXG4nKTtcXG4gIH1cXG5cXG4gIC8vIGxlZ2VuZFxcbiAgbXNnID0gJ1xcXFxuJ1xcbiAgICArIGNvbG9yKCdkaWZmIHJlbW92ZWQnLCAnYWN0dWFsJylcXG4gICAgKyAnICdcXG4gICAgKyBjb2xvcignZGlmZiBhZGRlZCcsICdleHBlY3RlZCcpXFxuICAgICsgJ1xcXFxuXFxcXG4nXFxuICAgICsgbXNnXFxuICAgICsgJ1xcXFxuJztcXG5cXG4gIC8vIGluZGVudFxcbiAgbXNnID0gbXNnLnJlcGxhY2UoL14vZ20sICcgICAgICAnKTtcXG4gIHJldHVybiBtc2c7XFxufVxcblxcbi8qKlxcbiAqIFJldHVybnMgYSB1bmlmaWVkIGRpZmYgYmV0d2VlbiB0d28gc3RyaW5ncy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciB3aXRoIGFjdHVhbC9leHBlY3RlZFxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZXNjYXBlXFxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgZGlmZi5cXG4gKi9cXG5mdW5jdGlvbiB1bmlmaWVkRGlmZihlcnIsIGVzY2FwZSkge1xcbiAgdmFyIGluZGVudCA9ICcgICAgICAnO1xcbiAgZnVuY3Rpb24gY2xlYW5VcChsaW5lKSB7XFxuICAgIGlmIChlc2NhcGUpIHtcXG4gICAgICBsaW5lID0gZXNjYXBlSW52aXNpYmxlcyhsaW5lKTtcXG4gICAgfVxcbiAgICBpZiAobGluZVswXSA9PT0gJysnKSB7XFxuICAgICAgcmV0dXJuIGluZGVudCArIGNvbG9yTGluZXMoJ2RpZmYgYWRkZWQnLCBsaW5lKTtcXG4gICAgfVxcbiAgICBpZiAobGluZVswXSA9PT0gJy0nKSB7XFxuICAgICAgcmV0dXJuIGluZGVudCArIGNvbG9yTGluZXMoJ2RpZmYgcmVtb3ZlZCcsIGxpbmUpO1xcbiAgICB9XFxuICAgIGlmIChsaW5lLm1hdGNoKC9cXFxcQFxcXFxALykpIHtcXG4gICAgICByZXR1cm4gbnVsbDtcXG4gICAgfVxcbiAgICBpZiAobGluZS5tYXRjaCgvXFxcXFxcXFwgTm8gbmV3bGluZS8pKSB7XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG4gICAgcmV0dXJuIGluZGVudCArIGxpbmU7XFxuICB9XFxuICBmdW5jdGlvbiBub3RCbGFuayhsaW5lKSB7XFxuICAgIHJldHVybiB0eXBlb2YgbGluZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbGluZSAhPT0gbnVsbDtcXG4gIH1cXG4gIHZhciBtc2cgPSBkaWZmLmNyZWF0ZVBhdGNoKCdzdHJpbmcnLCBlcnIuYWN0dWFsLCBlcnIuZXhwZWN0ZWQpO1xcbiAgdmFyIGxpbmVzID0gbXNnLnNwbGl0KCdcXFxcbicpLnNwbGljZSg0KTtcXG4gIHJldHVybiAnXFxcXG4gICAgICAnXFxuICAgICsgY29sb3JMaW5lcygnZGlmZiBhZGRlZCcsICcrIGV4cGVjdGVkJykgKyAnICdcXG4gICAgKyBjb2xvckxpbmVzKCdkaWZmIHJlbW92ZWQnLCAnLSBhY3R1YWwnKVxcbiAgICArICdcXFxcblxcXFxuJ1xcbiAgICArIGxpbmVzLm1hcChjbGVhblVwKS5maWx0ZXIobm90QmxhbmspLmpvaW4oJ1xcXFxuJyk7XFxufVxcblxcbi8qKlxcbiAqIFJldHVybiBhIGNoYXJhY3RlciBkaWZmIGZvciBgZXJyYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXFxuICogQHBhcmFtIHtib29sZWFufSBlc2NhcGVcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZnVuY3Rpb24gZXJyb3JEaWZmKGVyciwgdHlwZSwgZXNjYXBlKSB7XFxuICB2YXIgYWN0dWFsID0gZXNjYXBlID8gZXNjYXBlSW52aXNpYmxlcyhlcnIuYWN0dWFsKSA6IGVyci5hY3R1YWw7XFxuICB2YXIgZXhwZWN0ZWQgPSBlc2NhcGUgPyBlc2NhcGVJbnZpc2libGVzKGVyci5leHBlY3RlZCkgOiBlcnIuZXhwZWN0ZWQ7XFxuICByZXR1cm4gZGlmZlsnZGlmZicgKyB0eXBlXShhY3R1YWwsIGV4cGVjdGVkKS5tYXAoZnVuY3Rpb24oc3RyKSB7XFxuICAgIGlmIChzdHIuYWRkZWQpIHtcXG4gICAgICByZXR1cm4gY29sb3JMaW5lcygnZGlmZiBhZGRlZCcsIHN0ci52YWx1ZSk7XFxuICAgIH1cXG4gICAgaWYgKHN0ci5yZW1vdmVkKSB7XFxuICAgICAgcmV0dXJuIGNvbG9yTGluZXMoJ2RpZmYgcmVtb3ZlZCcsIHN0ci52YWx1ZSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHN0ci52YWx1ZTtcXG4gIH0pLmpvaW4oJycpO1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHdpdGggYWxsIGludmlzaWJsZSBjaGFyYWN0ZXJzIGluIHBsYWluIHRleHRcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBsaW5lXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmZ1bmN0aW9uIGVzY2FwZUludmlzaWJsZXMobGluZSkge1xcbiAgcmV0dXJuIGxpbmUucmVwbGFjZSgvXFxcXHQvZywgJzx0YWI+JylcXG4gICAgLnJlcGxhY2UoL1xcXFxyL2csICc8Q1I+JylcXG4gICAgLnJlcGxhY2UoL1xcXFxuL2csICc8TEY+XFxcXG4nKTtcXG59XFxuXFxuLyoqXFxuICogQ29sb3IgbGluZXMgZm9yIGBzdHJgLCB1c2luZyB0aGUgY29sb3IgYG5hbWVgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmZ1bmN0aW9uIGNvbG9yTGluZXMobmFtZSwgc3RyKSB7XFxuICByZXR1cm4gc3RyLnNwbGl0KCdcXFxcbicpLm1hcChmdW5jdGlvbihzdHIpIHtcXG4gICAgcmV0dXJuIGNvbG9yKG5hbWUsIHN0cik7XFxuICB9KS5qb2luKCdcXFxcbicpO1xcbn1cXG5cXG4vKipcXG4gKiBPYmplY3QjdG9TdHJpbmcgcmVmZXJlbmNlLlxcbiAqL1xcbnZhciBvYmpUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XFxuXFxuLyoqXFxuICogQ2hlY2sgdGhhdCBhIC8gYiBoYXZlIHRoZSBzYW1lIHR5cGUuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge09iamVjdH0gYVxcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXFxuICogQHJldHVybiB7Ym9vbGVhbn1cXG4gKi9cXG5mdW5jdGlvbiBzYW1lVHlwZShhLCBiKSB7XFxuICByZXR1cm4gb2JqVG9TdHJpbmcuY2FsbChhKSA9PT0gb2JqVG9TdHJpbmcuY2FsbChiKTtcXG59XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSlcXG59LHtcXFwiLi4vbXNcXFwiOjE1LFxcXCIuLi91dGlsc1xcXCI6MzksXFxcIl9wcm9jZXNzXFxcIjo1MSxcXFwiZGlmZlxcXCI6NjcsXFxcInN1cHBvcnRzLWNvbG9yXFxcIjo0MSxcXFwidHR5XFxcIjo1fV0sMTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgRG9jYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBEb2M7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRG9jYCByZXBvcnRlci5cXG4gKlxcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcbmZ1bmN0aW9uIERvYyhydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIGluZGVudHMgPSAyO1xcblxcbiAgZnVuY3Rpb24gaW5kZW50KCkge1xcbiAgICByZXR1cm4gQXJyYXkoaW5kZW50cykuam9pbignICAnKTtcXG4gIH1cXG5cXG4gIHJ1bm5lci5vbignc3VpdGUnLCBmdW5jdGlvbihzdWl0ZSkge1xcbiAgICBpZiAoc3VpdGUucm9vdCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICArK2luZGVudHM7XFxuICAgIGNvbnNvbGUubG9nKCclczxzZWN0aW9uIGNsYXNzPVxcXCJzdWl0ZVxcXCI+JywgaW5kZW50KCkpO1xcbiAgICArK2luZGVudHM7XFxuICAgIGNvbnNvbGUubG9nKCclczxoMT4lczwvaDE+JywgaW5kZW50KCksIHV0aWxzLmVzY2FwZShzdWl0ZS50aXRsZSkpO1xcbiAgICBjb25zb2xlLmxvZygnJXM8ZGw+JywgaW5kZW50KCkpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3N1aXRlIGVuZCcsIGZ1bmN0aW9uKHN1aXRlKSB7XFxuICAgIGlmIChzdWl0ZS5yb290KSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGNvbnNvbGUubG9nKCclczwvZGw+JywgaW5kZW50KCkpO1xcbiAgICAtLWluZGVudHM7XFxuICAgIGNvbnNvbGUubG9nKCclczwvc2VjdGlvbj4nLCBpbmRlbnQoKSk7XFxuICAgIC0taW5kZW50cztcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwYXNzJywgZnVuY3Rpb24odGVzdCkge1xcbiAgICBjb25zb2xlLmxvZygnJXMgIDxkdD4lczwvZHQ+JywgaW5kZW50KCksIHV0aWxzLmVzY2FwZSh0ZXN0LnRpdGxlKSk7XFxuICAgIHZhciBjb2RlID0gdXRpbHMuZXNjYXBlKHV0aWxzLmNsZWFuKHRlc3QuYm9keSkpO1xcbiAgICBjb25zb2xlLmxvZygnJXMgIDxkZD48cHJlPjxjb2RlPiVzPC9jb2RlPjwvcHJlPjwvZGQ+JywgaW5kZW50KCksIGNvZGUpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2ZhaWwnLCBmdW5jdGlvbih0ZXN0LCBlcnIpIHtcXG4gICAgY29uc29sZS5sb2coJyVzICA8ZHQgY2xhc3M9XFxcImVycm9yXFxcIj4lczwvZHQ+JywgaW5kZW50KCksIHV0aWxzLmVzY2FwZSh0ZXN0LnRpdGxlKSk7XFxuICAgIHZhciBjb2RlID0gdXRpbHMuZXNjYXBlKHV0aWxzLmNsZWFuKHRlc3QuZm4uYm9keSkpO1xcbiAgICBjb25zb2xlLmxvZygnJXMgIDxkZCBjbGFzcz1cXFwiZXJyb3JcXFwiPjxwcmU+PGNvZGU+JXM8L2NvZGU+PC9wcmU+PC9kZD4nLCBpbmRlbnQoKSwgY29kZSk7XFxuICAgIGNvbnNvbGUubG9nKCclcyAgPGRkIGNsYXNzPVxcXCJlcnJvclxcXCI+JXM8L2RkPicsIGluZGVudCgpLCB1dGlscy5lc2NhcGUoZXJyKSk7XFxuICB9KTtcXG59XFxuXFxufSx7XFxcIi4uL3V0aWxzXFxcIjozOSxcXFwiLi9iYXNlXFxcIjoxN31dLDE5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlscycpLmluaGVyaXRzO1xcbnZhciBjb2xvciA9IEJhc2UuY29sb3I7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBEb3RgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IERvdDtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBEb3RgIG1hdHJpeCB0ZXN0IHJlcG9ydGVyLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gRG90KHJ1bm5lcikge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgd2lkdGggPSBCYXNlLndpbmRvdy53aWR0aCAqIC43NSB8IDA7XFxuICB2YXIgbiA9IC0xO1xcblxcbiAgcnVubmVyLm9uKCdzdGFydCcsIGZ1bmN0aW9uKCkge1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxcXG4nKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwZW5kaW5nJywgZnVuY3Rpb24oKSB7XFxuICAgIGlmICgrK24gJSB3aWR0aCA9PT0gMCkge1xcbiAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXFxcbiAgJyk7XFxuICAgIH1cXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IoJ3BlbmRpbmcnLCBCYXNlLnN5bWJvbHMuZG90KSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uKHRlc3QpIHtcXG4gICAgaWYgKCsrbiAlIHdpZHRoID09PSAwKSB7XFxuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFxuICAnKTtcXG4gICAgfVxcbiAgICBpZiAodGVzdC5zcGVlZCA9PT0gJ3Nsb3cnKSB7XFxuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IoJ2JyaWdodCB5ZWxsb3cnLCBCYXNlLnN5bWJvbHMuZG90KSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IodGVzdC5zcGVlZCwgQmFzZS5zeW1ib2xzLmRvdCkpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZmFpbCcsIGZ1bmN0aW9uKCkge1xcbiAgICBpZiAoKytuICUgd2lkdGggPT09IDApIHtcXG4gICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxcXG4gICcpO1xcbiAgICB9XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNvbG9yKCdmYWlsJywgQmFzZS5zeW1ib2xzLmRvdCkpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xcbiAgICBjb25zb2xlLmxvZygpO1xcbiAgICBzZWxmLmVwaWxvZ3VlKCk7XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXFxuICovXFxuaW5oZXJpdHMoRG90LCBCYXNlKTtcXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiLi4vdXRpbHNcXFwiOjM5LFxcXCIuL2Jhc2VcXFwiOjE3LFxcXCJfcHJvY2Vzc1xcXCI6NTF9XSwyMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzLF9fZGlybmFtZSl7XFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgSlNPTkNvdiA9IHJlcXVpcmUoJy4vanNvbi1jb3YnKTtcXG52YXIgcmVhZEZpbGVTeW5jID0gcmVxdWlyZSgnZnMnKS5yZWFkRmlsZVN5bmM7XFxudmFyIGpvaW4gPSByZXF1aXJlKCdwYXRoJykuam9pbjtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYEhUTUxDb3ZgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEhUTUxDb3Y7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgSnNDb3ZlcmFnZWAgcmVwb3J0ZXIuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKi9cXG5mdW5jdGlvbiBIVE1MQ292KHJ1bm5lcikge1xcbiAgdmFyIGphZGUgPSByZXF1aXJlKCdqYWRlJyk7XFxuICB2YXIgZmlsZSA9IGpvaW4oX19kaXJuYW1lLCAnL3RlbXBsYXRlcy9jb3ZlcmFnZS5qYWRlJyk7XFxuICB2YXIgc3RyID0gcmVhZEZpbGVTeW5jKGZpbGUsICd1dGY4Jyk7XFxuICB2YXIgZm4gPSBqYWRlLmNvbXBpbGUoc3RyLCB7IGZpbGVuYW1lOiBmaWxlIH0pO1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgSlNPTkNvdi5jYWxsKHRoaXMsIHJ1bm5lciwgZmFsc2UpO1xcblxcbiAgcnVubmVyLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoZm4oe1xcbiAgICAgIGNvdjogc2VsZi5jb3YsXFxuICAgICAgY292ZXJhZ2VDbGFzczogY292ZXJhZ2VDbGFzc1xcbiAgICB9KSk7XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogUmV0dXJuIGNvdmVyYWdlIGNsYXNzIGZvciBhIGdpdmVuIGNvdmVyYWdlIHBlcmNlbnRhZ2UuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gY292ZXJhZ2VQY3RnXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmZ1bmN0aW9uIGNvdmVyYWdlQ2xhc3MoY292ZXJhZ2VQY3RnKSB7XFxuICBpZiAoY292ZXJhZ2VQY3RnID49IDc1KSB7XFxuICAgIHJldHVybiAnaGlnaCc7XFxuICB9XFxuICBpZiAoY292ZXJhZ2VQY3RnID49IDUwKSB7XFxuICAgIHJldHVybiAnbWVkaXVtJztcXG4gIH1cXG4gIGlmIChjb3ZlcmFnZVBjdGcgPj0gMjUpIHtcXG4gICAgcmV0dXJuICdsb3cnO1xcbiAgfVxcbiAgcmV0dXJuICd0ZXJyaWJsZSc7XFxufVxcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLFxcXCIvbGliL3JlcG9ydGVyc1xcXCIpXFxufSx7XFxcIi4vanNvbi1jb3ZcXFwiOjIzLFxcXCJfcHJvY2Vzc1xcXCI6NTEsXFxcImZzXFxcIjo0MSxcXFwiamFkZVxcXCI6NDEsXFxcInBhdGhcXFwiOjQxfV0sMjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAoZ2xvYmFsKXtcXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cXG5cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcXG52YXIgUHJvZ3Jlc3MgPSByZXF1aXJlKCcuLi9icm93c2VyL3Byb2dyZXNzJyk7XFxudmFyIGVzY2FwZVJlID0gcmVxdWlyZSgnZXNjYXBlLXN0cmluZy1yZWdleHAnKTtcXG52YXIgZXNjYXBlID0gdXRpbHMuZXNjYXBlO1xcblxcbi8qKlxcbiAqIFNhdmUgdGltZXIgcmVmZXJlbmNlcyB0byBhdm9pZCBTaW5vbiBpbnRlcmZlcmluZyAoc2VlIEdILTIzNykuXFxuICovXFxuXFxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMsIG5vLW5hdGl2ZS1yZWFzc2lnbiAqL1xcbnZhciBEYXRlID0gZ2xvYmFsLkRhdGU7XFxudmFyIHNldFRpbWVvdXQgPSBnbG9iYWwuc2V0VGltZW91dDtcXG52YXIgc2V0SW50ZXJ2YWwgPSBnbG9iYWwuc2V0SW50ZXJ2YWw7XFxudmFyIGNsZWFyVGltZW91dCA9IGdsb2JhbC5jbGVhclRpbWVvdXQ7XFxudmFyIGNsZWFySW50ZXJ2YWwgPSBnbG9iYWwuY2xlYXJJbnRlcnZhbDtcXG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzLCBuby1uYXRpdmUtcmVhc3NpZ24gKi9cXG5cXG4vKipcXG4gKiBFeHBvc2UgYEhUTUxgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEhUTUw7XFxuXFxuLyoqXFxuICogU3RhdHMgdGVtcGxhdGUuXFxuICovXFxuXFxudmFyIHN0YXRzVGVtcGxhdGUgPSAnPHVsIGlkPVxcXCJtb2NoYS1zdGF0c1xcXCI+J1xcbiAgKyAnPGxpIGNsYXNzPVxcXCJwcm9ncmVzc1xcXCI+PGNhbnZhcyB3aWR0aD1cXFwiNDBcXFwiIGhlaWdodD1cXFwiNDBcXFwiPjwvY2FudmFzPjwvbGk+J1xcbiAgKyAnPGxpIGNsYXNzPVxcXCJwYXNzZXNcXFwiPjxhIGhyZWY9XFxcImphdmFzY3JpcHQ6dm9pZCgwKTtcXFwiPnBhc3Nlczo8L2E+IDxlbT4wPC9lbT48L2xpPidcXG4gICsgJzxsaSBjbGFzcz1cXFwiZmFpbHVyZXNcXFwiPjxhIGhyZWY9XFxcImphdmFzY3JpcHQ6dm9pZCgwKTtcXFwiPmZhaWx1cmVzOjwvYT4gPGVtPjA8L2VtPjwvbGk+J1xcbiAgKyAnPGxpIGNsYXNzPVxcXCJkdXJhdGlvblxcXCI+ZHVyYXRpb246IDxlbT4wPC9lbT5zPC9saT4nXFxuICArICc8L3VsPic7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgSFRNTGAgcmVwb3J0ZXIuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKi9cXG5mdW5jdGlvbiBIVE1MKHJ1bm5lcikge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgc3RhdHMgPSB0aGlzLnN0YXRzO1xcbiAgdmFyIHN0YXQgPSBmcmFnbWVudChzdGF0c1RlbXBsYXRlKTtcXG4gIHZhciBpdGVtcyA9IHN0YXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2xpJyk7XFxuICB2YXIgcGFzc2VzID0gaXRlbXNbMV0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2VtJylbMF07XFxuICB2YXIgcGFzc2VzTGluayA9IGl0ZW1zWzFdLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhJylbMF07XFxuICB2YXIgZmFpbHVyZXMgPSBpdGVtc1syXS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZW0nKVswXTtcXG4gIHZhciBmYWlsdXJlc0xpbmsgPSBpdGVtc1syXS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYScpWzBdO1xcbiAgdmFyIGR1cmF0aW9uID0gaXRlbXNbM10uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2VtJylbMF07XFxuICB2YXIgY2FudmFzID0gc3RhdC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY2FudmFzJylbMF07XFxuICB2YXIgcmVwb3J0ID0gZnJhZ21lbnQoJzx1bCBpZD1cXFwibW9jaGEtcmVwb3J0XFxcIj48L3VsPicpO1xcbiAgdmFyIHN0YWNrID0gW3JlcG9ydF07XFxuICB2YXIgcHJvZ3Jlc3M7XFxuICB2YXIgY3R4O1xcbiAgdmFyIHJvb3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9jaGEnKTtcXG5cXG4gIGlmIChjYW52YXMuZ2V0Q29udGV4dCkge1xcbiAgICB2YXIgcmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSBjYW52YXMud2lkdGg7XFxuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xcbiAgICBjYW52YXMud2lkdGggKj0gcmF0aW87XFxuICAgIGNhbnZhcy5oZWlnaHQgKj0gcmF0aW87XFxuICAgIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xcbiAgICBjdHguc2NhbGUocmF0aW8sIHJhdGlvKTtcXG4gICAgcHJvZ3Jlc3MgPSBuZXcgUHJvZ3Jlc3MoKTtcXG4gIH1cXG5cXG4gIGlmICghcm9vdCkge1xcbiAgICByZXR1cm4gZXJyb3IoJyNtb2NoYSBkaXYgbWlzc2luZywgYWRkIGl0IHRvIHlvdXIgZG9jdW1lbnQnKTtcXG4gIH1cXG5cXG4gIC8vIHBhc3MgdG9nZ2xlXFxuICBvbihwYXNzZXNMaW5rLCAnY2xpY2snLCBmdW5jdGlvbigpIHtcXG4gICAgdW5oaWRlKCk7XFxuICAgIHZhciBuYW1lID0gKC9wYXNzLykudGVzdChyZXBvcnQuY2xhc3NOYW1lKSA/ICcnIDogJyBwYXNzJztcXG4gICAgcmVwb3J0LmNsYXNzTmFtZSA9IHJlcG9ydC5jbGFzc05hbWUucmVwbGFjZSgvZmFpbHxwYXNzL2csICcnKSArIG5hbWU7XFxuICAgIGlmIChyZXBvcnQuY2xhc3NOYW1lLnRyaW0oKSkge1xcbiAgICAgIGhpZGVTdWl0ZXNXaXRob3V0KCd0ZXN0IHBhc3MnKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyBmYWlsdXJlIHRvZ2dsZVxcbiAgb24oZmFpbHVyZXNMaW5rLCAnY2xpY2snLCBmdW5jdGlvbigpIHtcXG4gICAgdW5oaWRlKCk7XFxuICAgIHZhciBuYW1lID0gKC9mYWlsLykudGVzdChyZXBvcnQuY2xhc3NOYW1lKSA/ICcnIDogJyBmYWlsJztcXG4gICAgcmVwb3J0LmNsYXNzTmFtZSA9IHJlcG9ydC5jbGFzc05hbWUucmVwbGFjZSgvZmFpbHxwYXNzL2csICcnKSArIG5hbWU7XFxuICAgIGlmIChyZXBvcnQuY2xhc3NOYW1lLnRyaW0oKSkge1xcbiAgICAgIGhpZGVTdWl0ZXNXaXRob3V0KCd0ZXN0IGZhaWwnKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICByb290LmFwcGVuZENoaWxkKHN0YXQpO1xcbiAgcm9vdC5hcHBlbmRDaGlsZChyZXBvcnQpO1xcblxcbiAgaWYgKHByb2dyZXNzKSB7XFxuICAgIHByb2dyZXNzLnNpemUoNDApO1xcbiAgfVxcblxcbiAgcnVubmVyLm9uKCdzdWl0ZScsIGZ1bmN0aW9uKHN1aXRlKSB7XFxuICAgIGlmIChzdWl0ZS5yb290KSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIC8vIHN1aXRlXFxuICAgIHZhciB1cmwgPSBzZWxmLnN1aXRlVVJMKHN1aXRlKTtcXG4gICAgdmFyIGVsID0gZnJhZ21lbnQoJzxsaSBjbGFzcz1cXFwic3VpdGVcXFwiPjxoMT48YSBocmVmPVxcXCIlc1xcXCI+JXM8L2E+PC9oMT48L2xpPicsIHVybCwgZXNjYXBlKHN1aXRlLnRpdGxlKSk7XFxuXFxuICAgIC8vIGNvbnRhaW5lclxcbiAgICBzdGFja1swXS5hcHBlbmRDaGlsZChlbCk7XFxuICAgIHN0YWNrLnVuc2hpZnQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKSk7XFxuICAgIGVsLmFwcGVuZENoaWxkKHN0YWNrWzBdKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdzdWl0ZSBlbmQnLCBmdW5jdGlvbihzdWl0ZSkge1xcbiAgICBpZiAoc3VpdGUucm9vdCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBzdGFjay5zaGlmdCgpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2ZhaWwnLCBmdW5jdGlvbih0ZXN0KSB7XFxuICAgIC8vIEZvciB0eXBlID0gJ3Rlc3QnIGl0cyBwb3NzaWJsZSB0aGF0IHRoZSB0ZXN0IGZhaWxlZCBkdWUgdG8gbXVsdGlwbGVcXG4gICAgLy8gZG9uZSgpIGNhbGxzLiBTbyByZXBvcnQgdGhlIGlzc3VlIGhlcmUuXFxuICAgIGlmICh0ZXN0LnR5cGUgPT09ICdob29rJ1xcbiAgICAgIHx8IHRlc3QudHlwZSA9PT0gJ3Rlc3QnKSB7XFxuICAgICAgcnVubmVyLmVtaXQoJ3Rlc3QgZW5kJywgdGVzdCk7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCd0ZXN0IGVuZCcsIGZ1bmN0aW9uKHRlc3QpIHtcXG4gICAgLy8gVE9ETzogYWRkIHRvIHN0YXRzXFxuICAgIHZhciBwZXJjZW50ID0gc3RhdHMudGVzdHMgLyB0aGlzLnRvdGFsICogMTAwIHwgMDtcXG4gICAgaWYgKHByb2dyZXNzKSB7XFxuICAgICAgcHJvZ3Jlc3MudXBkYXRlKHBlcmNlbnQpLmRyYXcoY3R4KTtcXG4gICAgfVxcblxcbiAgICAvLyB1cGRhdGUgc3RhdHNcXG4gICAgdmFyIG1zID0gbmV3IERhdGUoKSAtIHN0YXRzLnN0YXJ0O1xcbiAgICB0ZXh0KHBhc3Nlcywgc3RhdHMucGFzc2VzKTtcXG4gICAgdGV4dChmYWlsdXJlcywgc3RhdHMuZmFpbHVyZXMpO1xcbiAgICB0ZXh0KGR1cmF0aW9uLCAobXMgLyAxMDAwKS50b0ZpeGVkKDIpKTtcXG5cXG4gICAgLy8gdGVzdFxcbiAgICB2YXIgZWw7XFxuICAgIGlmICh0ZXN0LnN0YXRlID09PSAncGFzc2VkJykge1xcbiAgICAgIHZhciB1cmwgPSBzZWxmLnRlc3RVUkwodGVzdCk7XFxuICAgICAgZWwgPSBmcmFnbWVudCgnPGxpIGNsYXNzPVxcXCJ0ZXN0IHBhc3MgJWVcXFwiPjxoMj4lZTxzcGFuIGNsYXNzPVxcXCJkdXJhdGlvblxcXCI+JWVtczwvc3Bhbj4gPGEgaHJlZj1cXFwiJXNcXFwiIGNsYXNzPVxcXCJyZXBsYXlcXFwiPuKAozwvYT48L2gyPjwvbGk+JywgdGVzdC5zcGVlZCwgdGVzdC50aXRsZSwgdGVzdC5kdXJhdGlvbiwgdXJsKTtcXG4gICAgfSBlbHNlIGlmICh0ZXN0LnBlbmRpbmcpIHtcXG4gICAgICBlbCA9IGZyYWdtZW50KCc8bGkgY2xhc3M9XFxcInRlc3QgcGFzcyBwZW5kaW5nXFxcIj48aDI+JWU8L2gyPjwvbGk+JywgdGVzdC50aXRsZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZWwgPSBmcmFnbWVudCgnPGxpIGNsYXNzPVxcXCJ0ZXN0IGZhaWxcXFwiPjxoMj4lZSA8YSBocmVmPVxcXCIlZVxcXCIgY2xhc3M9XFxcInJlcGxheVxcXCI+4oCjPC9hPjwvaDI+PC9saT4nLCB0ZXN0LnRpdGxlLCBzZWxmLnRlc3RVUkwodGVzdCkpO1xcbiAgICAgIHZhciBzdGFja1N0cmluZzsgLy8gTm90ZTogSW5jbHVkZXMgbGVhZGluZyBuZXdsaW5lXFxuICAgICAgdmFyIG1lc3NhZ2UgPSB0ZXN0LmVyci50b1N0cmluZygpO1xcblxcbiAgICAgIC8vIDw9SUU3IHN0cmluZ2lmaWVzIHRvIFtPYmplY3QgRXJyb3JdLiBTaW5jZSBpdCBjYW4gYmUgb3ZlcmxvYWRlZCwgd2VcXG4gICAgICAvLyBjaGVjayBmb3IgdGhlIHJlc3VsdCBvZiB0aGUgc3RyaW5naWZ5aW5nLlxcbiAgICAgIGlmIChtZXNzYWdlID09PSAnW29iamVjdCBFcnJvcl0nKSB7XFxuICAgICAgICBtZXNzYWdlID0gdGVzdC5lcnIubWVzc2FnZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRlc3QuZXJyLnN0YWNrKSB7XFxuICAgICAgICB2YXIgaW5kZXhPZk1lc3NhZ2UgPSB0ZXN0LmVyci5zdGFjay5pbmRleE9mKHRlc3QuZXJyLm1lc3NhZ2UpO1xcbiAgICAgICAgaWYgKGluZGV4T2ZNZXNzYWdlID09PSAtMSkge1xcbiAgICAgICAgICBzdGFja1N0cmluZyA9IHRlc3QuZXJyLnN0YWNrO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgc3RhY2tTdHJpbmcgPSB0ZXN0LmVyci5zdGFjay5zdWJzdHIodGVzdC5lcnIubWVzc2FnZS5sZW5ndGggKyBpbmRleE9mTWVzc2FnZSk7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIGlmICh0ZXN0LmVyci5zb3VyY2VVUkwgJiYgdGVzdC5lcnIubGluZSAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAvLyBTYWZhcmkgZG9lc24ndCBnaXZlIHlvdSBhIHN0YWNrLiBMZXQncyBhdCBsZWFzdCBwcm92aWRlIGEgc291cmNlIGxpbmUuXFxuICAgICAgICBzdGFja1N0cmluZyA9ICdcXFxcbignICsgdGVzdC5lcnIuc291cmNlVVJMICsgJzonICsgdGVzdC5lcnIubGluZSArICcpJztcXG4gICAgICB9XFxuXFxuICAgICAgc3RhY2tTdHJpbmcgPSBzdGFja1N0cmluZyB8fCAnJztcXG5cXG4gICAgICBpZiAodGVzdC5lcnIuaHRtbE1lc3NhZ2UgJiYgc3RhY2tTdHJpbmcpIHtcXG4gICAgICAgIGVsLmFwcGVuZENoaWxkKGZyYWdtZW50KCc8ZGl2IGNsYXNzPVxcXCJodG1sLWVycm9yXFxcIj4lc1xcXFxuPHByZSBjbGFzcz1cXFwiZXJyb3JcXFwiPiVlPC9wcmU+PC9kaXY+JywgdGVzdC5lcnIuaHRtbE1lc3NhZ2UsIHN0YWNrU3RyaW5nKSk7XFxuICAgICAgfSBlbHNlIGlmICh0ZXN0LmVyci5odG1sTWVzc2FnZSkge1xcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQoZnJhZ21lbnQoJzxkaXYgY2xhc3M9XFxcImh0bWwtZXJyb3JcXFwiPiVzPC9kaXY+JywgdGVzdC5lcnIuaHRtbE1lc3NhZ2UpKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQoZnJhZ21lbnQoJzxwcmUgY2xhc3M9XFxcImVycm9yXFxcIj4lZSVlPC9wcmU+JywgbWVzc2FnZSwgc3RhY2tTdHJpbmcpKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgLy8gdG9nZ2xlIGNvZGVcXG4gICAgLy8gVE9ETzogZGVmZXJcXG4gICAgaWYgKCF0ZXN0LnBlbmRpbmcpIHtcXG4gICAgICB2YXIgaDIgPSBlbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaDInKVswXTtcXG5cXG4gICAgICBvbihoMiwgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XFxuICAgICAgICBwcmUuc3R5bGUuZGlzcGxheSA9IHByZS5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnYmxvY2snIDogJ25vbmUnO1xcbiAgICAgIH0pO1xcblxcbiAgICAgIHZhciBwcmUgPSBmcmFnbWVudCgnPHByZT48Y29kZT4lZTwvY29kZT48L3ByZT4nLCB1dGlscy5jbGVhbih0ZXN0LmJvZHkpKTtcXG4gICAgICBlbC5hcHBlbmRDaGlsZChwcmUpO1xcbiAgICAgIHByZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xcbiAgICB9XFxuXFxuICAgIC8vIERvbid0IGNhbGwgLmFwcGVuZENoaWxkIGlmICNtb2NoYS1yZXBvcnQgd2FzIGFscmVhZHkgLnNoaWZ0KCknZWQgb2ZmIHRoZSBzdGFjay5cXG4gICAgaWYgKHN0YWNrWzBdKSB7XFxuICAgICAgc3RhY2tbMF0uYXBwZW5kQ2hpbGQoZWwpO1xcbiAgICB9XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogTWFrZXMgYSBVUkwsIHByZXNlcnZpbmcgcXVlcnlzdHJpbmcgKFxcXCJzZWFyY2hcXFwiKSBwYXJhbWV0ZXJzLlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IHNcXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgbmV3IFVSTC5cXG4gKi9cXG5mdW5jdGlvbiBtYWtlVXJsKHMpIHtcXG4gIHZhciBzZWFyY2ggPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoO1xcblxcbiAgLy8gUmVtb3ZlIHByZXZpb3VzIGdyZXAgcXVlcnkgcGFyYW1ldGVyIGlmIHByZXNlbnRcXG4gIGlmIChzZWFyY2gpIHtcXG4gICAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoL1s/Jl1ncmVwPVteJlxcXFxzXSovZywgJycpLnJlcGxhY2UoL14mLywgJz8nKTtcXG4gIH1cXG5cXG4gIHJldHVybiB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyAoc2VhcmNoID8gc2VhcmNoICsgJyYnIDogJz8nKSArICdncmVwPScgKyBlbmNvZGVVUklDb21wb25lbnQoZXNjYXBlUmUocykpO1xcbn1cXG5cXG4vKipcXG4gKiBQcm92aWRlIHN1aXRlIFVSTC5cXG4gKlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3VpdGVdXFxuICovXFxuSFRNTC5wcm90b3R5cGUuc3VpdGVVUkwgPSBmdW5jdGlvbihzdWl0ZSkge1xcbiAgcmV0dXJuIG1ha2VVcmwoc3VpdGUuZnVsbFRpdGxlKCkpO1xcbn07XFxuXFxuLyoqXFxuICogUHJvdmlkZSB0ZXN0IFVSTC5cXG4gKlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbdGVzdF1cXG4gKi9cXG5IVE1MLnByb3RvdHlwZS50ZXN0VVJMID0gZnVuY3Rpb24odGVzdCkge1xcbiAgcmV0dXJuIG1ha2VVcmwodGVzdC5mdWxsVGl0bGUoKSk7XFxufTtcXG5cXG4vKipcXG4gKiBEaXNwbGF5IGVycm9yIGBtc2dgLlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IG1zZ1xcbiAqL1xcbmZ1bmN0aW9uIGVycm9yKG1zZykge1xcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmcmFnbWVudCgnPGRpdiBpZD1cXFwibW9jaGEtZXJyb3JcXFwiPiVzPC9kaXY+JywgbXNnKSk7XFxufVxcblxcbi8qKlxcbiAqIFJldHVybiBhIERPTSBmcmFnbWVudCBmcm9tIGBodG1sYC5cXG4gKlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXFxuICovXFxuZnVuY3Rpb24gZnJhZ21lbnQoaHRtbCkge1xcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XFxuICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XFxuICB2YXIgaSA9IDE7XFxuXFxuICBkaXYuaW5uZXJIVE1MID0gaHRtbC5yZXBsYWNlKC8lKFtzZV0pL2csIGZ1bmN0aW9uKF8sIHR5cGUpIHtcXG4gICAgc3dpdGNoICh0eXBlKSB7XFxuICAgICAgY2FzZSAncyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcXG4gICAgICBjYXNlICdlJzogcmV0dXJuIGVzY2FwZShhcmdzW2krK10pO1xcbiAgICAgIC8vIG5vIGRlZmF1bHRcXG4gICAgfVxcbiAgfSk7XFxuXFxuICByZXR1cm4gZGl2LmZpcnN0Q2hpbGQ7XFxufVxcblxcbi8qKlxcbiAqIENoZWNrIGZvciBzdWl0ZXMgdGhhdCBkbyBub3QgaGF2ZSBlbGVtZW50c1xcbiAqIHdpdGggYGNsYXNzbmFtZWAsIGFuZCBoaWRlIHRoZW0uXFxuICpcXG4gKiBAcGFyYW0ge3RleHR9IGNsYXNzbmFtZVxcbiAqL1xcbmZ1bmN0aW9uIGhpZGVTdWl0ZXNXaXRob3V0KGNsYXNzbmFtZSkge1xcbiAgdmFyIHN1aXRlcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3N1aXRlJyk7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN1aXRlcy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgZWxzID0gc3VpdGVzW2ldLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoY2xhc3NuYW1lKTtcXG4gICAgaWYgKCFlbHMubGVuZ3RoKSB7XFxuICAgICAgc3VpdGVzW2ldLmNsYXNzTmFtZSArPSAnIGhpZGRlbic7XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuLyoqXFxuICogVW5oaWRlIC5oaWRkZW4gc3VpdGVzLlxcbiAqL1xcbmZ1bmN0aW9uIHVuaGlkZSgpIHtcXG4gIHZhciBlbHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdzdWl0ZSBoaWRkZW4nKTtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxzLmxlbmd0aDsgKytpKSB7XFxuICAgIGVsc1tpXS5jbGFzc05hbWUgPSBlbHNbaV0uY2xhc3NOYW1lLnJlcGxhY2UoJ3N1aXRlIGhpZGRlbicsICdzdWl0ZScpO1xcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBTZXQgYW4gZWxlbWVudCdzIHRleHQgY29udGVudHMuXFxuICpcXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50c1xcbiAqL1xcbmZ1bmN0aW9uIHRleHQoZWwsIGNvbnRlbnRzKSB7XFxuICBpZiAoZWwudGV4dENvbnRlbnQpIHtcXG4gICAgZWwudGV4dENvbnRlbnQgPSBjb250ZW50cztcXG4gIH0gZWxzZSB7XFxuICAgIGVsLmlubmVyVGV4dCA9IGNvbnRlbnRzO1xcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBMaXN0ZW4gb24gYGV2ZW50YCB3aXRoIGNhbGxiYWNrIGBmbmAuXFxuICovXFxuZnVuY3Rpb24gb24oZWwsIGV2ZW50LCBmbikge1xcbiAgaWYgKGVsLmFkZEV2ZW50TGlzdGVuZXIpIHtcXG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZm4sIGZhbHNlKTtcXG4gIH0gZWxzZSB7XFxuICAgIGVsLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgZm4pO1xcbiAgfVxcbn1cXG5cXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSlcXG59LHtcXFwiLi4vYnJvd3Nlci9wcm9ncmVzc1xcXCI6NCxcXFwiLi4vdXRpbHNcXFwiOjM5LFxcXCIuL2Jhc2VcXFwiOjE3LFxcXCJlc2NhcGUtc3RyaW5nLXJlZ2V4cFxcXCI6Njh9XSwyMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLy8gQWxpYXMgZXhwb3J0cyB0byBhIHRoZWlyIG5vcm1hbGl6ZWQgZm9ybWF0IE1vY2hhI3JlcG9ydGVyIHRvIHByZXZlbnQgYSBuZWVkXFxuLy8gZm9yIGR5bmFtaWMgKHRyeS9jYXRjaCkgcmVxdWlyZXMsIHdoaWNoIEJyb3dzZXJpZnkgZG9lc24ndCBoYW5kbGUuXFxuZXhwb3J0cy5CYXNlID0gZXhwb3J0cy5iYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxuZXhwb3J0cy5Eb3QgPSBleHBvcnRzLmRvdCA9IHJlcXVpcmUoJy4vZG90Jyk7XFxuZXhwb3J0cy5Eb2MgPSBleHBvcnRzLmRvYyA9IHJlcXVpcmUoJy4vZG9jJyk7XFxuZXhwb3J0cy5UQVAgPSBleHBvcnRzLnRhcCA9IHJlcXVpcmUoJy4vdGFwJyk7XFxuZXhwb3J0cy5KU09OID0gZXhwb3J0cy5qc29uID0gcmVxdWlyZSgnLi9qc29uJyk7XFxuZXhwb3J0cy5IVE1MID0gZXhwb3J0cy5odG1sID0gcmVxdWlyZSgnLi9odG1sJyk7XFxuZXhwb3J0cy5MaXN0ID0gZXhwb3J0cy5saXN0ID0gcmVxdWlyZSgnLi9saXN0Jyk7XFxuZXhwb3J0cy5NaW4gPSBleHBvcnRzLm1pbiA9IHJlcXVpcmUoJy4vbWluJyk7XFxuZXhwb3J0cy5TcGVjID0gZXhwb3J0cy5zcGVjID0gcmVxdWlyZSgnLi9zcGVjJyk7XFxuZXhwb3J0cy5OeWFuID0gZXhwb3J0cy5ueWFuID0gcmVxdWlyZSgnLi9ueWFuJyk7XFxuZXhwb3J0cy5YVW5pdCA9IGV4cG9ydHMueHVuaXQgPSByZXF1aXJlKCcuL3h1bml0Jyk7XFxuZXhwb3J0cy5NYXJrZG93biA9IGV4cG9ydHMubWFya2Rvd24gPSByZXF1aXJlKCcuL21hcmtkb3duJyk7XFxuZXhwb3J0cy5Qcm9ncmVzcyA9IGV4cG9ydHMucHJvZ3Jlc3MgPSByZXF1aXJlKCcuL3Byb2dyZXNzJyk7XFxuZXhwb3J0cy5MYW5kaW5nID0gZXhwb3J0cy5sYW5kaW5nID0gcmVxdWlyZSgnLi9sYW5kaW5nJyk7XFxuZXhwb3J0cy5KU09OQ292ID0gZXhwb3J0c1snanNvbi1jb3YnXSA9IHJlcXVpcmUoJy4vanNvbi1jb3YnKTtcXG5leHBvcnRzLkhUTUxDb3YgPSBleHBvcnRzWydodG1sLWNvdiddID0gcmVxdWlyZSgnLi9odG1sLWNvdicpO1xcbmV4cG9ydHMuSlNPTlN0cmVhbSA9IGV4cG9ydHNbJ2pzb24tc3RyZWFtJ10gPSByZXF1aXJlKCcuL2pzb24tc3RyZWFtJyk7XFxuXFxufSx7XFxcIi4vYmFzZVxcXCI6MTcsXFxcIi4vZG9jXFxcIjoxOCxcXFwiLi9kb3RcXFwiOjE5LFxcXCIuL2h0bWxcXFwiOjIxLFxcXCIuL2h0bWwtY292XFxcIjoyMCxcXFwiLi9qc29uXFxcIjoyNSxcXFwiLi9qc29uLWNvdlxcXCI6MjMsXFxcIi4vanNvbi1zdHJlYW1cXFwiOjI0LFxcXCIuL2xhbmRpbmdcXFwiOjI2LFxcXCIuL2xpc3RcXFwiOjI3LFxcXCIuL21hcmtkb3duXFxcIjoyOCxcXFwiLi9taW5cXFwiOjI5LFxcXCIuL255YW5cXFwiOjMwLFxcXCIuL3Byb2dyZXNzXFxcIjozMSxcXFwiLi9zcGVjXFxcIjozMixcXFwiLi90YXBcXFwiOjMzLFxcXCIuL3h1bml0XFxcIjozNH1dLDIzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBKU09OQ292YC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBKU09OQ292O1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYEpzQ292ZXJhZ2VgIHJlcG9ydGVyLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICogQHBhcmFtIHtib29sZWFufSBvdXRwdXRcXG4gKi9cXG5mdW5jdGlvbiBKU09OQ292KHJ1bm5lciwgb3V0cHV0KSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIG91dHB1dCA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDEgfHwgb3V0cHV0O1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHRlc3RzID0gW107XFxuICB2YXIgZmFpbHVyZXMgPSBbXTtcXG4gIHZhciBwYXNzZXMgPSBbXTtcXG5cXG4gIHJ1bm5lci5vbigndGVzdCBlbmQnLCBmdW5jdGlvbih0ZXN0KSB7XFxuICAgIHRlc3RzLnB1c2godGVzdCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uKHRlc3QpIHtcXG4gICAgcGFzc2VzLnB1c2godGVzdCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZmFpbCcsIGZ1bmN0aW9uKHRlc3QpIHtcXG4gICAgZmFpbHVyZXMucHVzaCh0ZXN0KTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcXG4gICAgdmFyIGNvdiA9IGdsb2JhbC5fJGpzY292ZXJhZ2UgfHwge307XFxuICAgIHZhciByZXN1bHQgPSBzZWxmLmNvdiA9IG1hcChjb3YpO1xcbiAgICByZXN1bHQuc3RhdHMgPSBzZWxmLnN0YXRzO1xcbiAgICByZXN1bHQudGVzdHMgPSB0ZXN0cy5tYXAoY2xlYW4pO1xcbiAgICByZXN1bHQuZmFpbHVyZXMgPSBmYWlsdXJlcy5tYXAoY2xlYW4pO1xcbiAgICByZXN1bHQucGFzc2VzID0gcGFzc2VzLm1hcChjbGVhbik7XFxuICAgIGlmICghb3V0cHV0KSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKEpTT04uc3RyaW5naWZ5KHJlc3VsdCwgbnVsbCwgMikpO1xcbiAgfSk7XFxufVxcblxcbi8qKlxcbiAqIE1hcCBqc2NvdmVyYWdlIGRhdGEgdG8gYSBKU09OIHN0cnVjdHVyZVxcbiAqIHN1aXRhYmxlIGZvciByZXBvcnRpbmcuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge09iamVjdH0gY292XFxuICogQHJldHVybiB7T2JqZWN0fVxcbiAqL1xcblxcbmZ1bmN0aW9uIG1hcChjb3YpIHtcXG4gIHZhciByZXQgPSB7XFxuICAgIGluc3RydW1lbnRhdGlvbjogJ25vZGUtanNjb3ZlcmFnZScsXFxuICAgIHNsb2M6IDAsXFxuICAgIGhpdHM6IDAsXFxuICAgIG1pc3NlczogMCxcXG4gICAgY292ZXJhZ2U6IDAsXFxuICAgIGZpbGVzOiBbXVxcbiAgfTtcXG5cXG4gIGZvciAodmFyIGZpbGVuYW1lIGluIGNvdikge1xcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvdiwgZmlsZW5hbWUpKSB7XFxuICAgICAgdmFyIGRhdGEgPSBjb3ZlcmFnZShmaWxlbmFtZSwgY292W2ZpbGVuYW1lXSk7XFxuICAgICAgcmV0LmZpbGVzLnB1c2goZGF0YSk7XFxuICAgICAgcmV0LmhpdHMgKz0gZGF0YS5oaXRzO1xcbiAgICAgIHJldC5taXNzZXMgKz0gZGF0YS5taXNzZXM7XFxuICAgICAgcmV0LnNsb2MgKz0gZGF0YS5zbG9jO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXQuZmlsZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XFxuICAgIHJldHVybiBhLmZpbGVuYW1lLmxvY2FsZUNvbXBhcmUoYi5maWxlbmFtZSk7XFxuICB9KTtcXG5cXG4gIGlmIChyZXQuc2xvYyA+IDApIHtcXG4gICAgcmV0LmNvdmVyYWdlID0gKHJldC5oaXRzIC8gcmV0LnNsb2MpICogMTAwO1xcbiAgfVxcblxcbiAgcmV0dXJuIHJldDtcXG59XFxuXFxuLyoqXFxuICogTWFwIGpzY292ZXJhZ2UgZGF0YSBmb3IgYSBzaW5nbGUgc291cmNlIGZpbGVcXG4gKiB0byBhIEpTT04gc3RydWN0dXJlIHN1aXRhYmxlIGZvciByZXBvcnRpbmcuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZW5hbWUgbmFtZSBvZiB0aGUgc291cmNlIGZpbGVcXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSBqc2NvdmVyYWdlIGNvdmVyYWdlIGRhdGFcXG4gKiBAcmV0dXJuIHtPYmplY3R9XFxuICovXFxuZnVuY3Rpb24gY292ZXJhZ2UoZmlsZW5hbWUsIGRhdGEpIHtcXG4gIHZhciByZXQgPSB7XFxuICAgIGZpbGVuYW1lOiBmaWxlbmFtZSxcXG4gICAgY292ZXJhZ2U6IDAsXFxuICAgIGhpdHM6IDAsXFxuICAgIG1pc3NlczogMCxcXG4gICAgc2xvYzogMCxcXG4gICAgc291cmNlOiB7fVxcbiAgfTtcXG5cXG4gIGRhdGEuc291cmNlLmZvckVhY2goZnVuY3Rpb24obGluZSwgbnVtKSB7XFxuICAgIG51bSsrO1xcblxcbiAgICBpZiAoZGF0YVtudW1dID09PSAwKSB7XFxuICAgICAgcmV0Lm1pc3NlcysrO1xcbiAgICAgIHJldC5zbG9jKys7XFxuICAgIH0gZWxzZSBpZiAoZGF0YVtudW1dICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICByZXQuaGl0cysrO1xcbiAgICAgIHJldC5zbG9jKys7XFxuICAgIH1cXG5cXG4gICAgcmV0LnNvdXJjZVtudW1dID0ge1xcbiAgICAgIHNvdXJjZTogbGluZSxcXG4gICAgICBjb3ZlcmFnZTogZGF0YVtudW1dID09PSB1bmRlZmluZWQgPyAnJyA6IGRhdGFbbnVtXVxcbiAgICB9O1xcbiAgfSk7XFxuXFxuICByZXQuY292ZXJhZ2UgPSByZXQuaGl0cyAvIHJldC5zbG9jICogMTAwO1xcblxcbiAgcmV0dXJuIHJldDtcXG59XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgcGxhaW4tb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGB0ZXN0YFxcbiAqIGZyZWUgb2YgY3ljbGljIHByb3BlcnRpZXMgZXRjLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtPYmplY3R9IHRlc3RcXG4gKiBAcmV0dXJuIHtPYmplY3R9XFxuICovXFxuZnVuY3Rpb24gY2xlYW4odGVzdCkge1xcbiAgcmV0dXJuIHtcXG4gICAgZHVyYXRpb246IHRlc3QuZHVyYXRpb24sXFxuICAgIGN1cnJlbnRSZXRyeTogdGVzdC5jdXJyZW50UmV0cnkoKSxcXG4gICAgZnVsbFRpdGxlOiB0ZXN0LmZ1bGxUaXRsZSgpLFxcbiAgICB0aXRsZTogdGVzdC50aXRsZVxcbiAgfTtcXG59XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSlcXG59LHtcXFwiLi9iYXNlXFxcIjoxNyxcXFwiX3Byb2Nlc3NcXFwiOjUxfV0sMjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgTGlzdGAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gTGlzdDtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBMaXN0YCB0ZXN0IHJlcG9ydGVyLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gTGlzdChydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHRvdGFsID0gcnVubmVyLnRvdGFsO1xcblxcbiAgcnVubmVyLm9uKCdzdGFydCcsIGZ1bmN0aW9uKCkge1xcbiAgICBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShbJ3N0YXJ0JywgeyB0b3RhbDogdG90YWwgfV0pKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwYXNzJywgZnVuY3Rpb24odGVzdCkge1xcbiAgICBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShbJ3Bhc3MnLCBjbGVhbih0ZXN0KV0pKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdmYWlsJywgZnVuY3Rpb24odGVzdCwgZXJyKSB7XFxuICAgIHRlc3QgPSBjbGVhbih0ZXN0KTtcXG4gICAgdGVzdC5lcnIgPSBlcnIubWVzc2FnZTtcXG4gICAgdGVzdC5zdGFjayA9IGVyci5zdGFjayB8fCBudWxsO1xcbiAgICBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShbJ2ZhaWwnLCB0ZXN0XSkpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShKU09OLnN0cmluZ2lmeShbJ2VuZCcsIHNlbGYuc3RhdHNdKSk7XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgcGxhaW4tb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGB0ZXN0YFxcbiAqIGZyZWUgb2YgY3ljbGljIHByb3BlcnRpZXMgZXRjLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtPYmplY3R9IHRlc3RcXG4gKiBAcmV0dXJuIHtPYmplY3R9XFxuICovXFxuZnVuY3Rpb24gY2xlYW4odGVzdCkge1xcbiAgcmV0dXJuIHtcXG4gICAgdGl0bGU6IHRlc3QudGl0bGUsXFxuICAgIGZ1bGxUaXRsZTogdGVzdC5mdWxsVGl0bGUoKSxcXG4gICAgZHVyYXRpb246IHRlc3QuZHVyYXRpb24sXFxuICAgIGN1cnJlbnRSZXRyeTogdGVzdC5jdXJyZW50UmV0cnkoKVxcbiAgfTtcXG59XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIi4vYmFzZVxcXCI6MTcsXFxcIl9wcm9jZXNzXFxcIjo1MX1dLDI1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYEpTT05gLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEpTT05SZXBvcnRlcjtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBKU09OYCByZXBvcnRlci5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqL1xcbmZ1bmN0aW9uIEpTT05SZXBvcnRlcihydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHRlc3RzID0gW107XFxuICB2YXIgcGVuZGluZyA9IFtdO1xcbiAgdmFyIGZhaWx1cmVzID0gW107XFxuICB2YXIgcGFzc2VzID0gW107XFxuXFxuICBydW5uZXIub24oJ3Rlc3QgZW5kJywgZnVuY3Rpb24odGVzdCkge1xcbiAgICB0ZXN0cy5wdXNoKHRlc3QpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Bhc3MnLCBmdW5jdGlvbih0ZXN0KSB7XFxuICAgIHBhc3Nlcy5wdXNoKHRlc3QpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2ZhaWwnLCBmdW5jdGlvbih0ZXN0KSB7XFxuICAgIGZhaWx1cmVzLnB1c2godGVzdCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGVuZGluZycsIGZ1bmN0aW9uKHRlc3QpIHtcXG4gICAgcGVuZGluZy5wdXNoKHRlc3QpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgb2JqID0ge1xcbiAgICAgIHN0YXRzOiBzZWxmLnN0YXRzLFxcbiAgICAgIHRlc3RzOiB0ZXN0cy5tYXAoY2xlYW4pLFxcbiAgICAgIHBlbmRpbmc6IHBlbmRpbmcubWFwKGNsZWFuKSxcXG4gICAgICBmYWlsdXJlczogZmFpbHVyZXMubWFwKGNsZWFuKSxcXG4gICAgICBwYXNzZXM6IHBhc3Nlcy5tYXAoY2xlYW4pXFxuICAgIH07XFxuXFxuICAgIHJ1bm5lci50ZXN0UmVzdWx0cyA9IG9iajtcXG5cXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoSlNPTi5zdHJpbmdpZnkob2JqLCBudWxsLCAyKSk7XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgcGxhaW4tb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGB0ZXN0YFxcbiAqIGZyZWUgb2YgY3ljbGljIHByb3BlcnRpZXMgZXRjLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtPYmplY3R9IHRlc3RcXG4gKiBAcmV0dXJuIHtPYmplY3R9XFxuICovXFxuZnVuY3Rpb24gY2xlYW4odGVzdCkge1xcbiAgcmV0dXJuIHtcXG4gICAgdGl0bGU6IHRlc3QudGl0bGUsXFxuICAgIGZ1bGxUaXRsZTogdGVzdC5mdWxsVGl0bGUoKSxcXG4gICAgZHVyYXRpb246IHRlc3QuZHVyYXRpb24sXFxuICAgIGN1cnJlbnRSZXRyeTogdGVzdC5jdXJyZW50UmV0cnkoKSxcXG4gICAgZXJyOiBlcnJvckpTT04odGVzdC5lcnIgfHwge30pXFxuICB9O1xcbn1cXG5cXG4vKipcXG4gKiBUcmFuc2Zvcm0gYGVycm9yYCBpbnRvIGEgSlNPTiBvYmplY3QuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcXG4gKiBAcmV0dXJuIHtPYmplY3R9XFxuICovXFxuZnVuY3Rpb24gZXJyb3JKU09OKGVycikge1xcbiAgdmFyIHJlcyA9IHt9O1xcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZXJyKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xcbiAgICByZXNba2V5XSA9IGVycltrZXldO1xcbiAgfSwgZXJyKTtcXG4gIHJldHVybiByZXM7XFxufVxcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCIuL2Jhc2VcXFwiOjE3LFxcXCJfcHJvY2Vzc1xcXCI6NTF9XSwyNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5pbmhlcml0cztcXG52YXIgY3Vyc29yID0gQmFzZS5jdXJzb3I7XFxudmFyIGNvbG9yID0gQmFzZS5jb2xvcjtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYExhbmRpbmdgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IExhbmRpbmc7XFxuXFxuLyoqXFxuICogQWlycGxhbmUgY29sb3IuXFxuICovXFxuXFxuQmFzZS5jb2xvcnMucGxhbmUgPSAwO1xcblxcbi8qKlxcbiAqIEFpcnBsYW5lIGNyYXNoIGNvbG9yLlxcbiAqL1xcblxcbkJhc2UuY29sb3JzWydwbGFuZSBjcmFzaCddID0gMzE7XFxuXFxuLyoqXFxuICogUnVud2F5IGNvbG9yLlxcbiAqL1xcblxcbkJhc2UuY29sb3JzLnJ1bndheSA9IDkwO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYExhbmRpbmdgIHJlcG9ydGVyLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gTGFuZGluZyhydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHdpZHRoID0gQmFzZS53aW5kb3cud2lkdGggKiAuNzUgfCAwO1xcbiAgdmFyIHRvdGFsID0gcnVubmVyLnRvdGFsO1xcbiAgdmFyIHN0cmVhbSA9IHByb2Nlc3Muc3Rkb3V0O1xcbiAgdmFyIHBsYW5lID0gY29sb3IoJ3BsYW5lJywgJ+KciCcpO1xcbiAgdmFyIGNyYXNoZWQgPSAtMTtcXG4gIHZhciBuID0gMDtcXG5cXG4gIGZ1bmN0aW9uIHJ1bndheSgpIHtcXG4gICAgdmFyIGJ1ZiA9IEFycmF5KHdpZHRoKS5qb2luKCctJyk7XFxuICAgIHJldHVybiAnICAnICsgY29sb3IoJ3J1bndheScsIGJ1Zik7XFxuICB9XFxuXFxuICBydW5uZXIub24oJ3N0YXJ0JywgZnVuY3Rpb24oKSB7XFxuICAgIHN0cmVhbS53cml0ZSgnXFxcXG5cXFxcblxcXFxuICAnKTtcXG4gICAgY3Vyc29yLmhpZGUoKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCd0ZXN0IGVuZCcsIGZ1bmN0aW9uKHRlc3QpIHtcXG4gICAgLy8gY2hlY2sgaWYgdGhlIHBsYW5lIGNyYXNoZWRcXG4gICAgdmFyIGNvbCA9IGNyYXNoZWQgPT09IC0xID8gd2lkdGggKiArK24gLyB0b3RhbCB8IDAgOiBjcmFzaGVkO1xcblxcbiAgICAvLyBzaG93IHRoZSBjcmFzaFxcbiAgICBpZiAodGVzdC5zdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcXG4gICAgICBwbGFuZSA9IGNvbG9yKCdwbGFuZSBjcmFzaCcsICfinIgnKTtcXG4gICAgICBjcmFzaGVkID0gY29sO1xcbiAgICB9XFxuXFxuICAgIC8vIHJlbmRlciBsYW5kaW5nIHN0cmlwXFxuICAgIHN0cmVhbS53cml0ZSgnXFxcXHUwMDFiWycgKyAod2lkdGggKyAxKSArICdEXFxcXHUwMDFiWzJBJyk7XFxuICAgIHN0cmVhbS53cml0ZShydW53YXkoKSk7XFxuICAgIHN0cmVhbS53cml0ZSgnXFxcXG4gICcpO1xcbiAgICBzdHJlYW0ud3JpdGUoY29sb3IoJ3J1bndheScsIEFycmF5KGNvbCkuam9pbign4ouFJykpKTtcXG4gICAgc3RyZWFtLndyaXRlKHBsYW5lKTtcXG4gICAgc3RyZWFtLndyaXRlKGNvbG9yKCdydW53YXknLCBBcnJheSh3aWR0aCAtIGNvbCkuam9pbign4ouFJykgKyAnXFxcXG4nKSk7XFxuICAgIHN0cmVhbS53cml0ZShydW53YXkoKSk7XFxuICAgIHN0cmVhbS53cml0ZSgnXFxcXHUwMDFiWzBtJyk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZW5kJywgZnVuY3Rpb24oKSB7XFxuICAgIGN1cnNvci5zaG93KCk7XFxuICAgIGNvbnNvbGUubG9nKCk7XFxuICAgIHNlbGYuZXBpbG9ndWUoKTtcXG4gIH0pO1xcbn1cXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYEJhc2UucHJvdG90eXBlYC5cXG4gKi9cXG5pbmhlcml0cyhMYW5kaW5nLCBCYXNlKTtcXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiLi4vdXRpbHNcXFwiOjM5LFxcXCIuL2Jhc2VcXFwiOjE3LFxcXCJfcHJvY2Vzc1xcXCI6NTF9XSwyNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5pbmhlcml0cztcXG52YXIgY29sb3IgPSBCYXNlLmNvbG9yO1xcbnZhciBjdXJzb3IgPSBCYXNlLmN1cnNvcjtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYExpc3RgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IExpc3Q7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgTGlzdGAgdGVzdCByZXBvcnRlci5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqL1xcbmZ1bmN0aW9uIExpc3QocnVubmVyKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciBuID0gMDtcXG5cXG4gIHJ1bm5lci5vbignc3RhcnQnLCBmdW5jdGlvbigpIHtcXG4gICAgY29uc29sZS5sb2coKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCd0ZXN0JywgZnVuY3Rpb24odGVzdCkge1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShjb2xvcigncGFzcycsICcgICAgJyArIHRlc3QuZnVsbFRpdGxlKCkgKyAnOiAnKSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGVuZGluZycsIGZ1bmN0aW9uKHRlc3QpIHtcXG4gICAgdmFyIGZtdCA9IGNvbG9yKCdjaGVja21hcmsnLCAnICAtJylcXG4gICAgICArIGNvbG9yKCdwZW5kaW5nJywgJyAlcycpO1xcbiAgICBjb25zb2xlLmxvZyhmbXQsIHRlc3QuZnVsbFRpdGxlKCkpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Bhc3MnLCBmdW5jdGlvbih0ZXN0KSB7XFxuICAgIHZhciBmbXQgPSBjb2xvcignY2hlY2ttYXJrJywgJyAgJyArIEJhc2Uuc3ltYm9scy5kb3QpXFxuICAgICAgKyBjb2xvcigncGFzcycsICcgJXM6ICcpXFxuICAgICAgKyBjb2xvcih0ZXN0LnNwZWVkLCAnJWRtcycpO1xcbiAgICBjdXJzb3IuQ1IoKTtcXG4gICAgY29uc29sZS5sb2coZm10LCB0ZXN0LmZ1bGxUaXRsZSgpLCB0ZXN0LmR1cmF0aW9uKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdmYWlsJywgZnVuY3Rpb24odGVzdCkge1xcbiAgICBjdXJzb3IuQ1IoKTtcXG4gICAgY29uc29sZS5sb2coY29sb3IoJ2ZhaWwnLCAnICAlZCkgJXMnKSwgKytuLCB0ZXN0LmZ1bGxUaXRsZSgpKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdlbmQnLCBzZWxmLmVwaWxvZ3VlLmJpbmQoc2VsZikpO1xcbn1cXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYEJhc2UucHJvdG90eXBlYC5cXG4gKi9cXG5pbmhlcml0cyhMaXN0LCBCYXNlKTtcXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiLi4vdXRpbHNcXFwiOjM5LFxcXCIuL2Jhc2VcXFwiOjE3LFxcXCJfcHJvY2Vzc1xcXCI6NTF9XSwyODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcXG5cXG4vKipcXG4gKiBDb25zdGFudHNcXG4gKi9cXG5cXG52YXIgU1VJVEVfUFJFRklYID0gJyQnO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgTWFya2Rvd25gLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IE1hcmtkb3duO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYE1hcmtkb3duYCByZXBvcnRlci5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqL1xcbmZ1bmN0aW9uIE1hcmtkb3duKHJ1bm5lcikge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgbGV2ZWwgPSAwO1xcbiAgdmFyIGJ1ZiA9ICcnO1xcblxcbiAgZnVuY3Rpb24gdGl0bGUoc3RyKSB7XFxuICAgIHJldHVybiBBcnJheShsZXZlbCkuam9pbignIycpICsgJyAnICsgc3RyO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gbWFwVE9DKHN1aXRlLCBvYmopIHtcXG4gICAgdmFyIHJldCA9IG9iajtcXG4gICAgdmFyIGtleSA9IFNVSVRFX1BSRUZJWCArIHN1aXRlLnRpdGxlO1xcblxcbiAgICBvYmogPSBvYmpba2V5XSA9IG9ialtrZXldIHx8IHsgc3VpdGU6IHN1aXRlIH07XFxuICAgIHN1aXRlLnN1aXRlcy5mb3JFYWNoKGZ1bmN0aW9uKHN1aXRlKSB7XFxuICAgICAgbWFwVE9DKHN1aXRlLCBvYmopO1xcbiAgICB9KTtcXG5cXG4gICAgcmV0dXJuIHJldDtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeVRPQyhvYmosIGxldmVsKSB7XFxuICAgICsrbGV2ZWw7XFxuICAgIHZhciBidWYgPSAnJztcXG4gICAgdmFyIGxpbms7XFxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcXG4gICAgICBpZiAoa2V5ID09PSAnc3VpdGUnKSB7XFxuICAgICAgICBjb250aW51ZTtcXG4gICAgICB9XFxuICAgICAgaWYgKGtleSAhPT0gU1VJVEVfUFJFRklYKSB7XFxuICAgICAgICBsaW5rID0gJyAtIFsnICsga2V5LnN1YnN0cmluZygxKSArICddJztcXG4gICAgICAgIGxpbmsgKz0gJygjJyArIHV0aWxzLnNsdWcob2JqW2tleV0uc3VpdGUuZnVsbFRpdGxlKCkpICsgJylcXFxcbic7XFxuICAgICAgICBidWYgKz0gQXJyYXkobGV2ZWwpLmpvaW4oJyAgJykgKyBsaW5rO1xcbiAgICAgIH1cXG4gICAgICBidWYgKz0gc3RyaW5naWZ5VE9DKG9ialtrZXldLCBsZXZlbCk7XFxuICAgIH1cXG4gICAgcmV0dXJuIGJ1ZjtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGdlbmVyYXRlVE9DKHN1aXRlKSB7XFxuICAgIHZhciBvYmogPSBtYXBUT0Moc3VpdGUsIHt9KTtcXG4gICAgcmV0dXJuIHN0cmluZ2lmeVRPQyhvYmosIDApO1xcbiAgfVxcblxcbiAgZ2VuZXJhdGVUT0MocnVubmVyLnN1aXRlKTtcXG5cXG4gIHJ1bm5lci5vbignc3VpdGUnLCBmdW5jdGlvbihzdWl0ZSkge1xcbiAgICArK2xldmVsO1xcbiAgICB2YXIgc2x1ZyA9IHV0aWxzLnNsdWcoc3VpdGUuZnVsbFRpdGxlKCkpO1xcbiAgICBidWYgKz0gJzxhIG5hbWU9XFxcIicgKyBzbHVnICsgJ1xcXCI+PC9hPicgKyAnXFxcXG4nO1xcbiAgICBidWYgKz0gdGl0bGUoc3VpdGUudGl0bGUpICsgJ1xcXFxuJztcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdzdWl0ZSBlbmQnLCBmdW5jdGlvbigpIHtcXG4gICAgLS1sZXZlbDtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwYXNzJywgZnVuY3Rpb24odGVzdCkge1xcbiAgICB2YXIgY29kZSA9IHV0aWxzLmNsZWFuKHRlc3QuYm9keSk7XFxuICAgIGJ1ZiArPSB0ZXN0LnRpdGxlICsgJy5cXFxcbic7XFxuICAgIGJ1ZiArPSAnXFxcXG5gYGBqc1xcXFxuJztcXG4gICAgYnVmICs9IGNvZGUgKyAnXFxcXG4nO1xcbiAgICBidWYgKz0gJ2BgYFxcXFxuXFxcXG4nO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnIyBUT0NcXFxcbicpO1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShnZW5lcmF0ZVRPQyhydW5uZXIuc3VpdGUpKTtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoYnVmKTtcXG4gIH0pO1xcbn1cXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiLi4vdXRpbHNcXFwiOjM5LFxcXCIuL2Jhc2VcXFwiOjE3LFxcXCJfcHJvY2Vzc1xcXCI6NTF9XSwyOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5pbmhlcml0cztcXG5cXG4vKipcXG4gKiBFeHBvc2UgYE1pbmAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gTWluO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYE1pbmAgbWluaW1hbCB0ZXN0IHJlcG9ydGVyIChiZXN0IHVzZWQgd2l0aCAtLXdhdGNoKS5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqL1xcbmZ1bmN0aW9uIE1pbihydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgcnVubmVyLm9uKCdzdGFydCcsIGZ1bmN0aW9uKCkge1xcbiAgICAvLyBjbGVhciBzY3JlZW5cXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFx1MDAxYlsySicpO1xcbiAgICAvLyBzZXQgY3Vyc29yIHBvc2l0aW9uXFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXFxcdTAwMWJbMTszSCcpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2VuZCcsIHRoaXMuZXBpbG9ndWUuYmluZCh0aGlzKSk7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgQmFzZS5wcm90b3R5cGVgLlxcbiAqL1xcbmluaGVyaXRzKE1pbiwgQmFzZSk7XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIi4uL3V0aWxzXFxcIjozOSxcXFwiLi9iYXNlXFxcIjoxNyxcXFwiX3Byb2Nlc3NcXFwiOjUxfV0sMzA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4uL3V0aWxzJykuaW5oZXJpdHM7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBEb3RgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IE55YW5DYXQ7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRG90YCBtYXRyaXggdGVzdCByZXBvcnRlci5cXG4gKlxcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcblxcbmZ1bmN0aW9uIE55YW5DYXQocnVubmVyKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciB3aWR0aCA9IEJhc2Uud2luZG93LndpZHRoICogLjc1IHwgMDtcXG4gIHZhciBueWFuQ2F0V2lkdGggPSB0aGlzLm55YW5DYXRXaWR0aCA9IDExO1xcblxcbiAgdGhpcy5jb2xvckluZGV4ID0gMDtcXG4gIHRoaXMubnVtYmVyT2ZMaW5lcyA9IDQ7XFxuICB0aGlzLnJhaW5ib3dDb2xvcnMgPSBzZWxmLmdlbmVyYXRlQ29sb3JzKCk7XFxuICB0aGlzLnNjb3JlYm9hcmRXaWR0aCA9IDU7XFxuICB0aGlzLnRpY2sgPSAwO1xcbiAgdGhpcy50cmFqZWN0b3JpZXMgPSBbW10sIFtdLCBbXSwgW11dO1xcbiAgdGhpcy50cmFqZWN0b3J5V2lkdGhNYXggPSAod2lkdGggLSBueWFuQ2F0V2lkdGgpO1xcblxcbiAgcnVubmVyLm9uKCdzdGFydCcsIGZ1bmN0aW9uKCkge1xcbiAgICBCYXNlLmN1cnNvci5oaWRlKCk7XFxuICAgIHNlbGYuZHJhdygpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3BlbmRpbmcnLCBmdW5jdGlvbigpIHtcXG4gICAgc2VsZi5kcmF3KCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uKCkge1xcbiAgICBzZWxmLmRyYXcoKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdmYWlsJywgZnVuY3Rpb24oKSB7XFxuICAgIHNlbGYuZHJhdygpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xcbiAgICBCYXNlLmN1cnNvci5zaG93KCk7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5udW1iZXJPZkxpbmVzOyBpKyspIHtcXG4gICAgICB3cml0ZSgnXFxcXG4nKTtcXG4gICAgfVxcbiAgICBzZWxmLmVwaWxvZ3VlKCk7XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXFxuICovXFxuaW5oZXJpdHMoTnlhbkNhdCwgQmFzZSk7XFxuXFxuLyoqXFxuICogRHJhdyB0aGUgbnlhbiBjYXRcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblxcbk55YW5DYXQucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbigpIHtcXG4gIHRoaXMuYXBwZW5kUmFpbmJvdygpO1xcbiAgdGhpcy5kcmF3U2NvcmVib2FyZCgpO1xcbiAgdGhpcy5kcmF3UmFpbmJvdygpO1xcbiAgdGhpcy5kcmF3TnlhbkNhdCgpO1xcbiAgdGhpcy50aWNrID0gIXRoaXMudGljaztcXG59O1xcblxcbi8qKlxcbiAqIERyYXcgdGhlIFxcXCJzY29yZWJvYXJkXFxcIiBzaG93aW5nIHRoZSBudW1iZXJcXG4gKiBvZiBwYXNzZXMsIGZhaWx1cmVzIGFuZCBwZW5kaW5nIHRlc3RzLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuXFxuTnlhbkNhdC5wcm90b3R5cGUuZHJhd1Njb3JlYm9hcmQgPSBmdW5jdGlvbigpIHtcXG4gIHZhciBzdGF0cyA9IHRoaXMuc3RhdHM7XFxuXFxuICBmdW5jdGlvbiBkcmF3KHR5cGUsIG4pIHtcXG4gICAgd3JpdGUoJyAnKTtcXG4gICAgd3JpdGUoQmFzZS5jb2xvcih0eXBlLCBuKSk7XFxuICAgIHdyaXRlKCdcXFxcbicpO1xcbiAgfVxcblxcbiAgZHJhdygnZ3JlZW4nLCBzdGF0cy5wYXNzZXMpO1xcbiAgZHJhdygnZmFpbCcsIHN0YXRzLmZhaWx1cmVzKTtcXG4gIGRyYXcoJ3BlbmRpbmcnLCBzdGF0cy5wZW5kaW5nKTtcXG4gIHdyaXRlKCdcXFxcbicpO1xcblxcbiAgdGhpcy5jdXJzb3JVcCh0aGlzLm51bWJlck9mTGluZXMpO1xcbn07XFxuXFxuLyoqXFxuICogQXBwZW5kIHRoZSByYWluYm93LlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuXFxuTnlhbkNhdC5wcm90b3R5cGUuYXBwZW5kUmFpbmJvdyA9IGZ1bmN0aW9uKCkge1xcbiAgdmFyIHNlZ21lbnQgPSB0aGlzLnRpY2sgPyAnXycgOiAnLSc7XFxuICB2YXIgcmFpbmJvd2lmaWVkID0gdGhpcy5yYWluYm93aWZ5KHNlZ21lbnQpO1xcblxcbiAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMubnVtYmVyT2ZMaW5lczsgaW5kZXgrKykge1xcbiAgICB2YXIgdHJhamVjdG9yeSA9IHRoaXMudHJhamVjdG9yaWVzW2luZGV4XTtcXG4gICAgaWYgKHRyYWplY3RvcnkubGVuZ3RoID49IHRoaXMudHJhamVjdG9yeVdpZHRoTWF4KSB7XFxuICAgICAgdHJhamVjdG9yeS5zaGlmdCgpO1xcbiAgICB9XFxuICAgIHRyYWplY3RvcnkucHVzaChyYWluYm93aWZpZWQpO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogRHJhdyB0aGUgcmFpbmJvdy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblxcbk55YW5DYXQucHJvdG90eXBlLmRyYXdSYWluYm93ID0gZnVuY3Rpb24oKSB7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICB0aGlzLnRyYWplY3Rvcmllcy5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcXG4gICAgd3JpdGUoJ1xcXFx1MDAxYlsnICsgc2VsZi5zY29yZWJvYXJkV2lkdGggKyAnQycpO1xcbiAgICB3cml0ZShsaW5lLmpvaW4oJycpKTtcXG4gICAgd3JpdGUoJ1xcXFxuJyk7XFxuICB9KTtcXG5cXG4gIHRoaXMuY3Vyc29yVXAodGhpcy5udW1iZXJPZkxpbmVzKTtcXG59O1xcblxcbi8qKlxcbiAqIERyYXcgdGhlIG55YW4gY2F0XFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5OeWFuQ2F0LnByb3RvdHlwZS5kcmF3TnlhbkNhdCA9IGZ1bmN0aW9uKCkge1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHN0YXJ0V2lkdGggPSB0aGlzLnNjb3JlYm9hcmRXaWR0aCArIHRoaXMudHJhamVjdG9yaWVzWzBdLmxlbmd0aDtcXG4gIHZhciBkaXN0ID0gJ1xcXFx1MDAxYlsnICsgc3RhcnRXaWR0aCArICdDJztcXG4gIHZhciBwYWRkaW5nID0gJyc7XFxuXFxuICB3cml0ZShkaXN0KTtcXG4gIHdyaXRlKCdfLC0tLS0tLSwnKTtcXG4gIHdyaXRlKCdcXFxcbicpO1xcblxcbiAgd3JpdGUoZGlzdCk7XFxuICBwYWRkaW5nID0gc2VsZi50aWNrID8gJyAgJyA6ICcgICAnO1xcbiAgd3JpdGUoJ198JyArIHBhZGRpbmcgKyAnL1xcXFxcXFxcXy9cXFxcXFxcXCAnKTtcXG4gIHdyaXRlKCdcXFxcbicpO1xcblxcbiAgd3JpdGUoZGlzdCk7XFxuICBwYWRkaW5nID0gc2VsZi50aWNrID8gJ18nIDogJ19fJztcXG4gIHZhciB0YWlsID0gc2VsZi50aWNrID8gJ34nIDogJ14nO1xcbiAgd3JpdGUodGFpbCArICd8JyArIHBhZGRpbmcgKyB0aGlzLmZhY2UoKSArICcgJyk7XFxuICB3cml0ZSgnXFxcXG4nKTtcXG5cXG4gIHdyaXRlKGRpc3QpO1xcbiAgcGFkZGluZyA9IHNlbGYudGljayA/ICcgJyA6ICcgICc7XFxuICB3cml0ZShwYWRkaW5nICsgJ1xcXCJcXFwiICBcXFwiXFxcIiAnKTtcXG4gIHdyaXRlKCdcXFxcbicpO1xcblxcbiAgdGhpcy5jdXJzb3JVcCh0aGlzLm51bWJlck9mTGluZXMpO1xcbn07XFxuXFxuLyoqXFxuICogRHJhdyBueWFuIGNhdCBmYWNlLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcblxcbk55YW5DYXQucHJvdG90eXBlLmZhY2UgPSBmdW5jdGlvbigpIHtcXG4gIHZhciBzdGF0cyA9IHRoaXMuc3RhdHM7XFxuICBpZiAoc3RhdHMuZmFpbHVyZXMpIHtcXG4gICAgcmV0dXJuICcoIHggLngpJztcXG4gIH0gZWxzZSBpZiAoc3RhdHMucGVuZGluZykge1xcbiAgICByZXR1cm4gJyggbyAubyknO1xcbiAgfSBlbHNlIGlmIChzdGF0cy5wYXNzZXMpIHtcXG4gICAgcmV0dXJuICcoIF4gLl4pJztcXG4gIH1cXG4gIHJldHVybiAnKCAtIC4tKSc7XFxufTtcXG5cXG4vKipcXG4gKiBNb3ZlIGN1cnNvciB1cCBgbmAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gblxcbiAqL1xcblxcbk55YW5DYXQucHJvdG90eXBlLmN1cnNvclVwID0gZnVuY3Rpb24obikge1xcbiAgd3JpdGUoJ1xcXFx1MDAxYlsnICsgbiArICdBJyk7XFxufTtcXG5cXG4vKipcXG4gKiBNb3ZlIGN1cnNvciBkb3duIGBuYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXFxuICovXFxuXFxuTnlhbkNhdC5wcm90b3R5cGUuY3Vyc29yRG93biA9IGZ1bmN0aW9uKG4pIHtcXG4gIHdyaXRlKCdcXFxcdTAwMWJbJyArIG4gKyAnQicpO1xcbn07XFxuXFxuLyoqXFxuICogR2VuZXJhdGUgcmFpbmJvdyBjb2xvcnMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcmV0dXJuIHtBcnJheX1cXG4gKi9cXG5OeWFuQ2F0LnByb3RvdHlwZS5nZW5lcmF0ZUNvbG9ycyA9IGZ1bmN0aW9uKCkge1xcbiAgdmFyIGNvbG9ycyA9IFtdO1xcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAoNiAqIDcpOyBpKyspIHtcXG4gICAgdmFyIHBpMyA9IE1hdGguZmxvb3IoTWF0aC5QSSAvIDMpO1xcbiAgICB2YXIgbiA9IChpICogKDEuMCAvIDYpKTtcXG4gICAgdmFyIHIgPSBNYXRoLmZsb29yKDMgKiBNYXRoLnNpbihuKSArIDMpO1xcbiAgICB2YXIgZyA9IE1hdGguZmxvb3IoMyAqIE1hdGguc2luKG4gKyAyICogcGkzKSArIDMpO1xcbiAgICB2YXIgYiA9IE1hdGguZmxvb3IoMyAqIE1hdGguc2luKG4gKyA0ICogcGkzKSArIDMpO1xcbiAgICBjb2xvcnMucHVzaCgzNiAqIHIgKyA2ICogZyArIGIgKyAxNik7XFxuICB9XFxuXFxuICByZXR1cm4gY29sb3JzO1xcbn07XFxuXFxuLyoqXFxuICogQXBwbHkgcmFpbmJvdyB0byB0aGUgZ2l2ZW4gYHN0cmAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbk55YW5DYXQucHJvdG90eXBlLnJhaW5ib3dpZnkgPSBmdW5jdGlvbihzdHIpIHtcXG4gIGlmICghQmFzZS51c2VDb2xvcnMpIHtcXG4gICAgcmV0dXJuIHN0cjtcXG4gIH1cXG4gIHZhciBjb2xvciA9IHRoaXMucmFpbmJvd0NvbG9yc1t0aGlzLmNvbG9ySW5kZXggJSB0aGlzLnJhaW5ib3dDb2xvcnMubGVuZ3RoXTtcXG4gIHRoaXMuY29sb3JJbmRleCArPSAxO1xcbiAgcmV0dXJuICdcXFxcdTAwMWJbMzg7NTsnICsgY29sb3IgKyAnbScgKyBzdHIgKyAnXFxcXHUwMDFiWzBtJztcXG59O1xcblxcbi8qKlxcbiAqIFN0ZG91dCBoZWxwZXIuXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIEEgbWVzc2FnZSB0byB3cml0ZSB0byBzdGRvdXQuXFxuICovXFxuZnVuY3Rpb24gd3JpdGUoc3RyaW5nKSB7XFxuICBwcm9jZXNzLnN0ZG91dC53cml0ZShzdHJpbmcpO1xcbn1cXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiLi4vdXRpbHNcXFwiOjM5LFxcXCIuL2Jhc2VcXFwiOjE3LFxcXCJfcHJvY2Vzc1xcXCI6NTF9XSwzMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5pbmhlcml0cztcXG52YXIgY29sb3IgPSBCYXNlLmNvbG9yO1xcbnZhciBjdXJzb3IgPSBCYXNlLmN1cnNvcjtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYFByb2dyZXNzYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBQcm9ncmVzcztcXG5cXG4vKipcXG4gKiBHZW5lcmFsIHByb2dyZXNzIGJhciBjb2xvci5cXG4gKi9cXG5cXG5CYXNlLmNvbG9ycy5wcm9ncmVzcyA9IDkwO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYFByb2dyZXNzYCBiYXIgdGVzdCByZXBvcnRlci5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXFxuICovXFxuZnVuY3Rpb24gUHJvZ3Jlc3MocnVubmVyLCBvcHRpb25zKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciB3aWR0aCA9IEJhc2Uud2luZG93LndpZHRoICogLjUwIHwgMDtcXG4gIHZhciB0b3RhbCA9IHJ1bm5lci50b3RhbDtcXG4gIHZhciBjb21wbGV0ZSA9IDA7XFxuICB2YXIgbGFzdE4gPSAtMTtcXG5cXG4gIC8vIGRlZmF1bHQgY2hhcnNcXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcbiAgb3B0aW9ucy5vcGVuID0gb3B0aW9ucy5vcGVuIHx8ICdbJztcXG4gIG9wdGlvbnMuY29tcGxldGUgPSBvcHRpb25zLmNvbXBsZXRlIHx8ICfilqwnO1xcbiAgb3B0aW9ucy5pbmNvbXBsZXRlID0gb3B0aW9ucy5pbmNvbXBsZXRlIHx8IEJhc2Uuc3ltYm9scy5kb3Q7XFxuICBvcHRpb25zLmNsb3NlID0gb3B0aW9ucy5jbG9zZSB8fCAnXSc7XFxuICBvcHRpb25zLnZlcmJvc2UgPSBmYWxzZTtcXG5cXG4gIC8vIHRlc3RzIHN0YXJ0ZWRcXG4gIHJ1bm5lci5vbignc3RhcnQnLCBmdW5jdGlvbigpIHtcXG4gICAgY29uc29sZS5sb2coKTtcXG4gICAgY3Vyc29yLmhpZGUoKTtcXG4gIH0pO1xcblxcbiAgLy8gdGVzdHMgY29tcGxldGVcXG4gIHJ1bm5lci5vbigndGVzdCBlbmQnLCBmdW5jdGlvbigpIHtcXG4gICAgY29tcGxldGUrKztcXG5cXG4gICAgdmFyIHBlcmNlbnQgPSBjb21wbGV0ZSAvIHRvdGFsO1xcbiAgICB2YXIgbiA9IHdpZHRoICogcGVyY2VudCB8IDA7XFxuICAgIHZhciBpID0gd2lkdGggLSBuO1xcblxcbiAgICBpZiAobiA9PT0gbGFzdE4gJiYgIW9wdGlvbnMudmVyYm9zZSkge1xcbiAgICAgIC8vIERvbid0IHJlLXJlbmRlciB0aGUgbGluZSBpZiBpdCBoYXNuJ3QgY2hhbmdlZFxcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBsYXN0TiA9IG47XFxuXFxuICAgIGN1cnNvci5DUigpO1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxcXHUwMDFiW0onKTtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IoJ3Byb2dyZXNzJywgJyAgJyArIG9wdGlvbnMub3BlbikpO1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShBcnJheShuKS5qb2luKG9wdGlvbnMuY29tcGxldGUpKTtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoQXJyYXkoaSkuam9pbihvcHRpb25zLmluY29tcGxldGUpKTtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IoJ3Byb2dyZXNzJywgb3B0aW9ucy5jbG9zZSkpO1xcbiAgICBpZiAob3B0aW9ucy52ZXJib3NlKSB7XFxuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IoJ3Byb2dyZXNzJywgJyAnICsgY29tcGxldGUgKyAnIG9mICcgKyB0b3RhbCkpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIHRlc3RzIGFyZSBjb21wbGV0ZSwgb3V0cHV0IHNvbWUgc3RhdHNcXG4gIC8vIGFuZCB0aGUgZmFpbHVyZXMgaWYgYW55XFxuICBydW5uZXIub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xcbiAgICBjdXJzb3Iuc2hvdygpO1xcbiAgICBjb25zb2xlLmxvZygpO1xcbiAgICBzZWxmLmVwaWxvZ3VlKCk7XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXFxuICovXFxuaW5oZXJpdHMoUHJvZ3Jlc3MsIEJhc2UpO1xcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCIuLi91dGlsc1xcXCI6MzksXFxcIi4vYmFzZVxcXCI6MTcsXFxcIl9wcm9jZXNzXFxcIjo1MX1dLDMyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5pbmhlcml0cztcXG52YXIgY29sb3IgPSBCYXNlLmNvbG9yO1xcbnZhciBjdXJzb3IgPSBCYXNlLmN1cnNvcjtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYFNwZWNgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFNwZWM7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgU3BlY2AgdGVzdCByZXBvcnRlci5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqL1xcbmZ1bmN0aW9uIFNwZWMocnVubmVyKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciBpbmRlbnRzID0gMDtcXG4gIHZhciBuID0gMDtcXG5cXG4gIGZ1bmN0aW9uIGluZGVudCgpIHtcXG4gICAgcmV0dXJuIEFycmF5KGluZGVudHMpLmpvaW4oJyAgJyk7XFxuICB9XFxuXFxuICBydW5uZXIub24oJ3N0YXJ0JywgZnVuY3Rpb24oKSB7XFxuICAgIGNvbnNvbGUubG9nKCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignc3VpdGUnLCBmdW5jdGlvbihzdWl0ZSkge1xcbiAgICArK2luZGVudHM7XFxuICAgIGNvbnNvbGUubG9nKGNvbG9yKCdzdWl0ZScsICclcyVzJyksIGluZGVudCgpLCBzdWl0ZS50aXRsZSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignc3VpdGUgZW5kJywgZnVuY3Rpb24oKSB7XFxuICAgIC0taW5kZW50cztcXG4gICAgaWYgKGluZGVudHMgPT09IDEpIHtcXG4gICAgICBjb25zb2xlLmxvZygpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGVuZGluZycsIGZ1bmN0aW9uKHRlc3QpIHtcXG4gICAgdmFyIGZtdCA9IGluZGVudCgpICsgY29sb3IoJ3BlbmRpbmcnLCAnICAtICVzJyk7XFxuICAgIGNvbnNvbGUubG9nKGZtdCwgdGVzdC50aXRsZSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uKHRlc3QpIHtcXG4gICAgdmFyIGZtdDtcXG4gICAgaWYgKHRlc3Quc3BlZWQgPT09ICdmYXN0Jykge1xcbiAgICAgIGZtdCA9IGluZGVudCgpXFxuICAgICAgICArIGNvbG9yKCdjaGVja21hcmsnLCAnICAnICsgQmFzZS5zeW1ib2xzLm9rKVxcbiAgICAgICAgKyBjb2xvcigncGFzcycsICcgJXMnKTtcXG4gICAgICBjdXJzb3IuQ1IoKTtcXG4gICAgICBjb25zb2xlLmxvZyhmbXQsIHRlc3QudGl0bGUpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGZtdCA9IGluZGVudCgpXFxuICAgICAgICArIGNvbG9yKCdjaGVja21hcmsnLCAnICAnICsgQmFzZS5zeW1ib2xzLm9rKVxcbiAgICAgICAgKyBjb2xvcigncGFzcycsICcgJXMnKVxcbiAgICAgICAgKyBjb2xvcih0ZXN0LnNwZWVkLCAnICglZG1zKScpO1xcbiAgICAgIGN1cnNvci5DUigpO1xcbiAgICAgIGNvbnNvbGUubG9nKGZtdCwgdGVzdC50aXRsZSwgdGVzdC5kdXJhdGlvbik7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdmYWlsJywgZnVuY3Rpb24odGVzdCkge1xcbiAgICBjdXJzb3IuQ1IoKTtcXG4gICAgY29uc29sZS5sb2coaW5kZW50KCkgKyBjb2xvcignZmFpbCcsICcgICVkKSAlcycpLCArK24sIHRlc3QudGl0bGUpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2VuZCcsIHNlbGYuZXBpbG9ndWUuYmluZChzZWxmKSk7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgQmFzZS5wcm90b3R5cGVgLlxcbiAqL1xcbmluaGVyaXRzKFNwZWMsIEJhc2UpO1xcblxcbn0se1xcXCIuLi91dGlsc1xcXCI6MzksXFxcIi4vYmFzZVxcXCI6MTd9XSwzMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgVEFQYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBUQVA7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgVEFQYCByZXBvcnRlci5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqL1xcbmZ1bmN0aW9uIFRBUChydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIG4gPSAxO1xcbiAgdmFyIHBhc3NlcyA9IDA7XFxuICB2YXIgZmFpbHVyZXMgPSAwO1xcblxcbiAgcnVubmVyLm9uKCdzdGFydCcsIGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgdG90YWwgPSBydW5uZXIuZ3JlcFRvdGFsKHJ1bm5lci5zdWl0ZSk7XFxuICAgIGNvbnNvbGUubG9nKCclZC4uJWQnLCAxLCB0b3RhbCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigndGVzdCBlbmQnLCBmdW5jdGlvbigpIHtcXG4gICAgKytuO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3BlbmRpbmcnLCBmdW5jdGlvbih0ZXN0KSB7XFxuICAgIGNvbnNvbGUubG9nKCdvayAlZCAlcyAjIFNLSVAgLScsIG4sIHRpdGxlKHRlc3QpKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwYXNzJywgZnVuY3Rpb24odGVzdCkge1xcbiAgICBwYXNzZXMrKztcXG4gICAgY29uc29sZS5sb2coJ29rICVkICVzJywgbiwgdGl0bGUodGVzdCkpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2ZhaWwnLCBmdW5jdGlvbih0ZXN0LCBlcnIpIHtcXG4gICAgZmFpbHVyZXMrKztcXG4gICAgY29uc29sZS5sb2coJ25vdCBvayAlZCAlcycsIG4sIHRpdGxlKHRlc3QpKTtcXG4gICAgaWYgKGVyci5zdGFjaykge1xcbiAgICAgIGNvbnNvbGUubG9nKGVyci5zdGFjay5yZXBsYWNlKC9eL2dtLCAnICAnKSk7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcXG4gICAgY29uc29sZS5sb2coJyMgdGVzdHMgJyArIChwYXNzZXMgKyBmYWlsdXJlcykpO1xcbiAgICBjb25zb2xlLmxvZygnIyBwYXNzICcgKyBwYXNzZXMpO1xcbiAgICBjb25zb2xlLmxvZygnIyBmYWlsICcgKyBmYWlsdXJlcyk7XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgVEFQLXNhZmUgdGl0bGUgb2YgYHRlc3RgXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge09iamVjdH0gdGVzdFxcbiAqIEByZXR1cm4ge1N0cmluZ31cXG4gKi9cXG5mdW5jdGlvbiB0aXRsZSh0ZXN0KSB7XFxuICByZXR1cm4gdGVzdC5mdWxsVGl0bGUoKS5yZXBsYWNlKC8jL2csICcnKTtcXG59XFxuXFxufSx7XFxcIi4vYmFzZVxcXCI6MTd9XSwzNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XFxudmFyIGluaGVyaXRzID0gdXRpbHMuaW5oZXJpdHM7XFxudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcXG52YXIgZXNjYXBlID0gdXRpbHMuZXNjYXBlO1xcbnZhciBta2RpcnAgPSByZXF1aXJlKCdta2RpcnAnKTtcXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcXG5cXG4vKipcXG4gKiBTYXZlIHRpbWVyIHJlZmVyZW5jZXMgdG8gYXZvaWQgU2lub24gaW50ZXJmZXJpbmcgKHNlZSBHSC0yMzcpLlxcbiAqL1xcblxcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzLCBuby1uYXRpdmUtcmVhc3NpZ24gKi9cXG52YXIgRGF0ZSA9IGdsb2JhbC5EYXRlO1xcbnZhciBzZXRUaW1lb3V0ID0gZ2xvYmFsLnNldFRpbWVvdXQ7XFxudmFyIHNldEludGVydmFsID0gZ2xvYmFsLnNldEludGVydmFsO1xcbnZhciBjbGVhclRpbWVvdXQgPSBnbG9iYWwuY2xlYXJUaW1lb3V0O1xcbnZhciBjbGVhckludGVydmFsID0gZ2xvYmFsLmNsZWFySW50ZXJ2YWw7XFxuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycywgbm8tbmF0aXZlLXJlYXNzaWduICovXFxuXFxuLyoqXFxuICogRXhwb3NlIGBYVW5pdGAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gWFVuaXQ7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgWFVuaXRgIHJlcG9ydGVyLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gWFVuaXQocnVubmVyLCBvcHRpb25zKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHZhciBzdGF0cyA9IHRoaXMuc3RhdHM7XFxuICB2YXIgdGVzdHMgPSBbXTtcXG4gIHZhciBzZWxmID0gdGhpcztcXG5cXG4gIGlmIChvcHRpb25zLnJlcG9ydGVyT3B0aW9ucyAmJiBvcHRpb25zLnJlcG9ydGVyT3B0aW9ucy5vdXRwdXQpIHtcXG4gICAgaWYgKCFmcy5jcmVhdGVXcml0ZVN0cmVhbSkge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmlsZSBvdXRwdXQgbm90IHN1cHBvcnRlZCBpbiBicm93c2VyJyk7XFxuICAgIH1cXG4gICAgbWtkaXJwLnN5bmMocGF0aC5kaXJuYW1lKG9wdGlvbnMucmVwb3J0ZXJPcHRpb25zLm91dHB1dCkpO1xcbiAgICBzZWxmLmZpbGVTdHJlYW0gPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShvcHRpb25zLnJlcG9ydGVyT3B0aW9ucy5vdXRwdXQpO1xcbiAgfVxcblxcbiAgcnVubmVyLm9uKCdwZW5kaW5nJywgZnVuY3Rpb24odGVzdCkge1xcbiAgICB0ZXN0cy5wdXNoKHRlc3QpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Bhc3MnLCBmdW5jdGlvbih0ZXN0KSB7XFxuICAgIHRlc3RzLnB1c2godGVzdCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZmFpbCcsIGZ1bmN0aW9uKHRlc3QpIHtcXG4gICAgdGVzdHMucHVzaCh0ZXN0KTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcXG4gICAgc2VsZi53cml0ZSh0YWcoJ3Rlc3RzdWl0ZScsIHtcXG4gICAgICBuYW1lOiAnTW9jaGEgVGVzdHMnLFxcbiAgICAgIHRlc3RzOiBzdGF0cy50ZXN0cyxcXG4gICAgICBmYWlsdXJlczogc3RhdHMuZmFpbHVyZXMsXFxuICAgICAgZXJyb3JzOiBzdGF0cy5mYWlsdXJlcyxcXG4gICAgICBza2lwcGVkOiBzdGF0cy50ZXN0cyAtIHN0YXRzLmZhaWx1cmVzIC0gc3RhdHMucGFzc2VzLFxcbiAgICAgIHRpbWVzdGFtcDogKG5ldyBEYXRlKCkpLnRvVVRDU3RyaW5nKCksXFxuICAgICAgdGltZTogKHN0YXRzLmR1cmF0aW9uIC8gMTAwMCkgfHwgMFxcbiAgICB9LCBmYWxzZSkpO1xcblxcbiAgICB0ZXN0cy5mb3JFYWNoKGZ1bmN0aW9uKHQpIHtcXG4gICAgICBzZWxmLnRlc3QodCk7XFxuICAgIH0pO1xcblxcbiAgICBzZWxmLndyaXRlKCc8L3Rlc3RzdWl0ZT4nKTtcXG4gIH0pO1xcbn1cXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYEJhc2UucHJvdG90eXBlYC5cXG4gKi9cXG5pbmhlcml0cyhYVW5pdCwgQmFzZSk7XFxuXFxuLyoqXFxuICogT3ZlcnJpZGUgZG9uZSB0byBjbG9zZSB0aGUgc3RyZWFtIChpZiBpdCdzIGEgZmlsZSkuXFxuICpcXG4gKiBAcGFyYW0gZmFpbHVyZXNcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqL1xcblhVbml0LnByb3RvdHlwZS5kb25lID0gZnVuY3Rpb24oZmFpbHVyZXMsIGZuKSB7XFxuICBpZiAodGhpcy5maWxlU3RyZWFtKSB7XFxuICAgIHRoaXMuZmlsZVN0cmVhbS5lbmQoZnVuY3Rpb24oKSB7XFxuICAgICAgZm4oZmFpbHVyZXMpO1xcbiAgICB9KTtcXG4gIH0gZWxzZSB7XFxuICAgIGZuKGZhaWx1cmVzKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIFdyaXRlIG91dCB0aGUgZ2l2ZW4gbGluZS5cXG4gKlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBsaW5lXFxuICovXFxuWFVuaXQucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24obGluZSkge1xcbiAgaWYgKHRoaXMuZmlsZVN0cmVhbSkge1xcbiAgICB0aGlzLmZpbGVTdHJlYW0ud3JpdGUobGluZSArICdcXFxcbicpO1xcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgcHJvY2Vzcy5zdGRvdXQpIHtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUobGluZSArICdcXFxcbicpO1xcbiAgfSBlbHNlIHtcXG4gICAgY29uc29sZS5sb2cobGluZSk7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBPdXRwdXQgdGFnIGZvciB0aGUgZ2l2ZW4gYHRlc3QuYFxcbiAqXFxuICogQHBhcmFtIHtUZXN0fSB0ZXN0XFxuICovXFxuWFVuaXQucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbih0ZXN0KSB7XFxuICB2YXIgYXR0cnMgPSB7XFxuICAgIGNsYXNzbmFtZTogdGVzdC5wYXJlbnQuZnVsbFRpdGxlKCksXFxuICAgIG5hbWU6IHRlc3QudGl0bGUsXFxuICAgIHRpbWU6ICh0ZXN0LmR1cmF0aW9uIC8gMTAwMCkgfHwgMFxcbiAgfTtcXG5cXG4gIGlmICh0ZXN0LnN0YXRlID09PSAnZmFpbGVkJykge1xcbiAgICB2YXIgZXJyID0gdGVzdC5lcnI7XFxuICAgIHRoaXMud3JpdGUodGFnKCd0ZXN0Y2FzZScsIGF0dHJzLCBmYWxzZSwgdGFnKCdmYWlsdXJlJywge30sIGZhbHNlLCBjZGF0YShlc2NhcGUoZXJyLm1lc3NhZ2UpICsgJ1xcXFxuJyArIGVyci5zdGFjaykpKSk7XFxuICB9IGVsc2UgaWYgKHRlc3QucGVuZGluZykge1xcbiAgICB0aGlzLndyaXRlKHRhZygndGVzdGNhc2UnLCBhdHRycywgZmFsc2UsIHRhZygnc2tpcHBlZCcsIHt9LCB0cnVlKSkpO1xcbiAgfSBlbHNlIHtcXG4gICAgdGhpcy53cml0ZSh0YWcoJ3Rlc3RjYXNlJywgYXR0cnMsIHRydWUpKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIEhUTUwgdGFnIGhlbHBlci5cXG4gKlxcbiAqIEBwYXJhbSBuYW1lXFxuICogQHBhcmFtIGF0dHJzXFxuICogQHBhcmFtIGNsb3NlXFxuICogQHBhcmFtIGNvbnRlbnRcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZnVuY3Rpb24gdGFnKG5hbWUsIGF0dHJzLCBjbG9zZSwgY29udGVudCkge1xcbiAgdmFyIGVuZCA9IGNsb3NlID8gJy8+JyA6ICc+JztcXG4gIHZhciBwYWlycyA9IFtdO1xcbiAgdmFyIHRhZztcXG5cXG4gIGZvciAodmFyIGtleSBpbiBhdHRycykge1xcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzLCBrZXkpKSB7XFxuICAgICAgcGFpcnMucHVzaChrZXkgKyAnPVxcXCInICsgZXNjYXBlKGF0dHJzW2tleV0pICsgJ1xcXCInKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgdGFnID0gJzwnICsgbmFtZSArIChwYWlycy5sZW5ndGggPyAnICcgKyBwYWlycy5qb2luKCcgJykgOiAnJykgKyBlbmQ7XFxuICBpZiAoY29udGVudCkge1xcbiAgICB0YWcgKz0gY29udGVudCArICc8LycgKyBuYW1lICsgZW5kO1xcbiAgfVxcbiAgcmV0dXJuIHRhZztcXG59XFxuXFxuLyoqXFxuICogUmV0dXJuIGNkYXRhIGVzY2FwZWQgQ0RBVEEgYHN0cmAuXFxuICovXFxuXFxuZnVuY3Rpb24gY2RhdGEoc3RyKSB7XFxuICByZXR1cm4gJzwhW0NEQVRBWycgKyBlc2NhcGUoc3RyKSArICddXT4nO1xcbn1cXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHdpbmRvdyA6IHt9KVxcbn0se1xcXCIuLi91dGlsc1xcXCI6MzksXFxcIi4vYmFzZVxcXCI6MTcsXFxcIl9wcm9jZXNzXFxcIjo1MSxcXFwiZnNcXFwiOjQxLFxcXCJta2RpcnBcXFwiOjcwLFxcXCJwYXRoXFxcIjo0MX1dLDM1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKGdsb2JhbCl7XFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xcbnZhciBQZW5kaW5nID0gcmVxdWlyZSgnLi9wZW5kaW5nJyk7XFxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbW9jaGE6cnVubmFibGUnKTtcXG52YXIgbWlsbGlzZWNvbmRzID0gcmVxdWlyZSgnLi9tcycpO1xcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcXG52YXIgaW5oZXJpdHMgPSB1dGlscy5pbmhlcml0cztcXG5cXG4vKipcXG4gKiBTYXZlIHRpbWVyIHJlZmVyZW5jZXMgdG8gYXZvaWQgU2lub24gaW50ZXJmZXJpbmcgKHNlZSBHSC0yMzcpLlxcbiAqL1xcblxcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzLCBuby1uYXRpdmUtcmVhc3NpZ24gKi9cXG52YXIgRGF0ZSA9IGdsb2JhbC5EYXRlO1xcbnZhciBzZXRUaW1lb3V0ID0gZ2xvYmFsLnNldFRpbWVvdXQ7XFxudmFyIHNldEludGVydmFsID0gZ2xvYmFsLnNldEludGVydmFsO1xcbnZhciBjbGVhclRpbWVvdXQgPSBnbG9iYWwuY2xlYXJUaW1lb3V0O1xcbnZhciBjbGVhckludGVydmFsID0gZ2xvYmFsLmNsZWFySW50ZXJ2YWw7XFxuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycywgbm8tbmF0aXZlLXJlYXNzaWduICovXFxuXFxuLyoqXFxuICogT2JqZWN0I3RvU3RyaW5nKCkuXFxuICovXFxuXFxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcXG5cXG4vKipcXG4gKiBFeHBvc2UgYFJ1bm5hYmxlYC5cXG4gKi9cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IFJ1bm5hYmxlO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJ1bm5hYmxlYCB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZCBjYWxsYmFjayBgZm5gLlxcbiAqXFxuICogQHBhcmFtIHtTdHJpbmd9IHRpdGxlXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqL1xcbmZ1bmN0aW9uIFJ1bm5hYmxlKHRpdGxlLCBmbikge1xcbiAgdGhpcy50aXRsZSA9IHRpdGxlO1xcbiAgdGhpcy5mbiA9IGZuO1xcbiAgdGhpcy5hc3luYyA9IGZuICYmIGZuLmxlbmd0aDtcXG4gIHRoaXMuc3luYyA9ICF0aGlzLmFzeW5jO1xcbiAgdGhpcy5fdGltZW91dCA9IDIwMDA7XFxuICB0aGlzLl9zbG93ID0gNzU7XFxuICB0aGlzLl9lbmFibGVUaW1lb3V0cyA9IHRydWU7XFxuICB0aGlzLnRpbWVkT3V0ID0gZmFsc2U7XFxuICB0aGlzLl90cmFjZSA9IG5ldyBFcnJvcignZG9uZSgpIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycpO1xcbiAgdGhpcy5fcmV0cmllcyA9IC0xO1xcbiAgdGhpcy5fY3VycmVudFJldHJ5ID0gMDtcXG59XFxuXFxuLyoqXFxuICogSW5oZXJpdCBmcm9tIGBFdmVudEVtaXR0ZXIucHJvdG90eXBlYC5cXG4gKi9cXG5pbmhlcml0cyhSdW5uYWJsZSwgRXZlbnRFbWl0dGVyKTtcXG5cXG4vKipcXG4gKiBTZXQgJiBnZXQgdGltZW91dCBgbXNgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBtc1xcbiAqIEByZXR1cm4ge1J1bm5hYmxlfG51bWJlcn0gbXMgb3IgUnVubmFibGUgaW5zdGFuY2UuXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbihtcykge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLl90aW1lb3V0O1xcbiAgfVxcbiAgaWYgKG1zID09PSAwKSB7XFxuICAgIHRoaXMuX2VuYWJsZVRpbWVvdXRzID0gZmFsc2U7XFxuICB9XFxuICBpZiAodHlwZW9mIG1zID09PSAnc3RyaW5nJykge1xcbiAgICBtcyA9IG1pbGxpc2Vjb25kcyhtcyk7XFxuICB9XFxuICBkZWJ1ZygndGltZW91dCAlZCcsIG1zKTtcXG4gIHRoaXMuX3RpbWVvdXQgPSBtcztcXG4gIGlmICh0aGlzLnRpbWVyKSB7XFxuICAgIHRoaXMucmVzZXRUaW1lb3V0KCk7XFxuICB9XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCAmIGdldCBzbG93IGBtc2AuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG1zXFxuICogQHJldHVybiB7UnVubmFibGV8bnVtYmVyfSBtcyBvciBSdW5uYWJsZSBpbnN0YW5jZS5cXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUuc2xvdyA9IGZ1bmN0aW9uKG1zKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX3Nsb3c7XFxuICB9XFxuICBpZiAodHlwZW9mIG1zID09PSAnc3RyaW5nJykge1xcbiAgICBtcyA9IG1pbGxpc2Vjb25kcyhtcyk7XFxuICB9XFxuICBkZWJ1ZygndGltZW91dCAlZCcsIG1zKTtcXG4gIHRoaXMuX3Nsb3cgPSBtcztcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IGFuZCBnZXQgd2hldGhlciB0aW1lb3V0IGlzIGBlbmFibGVkYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxcbiAqIEByZXR1cm4ge1J1bm5hYmxlfGJvb2xlYW59IGVuYWJsZWQgb3IgUnVubmFibGUgaW5zdGFuY2UuXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLmVuYWJsZVRpbWVvdXRzID0gZnVuY3Rpb24oZW5hYmxlZCkge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLl9lbmFibGVUaW1lb3V0cztcXG4gIH1cXG4gIGRlYnVnKCdlbmFibGVUaW1lb3V0cyAlcycsIGVuYWJsZWQpO1xcbiAgdGhpcy5fZW5hYmxlVGltZW91dHMgPSBlbmFibGVkO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBIYWx0IGFuZCBtYXJrIGFzIHBlbmRpbmcuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uKCkge1xcbiAgdGhyb3cgbmV3IFBlbmRpbmcoKTtcXG59O1xcblxcbi8qKlxcbiAqIFNldCBudW1iZXIgb2YgcmV0cmllcy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS5yZXRyaWVzID0gZnVuY3Rpb24obikge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLl9yZXRyaWVzO1xcbiAgfVxcbiAgdGhpcy5fcmV0cmllcyA9IG47XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgY3VycmVudCByZXRyeVxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLmN1cnJlbnRSZXRyeSA9IGZ1bmN0aW9uKG4pIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFJldHJ5O1xcbiAgfVxcbiAgdGhpcy5fY3VycmVudFJldHJ5ID0gbjtcXG59O1xcblxcbi8qKlxcbiAqIFJldHVybiB0aGUgZnVsbCB0aXRsZSBnZW5lcmF0ZWQgYnkgcmVjdXJzaXZlbHkgY29uY2F0ZW5hdGluZyB0aGUgcGFyZW50J3NcXG4gKiBmdWxsIHRpdGxlLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLmZ1bGxUaXRsZSA9IGZ1bmN0aW9uKCkge1xcbiAgcmV0dXJuIHRoaXMucGFyZW50LmZ1bGxUaXRsZSgpICsgJyAnICsgdGhpcy50aXRsZTtcXG59O1xcblxcbi8qKlxcbiAqIENsZWFyIHRoZSB0aW1lb3V0LlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uKCkge1xcbiAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xcbn07XFxuXFxuLyoqXFxuICogSW5zcGVjdCB0aGUgcnVubmFibGUgdm9pZCBvZiBwcml2YXRlIHByb3BlcnRpZXMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcXG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLCBmdW5jdGlvbihrZXksIHZhbCkge1xcbiAgICBpZiAoa2V5WzBdID09PSAnXycpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgaWYgKGtleSA9PT0gJ3BhcmVudCcpIHtcXG4gICAgICByZXR1cm4gJyM8U3VpdGU+JztcXG4gICAgfVxcbiAgICBpZiAoa2V5ID09PSAnY3R4Jykge1xcbiAgICAgIHJldHVybiAnIzxDb250ZXh0Pic7XFxuICAgIH1cXG4gICAgcmV0dXJuIHZhbDtcXG4gIH0sIDIpO1xcbn07XFxuXFxuLyoqXFxuICogUmVzZXQgdGhlIHRpbWVvdXQuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUucmVzZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgbXMgPSB0aGlzLnRpbWVvdXQoKSB8fCAxZTk7XFxuXFxuICBpZiAoIXRoaXMuX2VuYWJsZVRpbWVvdXRzKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG4gIHRoaXMuY2xlYXJUaW1lb3V0KCk7XFxuICB0aGlzLnRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcXG4gICAgaWYgKCFzZWxmLl9lbmFibGVUaW1lb3V0cykge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBzZWxmLmNhbGxiYWNrKG5ldyBFcnJvcigndGltZW91dCBvZiAnICsgbXMgKyAnbXMgZXhjZWVkZWQuIEVuc3VyZSB0aGUgZG9uZSgpIGNhbGxiYWNrIGlzIGJlaW5nIGNhbGxlZCBpbiB0aGlzIHRlc3QuJykpO1xcbiAgICBzZWxmLnRpbWVkT3V0ID0gdHJ1ZTtcXG4gIH0sIG1zKTtcXG59O1xcblxcbi8qKlxcbiAqIFdoaXRlbGlzdCBhIGxpc3Qgb2YgZ2xvYmFscyBmb3IgdGhpcyB0ZXN0IHJ1bi5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nW119IGdsb2JhbHNcXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUuZ2xvYmFscyA9IGZ1bmN0aW9uKGdsb2JhbHMpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fYWxsb3dlZEdsb2JhbHM7XFxuICB9XFxuICB0aGlzLl9hbGxvd2VkR2xvYmFscyA9IGdsb2JhbHM7XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gdGhlIHRlc3QgYW5kIGludm9rZSBgZm4oZXJyKWAuXFxuICpcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbihmbikge1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoKTtcXG4gIHZhciBjdHggPSB0aGlzLmN0eDtcXG4gIHZhciBmaW5pc2hlZDtcXG4gIHZhciBlbWl0dGVkO1xcblxcbiAgLy8gU29tZXRpbWVzIHRoZSBjdHggZXhpc3RzLCBidXQgaXQgaXMgbm90IHJ1bm5hYmxlXFxuICBpZiAoY3R4ICYmIGN0eC5ydW5uYWJsZSkge1xcbiAgICBjdHgucnVubmFibGUodGhpcyk7XFxuICB9XFxuXFxuICAvLyBjYWxsZWQgbXVsdGlwbGUgdGltZXNcXG4gIGZ1bmN0aW9uIG11bHRpcGxlKGVycikge1xcbiAgICBpZiAoZW1pdHRlZCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBlbWl0dGVkID0gdHJ1ZTtcXG4gICAgc2VsZi5lbWl0KCdlcnJvcicsIGVyciB8fCBuZXcgRXJyb3IoJ2RvbmUoKSBjYWxsZWQgbXVsdGlwbGUgdGltZXM7IHN0YWNrdHJhY2UgbWF5IGJlIGluYWNjdXJhdGUnKSk7XFxuICB9XFxuXFxuICAvLyBmaW5pc2hlZFxcbiAgZnVuY3Rpb24gZG9uZShlcnIpIHtcXG4gICAgdmFyIG1zID0gc2VsZi50aW1lb3V0KCk7XFxuICAgIGlmIChzZWxmLnRpbWVkT3V0KSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGlmIChmaW5pc2hlZCkge1xcbiAgICAgIHJldHVybiBtdWx0aXBsZShlcnIgfHwgc2VsZi5fdHJhY2UpO1xcbiAgICB9XFxuXFxuICAgIHNlbGYuY2xlYXJUaW1lb3V0KCk7XFxuICAgIHNlbGYuZHVyYXRpb24gPSBuZXcgRGF0ZSgpIC0gc3RhcnQ7XFxuICAgIGZpbmlzaGVkID0gdHJ1ZTtcXG4gICAgaWYgKCFlcnIgJiYgc2VsZi5kdXJhdGlvbiA+IG1zICYmIHNlbGYuX2VuYWJsZVRpbWVvdXRzKSB7XFxuICAgICAgZXJyID0gbmV3IEVycm9yKCd0aW1lb3V0IG9mICcgKyBtcyArICdtcyBleGNlZWRlZC4gRW5zdXJlIHRoZSBkb25lKCkgY2FsbGJhY2sgaXMgYmVpbmcgY2FsbGVkIGluIHRoaXMgdGVzdC4nKTtcXG4gICAgfVxcbiAgICBmbihlcnIpO1xcbiAgfVxcblxcbiAgLy8gZm9yIC5yZXNldFRpbWVvdXQoKVxcbiAgdGhpcy5jYWxsYmFjayA9IGRvbmU7XFxuXFxuICAvLyBleHBsaWNpdCBhc3luYyB3aXRoIGBkb25lYCBhcmd1bWVudFxcbiAgaWYgKHRoaXMuYXN5bmMpIHtcXG4gICAgdGhpcy5yZXNldFRpbWVvdXQoKTtcXG5cXG4gICAgaWYgKHRoaXMuYWxsb3dVbmNhdWdodCkge1xcbiAgICAgIHJldHVybiBjYWxsRm5Bc3luYyh0aGlzLmZuKTtcXG4gICAgfVxcbiAgICB0cnkge1xcbiAgICAgIGNhbGxGbkFzeW5jKHRoaXMuZm4pO1xcbiAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICBkb25lKHV0aWxzLmdldEVycm9yKGVycikpO1xcbiAgICB9XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIGlmICh0aGlzLmFsbG93VW5jYXVnaHQpIHtcXG4gICAgY2FsbEZuKHRoaXMuZm4pO1xcbiAgICBkb25lKCk7XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIC8vIHN5bmMgb3IgcHJvbWlzZS1yZXR1cm5pbmdcXG4gIHRyeSB7XFxuICAgIGlmICh0aGlzLnBlbmRpbmcpIHtcXG4gICAgICBkb25lKCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgY2FsbEZuKHRoaXMuZm4pO1xcbiAgICB9XFxuICB9IGNhdGNoIChlcnIpIHtcXG4gICAgZG9uZSh1dGlscy5nZXRFcnJvcihlcnIpKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNhbGxGbihmbikge1xcbiAgICB2YXIgcmVzdWx0ID0gZm4uY2FsbChjdHgpO1xcbiAgICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgIHNlbGYucmVzZXRUaW1lb3V0KCk7XFxuICAgICAgcmVzdWx0XFxuICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcXG4gICAgICAgICAgZG9uZSgpO1xcbiAgICAgICAgICAvLyBSZXR1cm4gbnVsbCBzbyBsaWJyYXJpZXMgbGlrZSBibHVlYmlyZCBkbyBub3Qgd2FybiBhYm91dFxcbiAgICAgICAgICAvLyBzdWJzZXF1ZW50bHkgY29uc3RydWN0ZWQgUHJvbWlzZXMuXFxuICAgICAgICAgIHJldHVybiBudWxsO1xcbiAgICAgICAgfSxcXG4gICAgICAgIGZ1bmN0aW9uKHJlYXNvbikge1xcbiAgICAgICAgICBkb25lKHJlYXNvbiB8fCBuZXcgRXJyb3IoJ1Byb21pc2UgcmVqZWN0ZWQgd2l0aCBubyBvciBmYWxzeSByZWFzb24nKSk7XFxuICAgICAgICB9KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBpZiAoc2VsZi5hc3luY09ubHkpIHtcXG4gICAgICAgIHJldHVybiBkb25lKG5ldyBFcnJvcignLS1hc3luYy1vbmx5IG9wdGlvbiBpbiB1c2Ugd2l0aG91dCBkZWNsYXJpbmcgYGRvbmUoKWAgb3IgcmV0dXJuaW5nIGEgcHJvbWlzZScpKTtcXG4gICAgICB9XFxuXFxuICAgICAgZG9uZSgpO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBjYWxsRm5Bc3luYyhmbikge1xcbiAgICBmbi5jYWxsKGN0eCwgZnVuY3Rpb24oZXJyKSB7XFxuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yIHx8IHRvU3RyaW5nLmNhbGwoZXJyKSA9PT0gJ1tvYmplY3QgRXJyb3JdJykge1xcbiAgICAgICAgcmV0dXJuIGRvbmUoZXJyKTtcXG4gICAgICB9XFxuICAgICAgaWYgKGVycikge1xcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlcnIpID09PSAnW29iamVjdCBPYmplY3RdJykge1xcbiAgICAgICAgICByZXR1cm4gZG9uZShuZXcgRXJyb3IoJ2RvbmUoKSBpbnZva2VkIHdpdGggbm9uLUVycm9yOiAnXFxuICAgICAgICAgICAgKyBKU09OLnN0cmluZ2lmeShlcnIpKSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gZG9uZShuZXcgRXJyb3IoJ2RvbmUoKSBpbnZva2VkIHdpdGggbm9uLUVycm9yOiAnICsgZXJyKSk7XFxuICAgICAgfVxcbiAgICAgIGRvbmUoKTtcXG4gICAgfSk7XFxuICB9XFxufTtcXG5cXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSlcXG59LHtcXFwiLi9tc1xcXCI6MTUsXFxcIi4vcGVuZGluZ1xcXCI6MTYsXFxcIi4vdXRpbHNcXFwiOjM5LFxcXCJkZWJ1Z1xcXCI6MixcXFwiZXZlbnRzXFxcIjozfV0sMzY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcXG52YXIgUGVuZGluZyA9IHJlcXVpcmUoJy4vcGVuZGluZycpO1xcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcXG52YXIgaW5oZXJpdHMgPSB1dGlscy5pbmhlcml0cztcXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdtb2NoYTpydW5uZXInKTtcXG52YXIgUnVubmFibGUgPSByZXF1aXJlKCcuL3J1bm5hYmxlJyk7XFxudmFyIGZpbHRlciA9IHV0aWxzLmZpbHRlcjtcXG52YXIgaW5kZXhPZiA9IHV0aWxzLmluZGV4T2Y7XFxudmFyIGtleXMgPSB1dGlscy5rZXlzO1xcbnZhciBzdGFja0ZpbHRlciA9IHV0aWxzLnN0YWNrVHJhY2VGaWx0ZXIoKTtcXG52YXIgc3RyaW5naWZ5ID0gdXRpbHMuc3RyaW5naWZ5O1xcbnZhciB0eXBlID0gdXRpbHMudHlwZTtcXG52YXIgdW5kZWZpbmVkRXJyb3IgPSB1dGlscy51bmRlZmluZWRFcnJvcjtcXG52YXIgaXNBcnJheSA9IHV0aWxzLmlzQXJyYXk7XFxuXFxuLyoqXFxuICogTm9uLWVudW1lcmFibGUgZ2xvYmFscy5cXG4gKi9cXG5cXG52YXIgZ2xvYmFscyA9IFtcXG4gICdzZXRUaW1lb3V0JyxcXG4gICdjbGVhclRpbWVvdXQnLFxcbiAgJ3NldEludGVydmFsJyxcXG4gICdjbGVhckludGVydmFsJyxcXG4gICdYTUxIdHRwUmVxdWVzdCcsXFxuICAnRGF0ZScsXFxuICAnc2V0SW1tZWRpYXRlJyxcXG4gICdjbGVhckltbWVkaWF0ZSdcXG5dO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgUnVubmVyYC5cXG4gKi9cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IFJ1bm5lcjtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgYFJ1bm5lcmAgZm9yIHRoZSBnaXZlbiBgc3VpdGVgLlxcbiAqXFxuICogRXZlbnRzOlxcbiAqXFxuICogICAtIGBzdGFydGAgIGV4ZWN1dGlvbiBzdGFydGVkXFxuICogICAtIGBlbmRgICBleGVjdXRpb24gY29tcGxldGVcXG4gKiAgIC0gYHN1aXRlYCAgKHN1aXRlKSB0ZXN0IHN1aXRlIGV4ZWN1dGlvbiBzdGFydGVkXFxuICogICAtIGBzdWl0ZSBlbmRgICAoc3VpdGUpIGFsbCB0ZXN0cyAoYW5kIHN1Yi1zdWl0ZXMpIGhhdmUgZmluaXNoZWRcXG4gKiAgIC0gYHRlc3RgICAodGVzdCkgdGVzdCBleGVjdXRpb24gc3RhcnRlZFxcbiAqICAgLSBgdGVzdCBlbmRgICAodGVzdCkgdGVzdCBjb21wbGV0ZWRcXG4gKiAgIC0gYGhvb2tgICAoaG9vaykgaG9vayBleGVjdXRpb24gc3RhcnRlZFxcbiAqICAgLSBgaG9vayBlbmRgICAoaG9vaykgaG9vayBjb21wbGV0ZVxcbiAqICAgLSBgcGFzc2AgICh0ZXN0KSB0ZXN0IHBhc3NlZFxcbiAqICAgLSBgZmFpbGAgICh0ZXN0LCBlcnIpIHRlc3QgZmFpbGVkXFxuICogICAtIGBwZW5kaW5nYCAgKHRlc3QpIHRlc3QgcGVuZGluZ1xcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZSBSb290IHN1aXRlXFxuICogQHBhcmFtIHtib29sZWFufSBbZGVsYXldIFdoZXRoZXIgb3Igbm90IHRvIGRlbGF5IGV4ZWN1dGlvbiBvZiByb290IHN1aXRlXFxuICogdW50aWwgcmVhZHkuXFxuICovXFxuZnVuY3Rpb24gUnVubmVyKHN1aXRlLCBkZWxheSkge1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdGhpcy5fZ2xvYmFscyA9IFtdO1xcbiAgdGhpcy5fYWJvcnQgPSBmYWxzZTtcXG4gIHRoaXMuX2RlbGF5ID0gZGVsYXk7XFxuICB0aGlzLnN1aXRlID0gc3VpdGU7XFxuICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcXG4gIHRoaXMudG90YWwgPSBzdWl0ZS50b3RhbCgpO1xcbiAgdGhpcy5mYWlsdXJlcyA9IDA7XFxuICB0aGlzLm9uKCd0ZXN0IGVuZCcsIGZ1bmN0aW9uKHRlc3QpIHtcXG4gICAgc2VsZi5jaGVja0dsb2JhbHModGVzdCk7XFxuICB9KTtcXG4gIHRoaXMub24oJ2hvb2sgZW5kJywgZnVuY3Rpb24oaG9vaykge1xcbiAgICBzZWxmLmNoZWNrR2xvYmFscyhob29rKTtcXG4gIH0pO1xcbiAgdGhpcy5fZGVmYXVsdEdyZXAgPSAvLiovO1xcbiAgdGhpcy5ncmVwKHRoaXMuX2RlZmF1bHRHcmVwKTtcXG4gIHRoaXMuZ2xvYmFscyh0aGlzLmdsb2JhbFByb3BzKCkuY29uY2F0KGV4dHJhR2xvYmFscygpKSk7XFxufVxcblxcbi8qKlxcbiAqIFdyYXBwZXIgZm9yIHNldEltbWVkaWF0ZSwgcHJvY2Vzcy5uZXh0VGljaywgb3IgYnJvd3NlciBwb2x5ZmlsbC5cXG4gKlxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmVyLmltbWVkaWF0ZWx5ID0gZ2xvYmFsLnNldEltbWVkaWF0ZSB8fCBwcm9jZXNzLm5leHRUaWNrO1xcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgRXZlbnRFbWl0dGVyLnByb3RvdHlwZWAuXFxuICovXFxuaW5oZXJpdHMoUnVubmVyLCBFdmVudEVtaXR0ZXIpO1xcblxcbi8qKlxcbiAqIFJ1biB0ZXN0cyB3aXRoIGZ1bGwgdGl0bGVzIG1hdGNoaW5nIGByZWAuIFVwZGF0ZXMgcnVubmVyLnRvdGFsXFxuICogd2l0aCBudW1iZXIgb2YgdGVzdHMgbWF0Y2hlZC5cXG4gKlxcbiAqIEBwYXJhbSB7UmVnRXhwfSByZVxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW52ZXJ0XFxuICogQHJldHVybiB7UnVubmVyfSBmb3IgY2hhaW5pbmdcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UmVnRXhwfSByZVxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW52ZXJ0XFxuICogQHJldHVybiB7UnVubmVyfSBSdW5uZXIgaW5zdGFuY2UuXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5ncmVwID0gZnVuY3Rpb24ocmUsIGludmVydCkge1xcbiAgZGVidWcoJ2dyZXAgJXMnLCByZSk7XFxuICB0aGlzLl9ncmVwID0gcmU7XFxuICB0aGlzLl9pbnZlcnQgPSBpbnZlcnQ7XFxuICB0aGlzLnRvdGFsID0gdGhpcy5ncmVwVG90YWwodGhpcy5zdWl0ZSk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiB0ZXN0cyBtYXRjaGluZyB0aGUgZ3JlcCBzZWFyY2ggZm9yIHRoZVxcbiAqIGdpdmVuIHN1aXRlLlxcbiAqXFxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGVcXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZVxcbiAqIEByZXR1cm4ge251bWJlcn1cXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLmdyZXBUb3RhbCA9IGZ1bmN0aW9uKHN1aXRlKSB7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgdG90YWwgPSAwO1xcblxcbiAgc3VpdGUuZWFjaFRlc3QoZnVuY3Rpb24odGVzdCkge1xcbiAgICB2YXIgbWF0Y2ggPSBzZWxmLl9ncmVwLnRlc3QodGVzdC5mdWxsVGl0bGUoKSk7XFxuICAgIGlmIChzZWxmLl9pbnZlcnQpIHtcXG4gICAgICBtYXRjaCA9ICFtYXRjaDtcXG4gICAgfVxcbiAgICBpZiAobWF0Y2gpIHtcXG4gICAgICB0b3RhbCsrO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIHJldHVybiB0b3RhbDtcXG59O1xcblxcbi8qKlxcbiAqIFJldHVybiBhIGxpc3Qgb2YgZ2xvYmFsIHByb3BlcnRpZXMuXFxuICpcXG4gKiBAcmV0dXJuIHtBcnJheX1cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLmdsb2JhbFByb3BzID0gZnVuY3Rpb24oKSB7XFxuICB2YXIgcHJvcHMgPSBrZXlzKGdsb2JhbCk7XFxuXFxuICAvLyBub24tZW51bWVyYWJsZXNcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZ2xvYmFscy5sZW5ndGg7ICsraSkge1xcbiAgICBpZiAofmluZGV4T2YocHJvcHMsIGdsb2JhbHNbaV0pKSB7XFxuICAgICAgY29udGludWU7XFxuICAgIH1cXG4gICAgcHJvcHMucHVzaChnbG9iYWxzW2ldKTtcXG4gIH1cXG5cXG4gIHJldHVybiBwcm9wcztcXG59O1xcblxcbi8qKlxcbiAqIEFsbG93IHRoZSBnaXZlbiBgYXJyYCBvZiBnbG9iYWxzLlxcbiAqXFxuICogQHBhcmFtIHtBcnJheX0gYXJyXFxuICogQHJldHVybiB7UnVubmVyfSBmb3IgY2hhaW5pbmdcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxcbiAqIEByZXR1cm4ge1J1bm5lcn0gUnVubmVyIGluc3RhbmNlLlxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUuZ2xvYmFscyA9IGZ1bmN0aW9uKGFycikge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLl9nbG9iYWxzO1xcbiAgfVxcbiAgZGVidWcoJ2dsb2JhbHMgJWonLCBhcnIpO1xcbiAgdGhpcy5fZ2xvYmFscyA9IHRoaXMuX2dsb2JhbHMuY29uY2F0KGFycik7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIENoZWNrIGZvciBnbG9iYWwgdmFyaWFibGUgbGVha3MuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLmNoZWNrR2xvYmFscyA9IGZ1bmN0aW9uKHRlc3QpIHtcXG4gIGlmICh0aGlzLmlnbm9yZUxlYWtzKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG4gIHZhciBvayA9IHRoaXMuX2dsb2JhbHM7XFxuXFxuICB2YXIgZ2xvYmFscyA9IHRoaXMuZ2xvYmFsUHJvcHMoKTtcXG4gIHZhciBsZWFrcztcXG5cXG4gIGlmICh0ZXN0KSB7XFxuICAgIG9rID0gb2suY29uY2F0KHRlc3QuX2FsbG93ZWRHbG9iYWxzIHx8IFtdKTtcXG4gIH1cXG5cXG4gIGlmICh0aGlzLnByZXZHbG9iYWxzTGVuZ3RoID09PSBnbG9iYWxzLmxlbmd0aCkge1xcbiAgICByZXR1cm47XFxuICB9XFxuICB0aGlzLnByZXZHbG9iYWxzTGVuZ3RoID0gZ2xvYmFscy5sZW5ndGg7XFxuXFxuICBsZWFrcyA9IGZpbHRlckxlYWtzKG9rLCBnbG9iYWxzKTtcXG4gIHRoaXMuX2dsb2JhbHMgPSB0aGlzLl9nbG9iYWxzLmNvbmNhdChsZWFrcyk7XFxuXFxuICBpZiAobGVha3MubGVuZ3RoID4gMSkge1xcbiAgICB0aGlzLmZhaWwodGVzdCwgbmV3IEVycm9yKCdnbG9iYWwgbGVha3MgZGV0ZWN0ZWQ6ICcgKyBsZWFrcy5qb2luKCcsICcpICsgJycpKTtcXG4gIH0gZWxzZSBpZiAobGVha3MubGVuZ3RoKSB7XFxuICAgIHRoaXMuZmFpbCh0ZXN0LCBuZXcgRXJyb3IoJ2dsb2JhbCBsZWFrIGRldGVjdGVkOiAnICsgbGVha3NbMF0pKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIEZhaWwgdGhlIGdpdmVuIGB0ZXN0YC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7VGVzdH0gdGVzdFxcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUuZmFpbCA9IGZ1bmN0aW9uKHRlc3QsIGVycikge1xcbiAgKyt0aGlzLmZhaWx1cmVzO1xcbiAgdGVzdC5zdGF0ZSA9ICdmYWlsZWQnO1xcblxcbiAgaWYgKCEoZXJyIGluc3RhbmNlb2YgRXJyb3IgfHwgZXJyICYmIHR5cGVvZiBlcnIubWVzc2FnZSA9PT0gJ3N0cmluZycpKSB7XFxuICAgIGVyciA9IG5ldyBFcnJvcigndGhlICcgKyB0eXBlKGVycikgKyAnICcgKyBzdHJpbmdpZnkoZXJyKSArICcgd2FzIHRocm93biwgdGhyb3cgYW4gRXJyb3IgOiknKTtcXG4gIH1cXG5cXG4gIGVyci5zdGFjayA9ICh0aGlzLmZ1bGxTdGFja1RyYWNlIHx8ICFlcnIuc3RhY2spXFxuICAgID8gZXJyLnN0YWNrXFxuICAgIDogc3RhY2tGaWx0ZXIoZXJyLnN0YWNrKTtcXG5cXG4gIHRoaXMuZW1pdCgnZmFpbCcsIHRlc3QsIGVycik7XFxufTtcXG5cXG4vKipcXG4gKiBGYWlsIHRoZSBnaXZlbiBgaG9va2Agd2l0aCBgZXJyYC5cXG4gKlxcbiAqIEhvb2sgZmFpbHVyZXMgd29yayBpbiB0aGUgZm9sbG93aW5nIHBhdHRlcm46XFxuICogLSBJZiBiYWlsLCB0aGVuIGV4aXRcXG4gKiAtIEZhaWxlZCBgYmVmb3JlYCBob29rIHNraXBzIGFsbCB0ZXN0cyBpbiBhIHN1aXRlIGFuZCBzdWJzdWl0ZXMsXFxuICogICBidXQganVtcHMgdG8gY29ycmVzcG9uZGluZyBgYWZ0ZXJgIGhvb2tcXG4gKiAtIEZhaWxlZCBgYmVmb3JlIGVhY2hgIGhvb2sgc2tpcHMgcmVtYWluaW5nIHRlc3RzIGluIGFcXG4gKiAgIHN1aXRlIGFuZCBqdW1wcyB0byBjb3JyZXNwb25kaW5nIGBhZnRlciBlYWNoYCBob29rLFxcbiAqICAgd2hpY2ggaXMgcnVuIG9ubHkgb25jZVxcbiAqIC0gRmFpbGVkIGBhZnRlcmAgaG9vayBkb2VzIG5vdCBhbHRlclxcbiAqICAgZXhlY3V0aW9uIG9yZGVyXFxuICogLSBGYWlsZWQgYGFmdGVyIGVhY2hgIGhvb2sgc2tpcHMgcmVtYWluaW5nIHRlc3RzIGluIGFcXG4gKiAgIHN1aXRlIGFuZCBzdWJzdWl0ZXMsIGJ1dCBleGVjdXRlcyBvdGhlciBgYWZ0ZXIgZWFjaGBcXG4gKiAgIGhvb2tzXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge0hvb2t9IGhvb2tcXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLmZhaWxIb29rID0gZnVuY3Rpb24oaG9vaywgZXJyKSB7XFxuICBpZiAoaG9vay5jdHggJiYgaG9vay5jdHguY3VycmVudFRlc3QpIHtcXG4gICAgaG9vay5vcmlnaW5hbFRpdGxlID0gaG9vay5vcmlnaW5hbFRpdGxlIHx8IGhvb2sudGl0bGU7XFxuICAgIGhvb2sudGl0bGUgPSBob29rLm9yaWdpbmFsVGl0bGUgKyAnIGZvciBcXFwiJyArIGhvb2suY3R4LmN1cnJlbnRUZXN0LnRpdGxlICsgJ1xcXCInO1xcbiAgfVxcblxcbiAgdGhpcy5mYWlsKGhvb2ssIGVycik7XFxuICBpZiAodGhpcy5zdWl0ZS5iYWlsKCkpIHtcXG4gICAgdGhpcy5lbWl0KCdlbmQnKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIFJ1biBob29rIGBuYW1lYCBjYWxsYmFja3MgYW5kIHRoZW4gaW52b2tlIGBmbigpYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKi9cXG5cXG5SdW5uZXIucHJvdG90eXBlLmhvb2sgPSBmdW5jdGlvbihuYW1lLCBmbikge1xcbiAgdmFyIHN1aXRlID0gdGhpcy5zdWl0ZTtcXG4gIHZhciBob29rcyA9IHN1aXRlWydfJyArIG5hbWVdO1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgZnVuY3Rpb24gbmV4dChpKSB7XFxuICAgIHZhciBob29rID0gaG9va3NbaV07XFxuICAgIGlmICghaG9vaykge1xcbiAgICAgIHJldHVybiBmbigpO1xcbiAgICB9XFxuICAgIHNlbGYuY3VycmVudFJ1bm5hYmxlID0gaG9vaztcXG5cXG4gICAgaG9vay5jdHguY3VycmVudFRlc3QgPSBzZWxmLnRlc3Q7XFxuXFxuICAgIHNlbGYuZW1pdCgnaG9vaycsIGhvb2spO1xcblxcbiAgICBpZiAoIWhvb2subGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCkge1xcbiAgICAgIGhvb2sub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XFxuICAgICAgICBzZWxmLmZhaWxIb29rKGhvb2ssIGVycik7XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgaG9vay5ydW4oZnVuY3Rpb24oZXJyKSB7XFxuICAgICAgdmFyIHRlc3RFcnJvciA9IGhvb2suZXJyb3IoKTtcXG4gICAgICBpZiAodGVzdEVycm9yKSB7XFxuICAgICAgICBzZWxmLmZhaWwoc2VsZi50ZXN0LCB0ZXN0RXJyb3IpO1xcbiAgICAgIH1cXG4gICAgICBpZiAoZXJyKSB7XFxuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgUGVuZGluZykge1xcbiAgICAgICAgICBzdWl0ZS5wZW5kaW5nID0gdHJ1ZTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHNlbGYuZmFpbEhvb2soaG9vaywgZXJyKTtcXG5cXG4gICAgICAgICAgLy8gc3RvcCBleGVjdXRpbmcgaG9va3MsIG5vdGlmeSBjYWxsZWUgb2YgaG9vayBlcnJcXG4gICAgICAgICAgcmV0dXJuIGZuKGVycik7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHNlbGYuZW1pdCgnaG9vayBlbmQnLCBob29rKTtcXG4gICAgICBkZWxldGUgaG9vay5jdHguY3VycmVudFRlc3Q7XFxuICAgICAgbmV4dCgrK2kpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIFJ1bm5lci5pbW1lZGlhdGVseShmdW5jdGlvbigpIHtcXG4gICAgbmV4dCgwKTtcXG4gIH0pO1xcbn07XFxuXFxuLyoqXFxuICogUnVuIGhvb2sgYG5hbWVgIGZvciB0aGUgZ2l2ZW4gYXJyYXkgb2YgYHN1aXRlc2BcXG4gKiBpbiBvcmRlciwgYW5kIGNhbGxiYWNrIGBmbihlcnIsIGVyclN1aXRlKWAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxcbiAqIEBwYXJhbSB7QXJyYXl9IHN1aXRlc1xcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5ob29rcyA9IGZ1bmN0aW9uKG5hbWUsIHN1aXRlcywgZm4pIHtcXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciBvcmlnID0gdGhpcy5zdWl0ZTtcXG5cXG4gIGZ1bmN0aW9uIG5leHQoc3VpdGUpIHtcXG4gICAgc2VsZi5zdWl0ZSA9IHN1aXRlO1xcblxcbiAgICBpZiAoIXN1aXRlKSB7XFxuICAgICAgc2VsZi5zdWl0ZSA9IG9yaWc7XFxuICAgICAgcmV0dXJuIGZuKCk7XFxuICAgIH1cXG5cXG4gICAgc2VsZi5ob29rKG5hbWUsIGZ1bmN0aW9uKGVycikge1xcbiAgICAgIGlmIChlcnIpIHtcXG4gICAgICAgIHZhciBlcnJTdWl0ZSA9IHNlbGYuc3VpdGU7XFxuICAgICAgICBzZWxmLnN1aXRlID0gb3JpZztcXG4gICAgICAgIHJldHVybiBmbihlcnIsIGVyclN1aXRlKTtcXG4gICAgICB9XFxuXFxuICAgICAgbmV4dChzdWl0ZXMucG9wKCkpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIG5leHQoc3VpdGVzLnBvcCgpKTtcXG59O1xcblxcbi8qKlxcbiAqIFJ1biBob29rcyBmcm9tIHRoZSB0b3AgbGV2ZWwgZG93bi5cXG4gKlxcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLmhvb2tVcCA9IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XFxuICB2YXIgc3VpdGVzID0gW3RoaXMuc3VpdGVdLmNvbmNhdCh0aGlzLnBhcmVudHMoKSkucmV2ZXJzZSgpO1xcbiAgdGhpcy5ob29rcyhuYW1lLCBzdWl0ZXMsIGZuKTtcXG59O1xcblxcbi8qKlxcbiAqIFJ1biBob29rcyBmcm9tIHRoZSBib3R0b20gdXAuXFxuICpcXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5ob29rRG93biA9IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XFxuICB2YXIgc3VpdGVzID0gW3RoaXMuc3VpdGVdLmNvbmNhdCh0aGlzLnBhcmVudHMoKSk7XFxuICB0aGlzLmhvb2tzKG5hbWUsIHN1aXRlcywgZm4pO1xcbn07XFxuXFxuLyoqXFxuICogUmV0dXJuIGFuIGFycmF5IG9mIHBhcmVudCBTdWl0ZXMgZnJvbVxcbiAqIGNsb3Nlc3QgdG8gZnVydGhlc3QuXFxuICpcXG4gKiBAcmV0dXJuIHtBcnJheX1cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLnBhcmVudHMgPSBmdW5jdGlvbigpIHtcXG4gIHZhciBzdWl0ZSA9IHRoaXMuc3VpdGU7XFxuICB2YXIgc3VpdGVzID0gW107XFxuICB3aGlsZSAoc3VpdGUucGFyZW50KSB7XFxuICAgIHN1aXRlID0gc3VpdGUucGFyZW50O1xcbiAgICBzdWl0ZXMucHVzaChzdWl0ZSk7XFxuICB9XFxuICByZXR1cm4gc3VpdGVzO1xcbn07XFxuXFxuLyoqXFxuICogUnVuIHRoZSBjdXJyZW50IHRlc3QgYW5kIGNhbGxiYWNrIGBmbihlcnIpYC5cXG4gKlxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5ydW5UZXN0ID0gZnVuY3Rpb24oZm4pIHtcXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciB0ZXN0ID0gdGhpcy50ZXN0O1xcblxcbiAgaWYgKHRoaXMuYXN5bmNPbmx5KSB7XFxuICAgIHRlc3QuYXN5bmNPbmx5ID0gdHJ1ZTtcXG4gIH1cXG5cXG4gIGlmICh0aGlzLmFsbG93VW5jYXVnaHQpIHtcXG4gICAgdGVzdC5hbGxvd1VuY2F1Z2h0ID0gdHJ1ZTtcXG4gICAgcmV0dXJuIHRlc3QucnVuKGZuKTtcXG4gIH1cXG4gIHRyeSB7XFxuICAgIHRlc3Qub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XFxuICAgICAgc2VsZi5mYWlsKHRlc3QsIGVycik7XFxuICAgIH0pO1xcbiAgICB0ZXN0LnJ1bihmbik7XFxuICB9IGNhdGNoIChlcnIpIHtcXG4gICAgZm4oZXJyKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIFJ1biB0ZXN0cyBpbiB0aGUgZ2l2ZW4gYHN1aXRlYCBhbmQgaW52b2tlIHRoZSBjYWxsYmFjayBgZm4oKWAgd2hlbiBjb21wbGV0ZS5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLnJ1blRlc3RzID0gZnVuY3Rpb24oc3VpdGUsIGZuKSB7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgdGVzdHMgPSBzdWl0ZS50ZXN0cy5zbGljZSgpO1xcbiAgdmFyIHRlc3Q7XFxuXFxuICBmdW5jdGlvbiBob29rRXJyKF8sIGVyclN1aXRlLCBhZnRlcikge1xcbiAgICAvLyBiZWZvcmUvYWZ0ZXIgRWFjaCBob29rIGZvciBlcnJTdWl0ZSBmYWlsZWQ6XFxuICAgIHZhciBvcmlnID0gc2VsZi5zdWl0ZTtcXG5cXG4gICAgLy8gZm9yIGZhaWxlZCAnYWZ0ZXIgZWFjaCcgaG9vayBzdGFydCBmcm9tIGVyclN1aXRlIHBhcmVudCxcXG4gICAgLy8gb3RoZXJ3aXNlIHN0YXJ0IGZyb20gZXJyU3VpdGUgaXRzZWxmXFxuICAgIHNlbGYuc3VpdGUgPSBhZnRlciA/IGVyclN1aXRlLnBhcmVudCA6IGVyclN1aXRlO1xcblxcbiAgICBpZiAoc2VsZi5zdWl0ZSkge1xcbiAgICAgIC8vIGNhbGwgaG9va1VwIGFmdGVyRWFjaFxcbiAgICAgIHNlbGYuaG9va1VwKCdhZnRlckVhY2gnLCBmdW5jdGlvbihlcnIyLCBlcnJTdWl0ZTIpIHtcXG4gICAgICAgIHNlbGYuc3VpdGUgPSBvcmlnO1xcbiAgICAgICAgLy8gc29tZSBob29rcyBtYXkgZmFpbCBldmVuIG5vd1xcbiAgICAgICAgaWYgKGVycjIpIHtcXG4gICAgICAgICAgcmV0dXJuIGhvb2tFcnIoZXJyMiwgZXJyU3VpdGUyLCB0cnVlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8vIHJlcG9ydCBlcnJvciBzdWl0ZVxcbiAgICAgICAgZm4oZXJyU3VpdGUpO1xcbiAgICAgIH0pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vIHRoZXJlIGlzIG5vIG5lZWQgY2FsbGluZyBvdGhlciAnYWZ0ZXIgZWFjaCcgaG9va3NcXG4gICAgICBzZWxmLnN1aXRlID0gb3JpZztcXG4gICAgICBmbihlcnJTdWl0ZSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIG5leHQoZXJyLCBlcnJTdWl0ZSkge1xcbiAgICAvLyBpZiB3ZSBiYWlsIGFmdGVyIGZpcnN0IGVyclxcbiAgICBpZiAoc2VsZi5mYWlsdXJlcyAmJiBzdWl0ZS5fYmFpbCkge1xcbiAgICAgIHJldHVybiBmbigpO1xcbiAgICB9XFxuXFxuICAgIGlmIChzZWxmLl9hYm9ydCkge1xcbiAgICAgIHJldHVybiBmbigpO1xcbiAgICB9XFxuXFxuICAgIGlmIChlcnIpIHtcXG4gICAgICByZXR1cm4gaG9va0VycihlcnIsIGVyclN1aXRlLCB0cnVlKTtcXG4gICAgfVxcblxcbiAgICAvLyBuZXh0IHRlc3RcXG4gICAgdGVzdCA9IHRlc3RzLnNoaWZ0KCk7XFxuXFxuICAgIC8vIGFsbCBkb25lXFxuICAgIGlmICghdGVzdCkge1xcbiAgICAgIHJldHVybiBmbigpO1xcbiAgICB9XFxuXFxuICAgIC8vIGdyZXBcXG4gICAgdmFyIG1hdGNoID0gc2VsZi5fZ3JlcC50ZXN0KHRlc3QuZnVsbFRpdGxlKCkpO1xcbiAgICBpZiAoc2VsZi5faW52ZXJ0KSB7XFxuICAgICAgbWF0Y2ggPSAhbWF0Y2g7XFxuICAgIH1cXG4gICAgaWYgKCFtYXRjaCkge1xcbiAgICAgIC8vIFJ1biBpbW1lZGlhdGVseSBvbmx5IGlmIHdlIGhhdmUgZGVmaW5lZCBhIGdyZXAuIFdoZW4gd2VcXG4gICAgICAvLyBkZWZpbmUgYSBncmVwIOKAlCBJdCBjYW4gY2F1c2UgbWF4aW11bSBjYWxsc3RhY2sgZXJyb3IgaWZcXG4gICAgICAvLyB0aGUgZ3JlcCBpcyBkb2luZyBhIGxhcmdlIHJlY3Vyc2l2ZSBsb29wIGJ5IG5lZ2xlY3RpbmdcXG4gICAgICAvLyBhbGwgdGVzdHMuIFRoZSBydW4gaW1tZWRpYXRlbHkgZnVuY3Rpb24gYWxzbyBjb21lcyB3aXRoXFxuICAgICAgLy8gYSBwZXJmb3JtYW5jZSBjb3N0LiBTbyB3ZSBkb24ndCB3YW50IHRvIHJ1biBpbW1lZGlhdGVseVxcbiAgICAgIC8vIGlmIHdlIHJ1biB0aGUgd2hvbGUgdGVzdCBzdWl0ZSwgYmVjYXVzZSBydW5uaW5nIHRoZSB3aG9sZVxcbiAgICAgIC8vIHRlc3Qgc3VpdGUgZG9uJ3QgZG8gYW55IGltbWVkaWF0ZSByZWN1cnNpdmUgbG9vcHMuIFRodXMsXFxuICAgICAgLy8gYWxsb3dpbmcgYSBKUyBydW50aW1lIHRvIGJyZWF0aGUuXFxuICAgICAgaWYgKHNlbGYuX2dyZXAgIT09IHNlbGYuX2RlZmF1bHRHcmVwKSB7XFxuICAgICAgICBSdW5uZXIuaW1tZWRpYXRlbHkobmV4dCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIG5leHQoKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHBhcmVudFBlbmRpbmcoc3VpdGUpIHtcXG4gICAgICByZXR1cm4gc3VpdGUucGVuZGluZyB8fCAoc3VpdGUucGFyZW50ICYmIHBhcmVudFBlbmRpbmcoc3VpdGUucGFyZW50KSk7XFxuICAgIH1cXG5cXG4gICAgLy8gcGVuZGluZ1xcbiAgICBpZiAodGVzdC5wZW5kaW5nIHx8IHBhcmVudFBlbmRpbmcodGVzdC5wYXJlbnQpKSB7XFxuICAgICAgc2VsZi5lbWl0KCdwZW5kaW5nJywgdGVzdCk7XFxuICAgICAgc2VsZi5lbWl0KCd0ZXN0IGVuZCcsIHRlc3QpO1xcbiAgICAgIHJldHVybiBuZXh0KCk7XFxuICAgIH1cXG5cXG4gICAgLy8gZXhlY3V0ZSB0ZXN0IGFuZCBob29rKHMpXFxuICAgIHNlbGYuZW1pdCgndGVzdCcsIHNlbGYudGVzdCA9IHRlc3QpO1xcbiAgICBzZWxmLmhvb2tEb3duKCdiZWZvcmVFYWNoJywgZnVuY3Rpb24oZXJyLCBlcnJTdWl0ZSkge1xcbiAgICAgIGlmIChzdWl0ZS5wZW5kaW5nKSB7XFxuICAgICAgICBzZWxmLmVtaXQoJ3BlbmRpbmcnLCB0ZXN0KTtcXG4gICAgICAgIHNlbGYuZW1pdCgndGVzdCBlbmQnLCB0ZXN0KTtcXG4gICAgICAgIHJldHVybiBuZXh0KCk7XFxuICAgICAgfVxcbiAgICAgIGlmIChlcnIpIHtcXG4gICAgICAgIHJldHVybiBob29rRXJyKGVyciwgZXJyU3VpdGUsIGZhbHNlKTtcXG4gICAgICB9XFxuICAgICAgc2VsZi5jdXJyZW50UnVubmFibGUgPSBzZWxmLnRlc3Q7XFxuICAgICAgc2VsZi5ydW5UZXN0KGZ1bmN0aW9uKGVycikge1xcbiAgICAgICAgdGVzdCA9IHNlbGYudGVzdDtcXG4gICAgICAgIGlmIChlcnIpIHtcXG4gICAgICAgICAgdmFyIHJldHJ5ID0gdGVzdC5jdXJyZW50UmV0cnkoKTtcXG4gICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFBlbmRpbmcpIHtcXG4gICAgICAgICAgICB0ZXN0LnBlbmRpbmcgPSB0cnVlO1xcbiAgICAgICAgICAgIHNlbGYuZW1pdCgncGVuZGluZycsIHRlc3QpO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKHJldHJ5IDwgdGVzdC5yZXRyaWVzKCkpIHtcXG4gICAgICAgICAgICB2YXIgY2xvbmVkVGVzdCA9IHRlc3QuY2xvbmUoKTtcXG4gICAgICAgICAgICBjbG9uZWRUZXN0LmN1cnJlbnRSZXRyeShyZXRyeSArIDEpO1xcbiAgICAgICAgICAgIHRlc3RzLnVuc2hpZnQoY2xvbmVkVGVzdCk7XFxuXFxuICAgICAgICAgICAgLy8gRWFybHkgcmV0dXJuICsgaG9vayB0cmlnZ2VyIHNvIHRoYXQgaXQgZG9lc24ndFxcbiAgICAgICAgICAgIC8vIGluY3JlbWVudCB0aGUgY291bnQgd3JvbmdcXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5ob29rVXAoJ2FmdGVyRWFjaCcsIG5leHQpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHNlbGYuZmFpbCh0ZXN0LCBlcnIpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHNlbGYuZW1pdCgndGVzdCBlbmQnLCB0ZXN0KTtcXG5cXG4gICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFBlbmRpbmcpIHtcXG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiBzZWxmLmhvb2tVcCgnYWZ0ZXJFYWNoJywgbmV4dCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0ZXN0LnN0YXRlID0gJ3Bhc3NlZCc7XFxuICAgICAgICBzZWxmLmVtaXQoJ3Bhc3MnLCB0ZXN0KTtcXG4gICAgICAgIHNlbGYuZW1pdCgndGVzdCBlbmQnLCB0ZXN0KTtcXG4gICAgICAgIHNlbGYuaG9va1VwKCdhZnRlckVhY2gnLCBuZXh0KTtcXG4gICAgICB9KTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICB0aGlzLm5leHQgPSBuZXh0O1xcbiAgdGhpcy5ob29rRXJyID0gaG9va0VycjtcXG4gIG5leHQoKTtcXG59O1xcblxcbi8qKlxcbiAqIFJ1biB0aGUgZ2l2ZW4gYHN1aXRlYCBhbmQgaW52b2tlIHRoZSBjYWxsYmFjayBgZm4oKWAgd2hlbiBjb21wbGV0ZS5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLnJ1blN1aXRlID0gZnVuY3Rpb24oc3VpdGUsIGZuKSB7XFxuICB2YXIgaSA9IDA7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgdG90YWwgPSB0aGlzLmdyZXBUb3RhbChzdWl0ZSk7XFxuICB2YXIgYWZ0ZXJBbGxIb29rQ2FsbGVkID0gZmFsc2U7XFxuXFxuICBkZWJ1ZygncnVuIHN1aXRlICVzJywgc3VpdGUuZnVsbFRpdGxlKCkpO1xcblxcbiAgaWYgKCF0b3RhbCB8fCAoc2VsZi5mYWlsdXJlcyAmJiBzdWl0ZS5fYmFpbCkpIHtcXG4gICAgcmV0dXJuIGZuKCk7XFxuICB9XFxuXFxuICB0aGlzLmVtaXQoJ3N1aXRlJywgdGhpcy5zdWl0ZSA9IHN1aXRlKTtcXG5cXG4gIGZ1bmN0aW9uIG5leHQoZXJyU3VpdGUpIHtcXG4gICAgaWYgKGVyclN1aXRlKSB7XFxuICAgICAgLy8gY3VycmVudCBzdWl0ZSBmYWlsZWQgb24gYSBob29rIGZyb20gZXJyU3VpdGVcXG4gICAgICBpZiAoZXJyU3VpdGUgPT09IHN1aXRlKSB7XFxuICAgICAgICAvLyBpZiBlcnJTdWl0ZSBpcyBjdXJyZW50IHN1aXRlXFxuICAgICAgICAvLyBjb250aW51ZSB0byB0aGUgbmV4dCBzaWJsaW5nIHN1aXRlXFxuICAgICAgICByZXR1cm4gZG9uZSgpO1xcbiAgICAgIH1cXG4gICAgICAvLyBlcnJTdWl0ZSBpcyBhbW9uZyB0aGUgcGFyZW50cyBvZiBjdXJyZW50IHN1aXRlXFxuICAgICAgLy8gc3RvcCBleGVjdXRpb24gb2YgZXJyU3VpdGUgYW5kIGFsbCBzdWItc3VpdGVzXFxuICAgICAgcmV0dXJuIGRvbmUoZXJyU3VpdGUpO1xcbiAgICB9XFxuXFxuICAgIGlmIChzZWxmLl9hYm9ydCkge1xcbiAgICAgIHJldHVybiBkb25lKCk7XFxuICAgIH1cXG5cXG4gICAgdmFyIGN1cnIgPSBzdWl0ZS5zdWl0ZXNbaSsrXTtcXG4gICAgaWYgKCFjdXJyKSB7XFxuICAgICAgcmV0dXJuIGRvbmUoKTtcXG4gICAgfVxcblxcbiAgICAvLyBBdm9pZCBncmVwIG5lZ2xlY3RpbmcgbGFyZ2UgbnVtYmVyIG9mIHRlc3RzIGNhdXNpbmcgYVxcbiAgICAvLyBodWdlIHJlY3Vyc2l2ZSBsb29wIGFuZCB0aHVzIGEgbWF4aW11bSBjYWxsIHN0YWNrIGVycm9yLlxcbiAgICAvLyBTZWUgY29tbWVudCBpbiBgdGhpcy5ydW5UZXN0cygpYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cXG4gICAgaWYgKHNlbGYuX2dyZXAgIT09IHNlbGYuX2RlZmF1bHRHcmVwKSB7XFxuICAgICAgUnVubmVyLmltbWVkaWF0ZWx5KGZ1bmN0aW9uKCkge1xcbiAgICAgICAgc2VsZi5ydW5TdWl0ZShjdXJyLCBuZXh0KTtcXG4gICAgICB9KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzZWxmLnJ1blN1aXRlKGN1cnIsIG5leHQpO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBkb25lKGVyclN1aXRlKSB7XFxuICAgIHNlbGYuc3VpdGUgPSBzdWl0ZTtcXG4gICAgc2VsZi5uZXh0U3VpdGUgPSBuZXh0O1xcblxcbiAgICBpZiAoYWZ0ZXJBbGxIb29rQ2FsbGVkKSB7XFxuICAgICAgZm4oZXJyU3VpdGUpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vIG1hcmsgdGhhdCB0aGUgYWZ0ZXJBbGwgYmxvY2sgaGFzIGJlZW4gY2FsbGVkIG9uY2VcXG4gICAgICAvLyBhbmQgc28gY2FuIGJlIHNraXBwZWQgaWYgdGhlcmUgaXMgYW4gZXJyb3IgaW4gaXQuXFxuICAgICAgYWZ0ZXJBbGxIb29rQ2FsbGVkID0gdHJ1ZTtcXG5cXG4gICAgICAvLyByZW1vdmUgcmVmZXJlbmNlIHRvIHRlc3RcXG4gICAgICBkZWxldGUgc2VsZi50ZXN0O1xcblxcbiAgICAgIHNlbGYuaG9vaygnYWZ0ZXJBbGwnLCBmdW5jdGlvbigpIHtcXG4gICAgICAgIHNlbGYuZW1pdCgnc3VpdGUgZW5kJywgc3VpdGUpO1xcbiAgICAgICAgZm4oZXJyU3VpdGUpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9XFxuXFxuICB0aGlzLm5leHRTdWl0ZSA9IG5leHQ7XFxuXFxuICB0aGlzLmhvb2soJ2JlZm9yZUFsbCcsIGZ1bmN0aW9uKGVycikge1xcbiAgICBpZiAoZXJyKSB7XFxuICAgICAgcmV0dXJuIGRvbmUoKTtcXG4gICAgfVxcbiAgICBzZWxmLnJ1blRlc3RzKHN1aXRlLCBuZXh0KTtcXG4gIH0pO1xcbn07XFxuXFxuLyoqXFxuICogSGFuZGxlIHVuY2F1Z2h0IGV4Y2VwdGlvbnMuXFxuICpcXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLnVuY2F1Z2h0ID0gZnVuY3Rpb24oZXJyKSB7XFxuICBpZiAoZXJyKSB7XFxuICAgIGRlYnVnKCd1bmNhdWdodCBleGNlcHRpb24gJXMnLCBlcnIgIT09IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9LmNhbGwoZXJyKSA/IGVyciA6IChlcnIubWVzc2FnZSB8fCBlcnIpKTtcXG4gIH0gZWxzZSB7XFxuICAgIGRlYnVnKCd1bmNhdWdodCB1bmRlZmluZWQgZXhjZXB0aW9uJyk7XFxuICAgIGVyciA9IHVuZGVmaW5lZEVycm9yKCk7XFxuICB9XFxuICBlcnIudW5jYXVnaHQgPSB0cnVlO1xcblxcbiAgdmFyIHJ1bm5hYmxlID0gdGhpcy5jdXJyZW50UnVubmFibGU7XFxuXFxuICBpZiAoIXJ1bm5hYmxlKSB7XFxuICAgIHJ1bm5hYmxlID0gbmV3IFJ1bm5hYmxlKCdVbmNhdWdodCBlcnJvciBvdXRzaWRlIHRlc3Qgc3VpdGUnKTtcXG4gICAgcnVubmFibGUucGFyZW50ID0gdGhpcy5zdWl0ZTtcXG5cXG4gICAgaWYgKHRoaXMuc3RhcnRlZCkge1xcbiAgICAgIHRoaXMuZmFpbChydW5uYWJsZSwgZXJyKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBDYW4ndCByZWNvdmVyIGZyb20gdGhpcyBmYWlsdXJlXFxuICAgICAgdGhpcy5lbWl0KCdzdGFydCcpO1xcbiAgICAgIHRoaXMuZmFpbChydW5uYWJsZSwgZXJyKTtcXG4gICAgICB0aGlzLmVtaXQoJ2VuZCcpO1xcbiAgICB9XFxuXFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIHJ1bm5hYmxlLmNsZWFyVGltZW91dCgpO1xcblxcbiAgLy8gSWdub3JlIGVycm9ycyBpZiBjb21wbGV0ZVxcbiAgaWYgKHJ1bm5hYmxlLnN0YXRlKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG4gIHRoaXMuZmFpbChydW5uYWJsZSwgZXJyKTtcXG5cXG4gIC8vIHJlY292ZXIgZnJvbSB0ZXN0XFxuICBpZiAocnVubmFibGUudHlwZSA9PT0gJ3Rlc3QnKSB7XFxuICAgIHRoaXMuZW1pdCgndGVzdCBlbmQnLCBydW5uYWJsZSk7XFxuICAgIHRoaXMuaG9va1VwKCdhZnRlckVhY2gnLCB0aGlzLm5leHQpO1xcbiAgICByZXR1cm47XFxuICB9XFxuXFxuIC8vIHJlY292ZXIgZnJvbSBob29rc1xcbiAgaWYgKHJ1bm5hYmxlLnR5cGUgPT09ICdob29rJykge1xcbiAgICB2YXIgZXJyU3VpdGUgPSB0aGlzLnN1aXRlO1xcbiAgICAvLyBpZiBob29rIGZhaWx1cmUgaXMgaW4gYWZ0ZXJFYWNoIGJsb2NrXFxuICAgIGlmIChydW5uYWJsZS5mdWxsVGl0bGUoKS5pbmRleE9mKCdhZnRlciBlYWNoJykgPiAtMSkge1xcbiAgICAgIHJldHVybiB0aGlzLmhvb2tFcnIoZXJyLCBlcnJTdWl0ZSwgdHJ1ZSk7XFxuICAgIH1cXG4gICAgLy8gaWYgaG9vayBmYWlsdXJlIGlzIGluIGJlZm9yZUVhY2ggYmxvY2tcXG4gICAgaWYgKHJ1bm5hYmxlLmZ1bGxUaXRsZSgpLmluZGV4T2YoJ2JlZm9yZSBlYWNoJykgPiAtMSkge1xcbiAgICAgIHJldHVybiB0aGlzLmhvb2tFcnIoZXJyLCBlcnJTdWl0ZSwgZmFsc2UpO1xcbiAgICB9XFxuICAgIC8vIGlmIGhvb2sgZmFpbHVyZSBpcyBpbiBhZnRlciBvciBiZWZvcmUgYmxvY2tzXFxuICAgIHJldHVybiB0aGlzLm5leHRTdWl0ZShlcnJTdWl0ZSk7XFxuICB9XFxuXFxuICAvLyBiYWlsXFxuICB0aGlzLmVtaXQoJ2VuZCcpO1xcbn07XFxuXFxuLyoqXFxuICogQ2xlYW5zIHVwIHRoZSByZWZlcmVuY2VzIHRvIGFsbCB0aGUgZGVmZXJyZWQgZnVuY3Rpb25zXFxuICogKGJlZm9yZS9hZnRlci9iZWZvcmVFYWNoL2FmdGVyRWFjaCkgYW5kIHRlc3RzIG9mIGEgU3VpdGUuXFxuICogVGhlc2UgbXVzdCBiZSBkZWxldGVkIG90aGVyd2lzZSBhIG1lbW9yeSBsZWFrIGNhbiBoYXBwZW4sXFxuICogYXMgdGhvc2UgZnVuY3Rpb25zIG1heSByZWZlcmVuY2UgdmFyaWFibGVzIGZyb20gY2xvc3VyZXMsXFxuICogdGh1cyB0aG9zZSB2YXJpYWJsZXMgY2FuIG5ldmVyIGJlIGdhcmJhZ2UgY29sbGVjdGVkIGFzIGxvbmdcXG4gKiBhcyB0aGUgZGVmZXJyZWQgZnVuY3Rpb25zIGV4aXN0LlxcbiAqXFxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGVcXG4gKi9cXG5mdW5jdGlvbiBjbGVhblN1aXRlUmVmZXJlbmNlcyhzdWl0ZSkge1xcbiAgZnVuY3Rpb24gY2xlYW5BcnJSZWZlcmVuY2VzKGFycikge1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xcbiAgICAgIGRlbGV0ZSBhcnJbaV0uZm47XFxuICAgIH1cXG4gIH1cXG5cXG4gIGlmIChpc0FycmF5KHN1aXRlLl9iZWZvcmVBbGwpKSB7XFxuICAgIGNsZWFuQXJyUmVmZXJlbmNlcyhzdWl0ZS5fYmVmb3JlQWxsKTtcXG4gIH1cXG5cXG4gIGlmIChpc0FycmF5KHN1aXRlLl9iZWZvcmVFYWNoKSkge1xcbiAgICBjbGVhbkFyclJlZmVyZW5jZXMoc3VpdGUuX2JlZm9yZUVhY2gpO1xcbiAgfVxcblxcbiAgaWYgKGlzQXJyYXkoc3VpdGUuX2FmdGVyQWxsKSkge1xcbiAgICBjbGVhbkFyclJlZmVyZW5jZXMoc3VpdGUuX2FmdGVyQWxsKTtcXG4gIH1cXG5cXG4gIGlmIChpc0FycmF5KHN1aXRlLl9hZnRlckVhY2gpKSB7XFxuICAgIGNsZWFuQXJyUmVmZXJlbmNlcyhzdWl0ZS5fYWZ0ZXJFYWNoKTtcXG4gIH1cXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3VpdGUudGVzdHMubGVuZ3RoOyBpKyspIHtcXG4gICAgZGVsZXRlIHN1aXRlLnRlc3RzW2ldLmZuO1xcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBSdW4gdGhlIHJvb3Qgc3VpdGUgYW5kIGludm9rZSBgZm4oZmFpbHVyZXMpYFxcbiAqIG9uIGNvbXBsZXRpb24uXFxuICpcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEByZXR1cm4ge1J1bm5lcn0gZm9yIGNoYWluaW5nXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEByZXR1cm4ge1J1bm5lcn0gUnVubmVyIGluc3RhbmNlLlxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oZm4pIHtcXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciByb290U3VpdGUgPSB0aGlzLnN1aXRlO1xcblxcbiAgZm4gPSBmbiB8fCBmdW5jdGlvbigpIHt9O1xcblxcbiAgZnVuY3Rpb24gdW5jYXVnaHQoZXJyKSB7XFxuICAgIHNlbGYudW5jYXVnaHQoZXJyKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHN0YXJ0KCkge1xcbiAgICBzZWxmLnN0YXJ0ZWQgPSB0cnVlO1xcbiAgICBzZWxmLmVtaXQoJ3N0YXJ0Jyk7XFxuICAgIHNlbGYucnVuU3VpdGUocm9vdFN1aXRlLCBmdW5jdGlvbigpIHtcXG4gICAgICBkZWJ1ZygnZmluaXNoZWQgcnVubmluZycpO1xcbiAgICAgIHNlbGYuZW1pdCgnZW5kJyk7XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgZGVidWcoJ3N0YXJ0Jyk7XFxuXFxuICAvLyByZWZlcmVuY2VzIGNsZWFudXAgdG8gYXZvaWQgbWVtb3J5IGxlYWtzXFxuICB0aGlzLm9uKCdzdWl0ZSBlbmQnLCBjbGVhblN1aXRlUmVmZXJlbmNlcyk7XFxuXFxuICAvLyBjYWxsYmFja1xcbiAgdGhpcy5vbignZW5kJywgZnVuY3Rpb24oKSB7XFxuICAgIGRlYnVnKCdlbmQnKTtcXG4gICAgcHJvY2Vzcy5yZW1vdmVMaXN0ZW5lcigndW5jYXVnaHRFeGNlcHRpb24nLCB1bmNhdWdodCk7XFxuICAgIGZuKHNlbGYuZmFpbHVyZXMpO1xcbiAgfSk7XFxuXFxuICAvLyB1bmNhdWdodCBleGNlcHRpb25cXG4gIHByb2Nlc3Mub24oJ3VuY2F1Z2h0RXhjZXB0aW9uJywgdW5jYXVnaHQpO1xcblxcbiAgaWYgKHRoaXMuX2RlbGF5KSB7XFxuICAgIC8vIGZvciByZXBvcnRlcnMsIEkgZ3Vlc3MuXFxuICAgIC8vIG1pZ2h0IGJlIG5pY2UgdG8gZGVib3VuY2Ugc29tZSBkb3RzIHdoaWxlIHdlIHdhaXQuXFxuICAgIHRoaXMuZW1pdCgnd2FpdGluZycsIHJvb3RTdWl0ZSk7XFxuICAgIHJvb3RTdWl0ZS5vbmNlKCdydW4nLCBzdGFydCk7XFxuICB9IGVsc2Uge1xcbiAgICBzdGFydCgpO1xcbiAgfVxcblxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBDbGVhbmx5IGFib3J0IGV4ZWN1dGlvbi5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHJldHVybiB7UnVubmVyfSBSdW5uZXIgaW5zdGFuY2UuXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xcbiAgZGVidWcoJ2Fib3J0aW5nJyk7XFxuICB0aGlzLl9hYm9ydCA9IHRydWU7XFxuXFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIEZpbHRlciBsZWFrcyB3aXRoIHRoZSBnaXZlbiBnbG9iYWxzIGZsYWdnZWQgYXMgYG9rYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7QXJyYXl9IG9rXFxuICogQHBhcmFtIHtBcnJheX0gZ2xvYmFsc1xcbiAqIEByZXR1cm4ge0FycmF5fVxcbiAqL1xcbmZ1bmN0aW9uIGZpbHRlckxlYWtzKG9rLCBnbG9iYWxzKSB7XFxuICByZXR1cm4gZmlsdGVyKGdsb2JhbHMsIGZ1bmN0aW9uKGtleSkge1xcbiAgICAvLyBGaXJlZm94IGFuZCBDaHJvbWUgZXhwb3NlcyBpZnJhbWVzIGFzIGluZGV4IGluc2lkZSB0aGUgd2luZG93IG9iamVjdFxcbiAgICBpZiAoL15kKy8udGVzdChrZXkpKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuXFxuICAgIC8vIGluIGZpcmVmb3hcXG4gICAgLy8gaWYgcnVubmVyIHJ1bnMgaW4gYW4gaWZyYW1lLCB0aGlzIGlmcmFtZSdzIHdpbmRvdy5nZXRJbnRlcmZhY2UgbWV0aG9kIG5vdCBpbml0IGF0IGZpcnN0XFxuICAgIC8vIGl0IGlzIGFzc2lnbmVkIGluIHNvbWUgc2Vjb25kc1xcbiAgICBpZiAoZ2xvYmFsLm5hdmlnYXRvciAmJiAoL15nZXRJbnRlcmZhY2UvKS50ZXN0KGtleSkpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgLy8gYW4gaWZyYW1lIGNvdWxkIGJlIGFwcHJvYWNoZWQgYnkgd2luZG93W2lmcmFtZUluZGV4XVxcbiAgICAvLyBpbiBpZTYsNyw4IGFuZCBvcGVyYSwgaWZyYW1lSW5kZXggaXMgZW51bWVyYWJsZSwgdGhpcyBjb3VsZCBjYXVzZSBsZWFrXFxuICAgIGlmIChnbG9iYWwubmF2aWdhdG9yICYmICgvXlxcXFxkKy8pLnRlc3Qoa2V5KSkge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcblxcbiAgICAvLyBPcGVyYSBhbmQgSUUgZXhwb3NlIGdsb2JhbCB2YXJpYWJsZXMgZm9yIEhUTUwgZWxlbWVudCBJRHMgKGlzc3VlICMyNDMpXFxuICAgIGlmICgvXm1vY2hhLS8udGVzdChrZXkpKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuXFxuICAgIHZhciBtYXRjaGVkID0gZmlsdGVyKG9rLCBmdW5jdGlvbihvaykge1xcbiAgICAgIGlmICh+b2suaW5kZXhPZignKicpKSB7XFxuICAgICAgICByZXR1cm4ga2V5LmluZGV4T2Yob2suc3BsaXQoJyonKVswXSkgPT09IDA7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBrZXkgPT09IG9rO1xcbiAgICB9KTtcXG4gICAgcmV0dXJuICFtYXRjaGVkLmxlbmd0aCAmJiAoIWdsb2JhbC5uYXZpZ2F0b3IgfHwga2V5ICE9PSAnb25lcnJvcicpO1xcbiAgfSk7XFxufVxcblxcbi8qKlxcbiAqIEFycmF5IG9mIGdsb2JhbHMgZGVwZW5kZW50IG9uIHRoZSBlbnZpcm9ubWVudC5cXG4gKlxcbiAqIEByZXR1cm4ge0FycmF5fVxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcbmZ1bmN0aW9uIGV4dHJhR2xvYmFscygpIHtcXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHByb2Nlc3MudmVyc2lvbiA9PT0gJ3N0cmluZycpIHtcXG4gICAgdmFyIHBhcnRzID0gcHJvY2Vzcy52ZXJzaW9uLnNwbGl0KCcuJyk7XFxuICAgIHZhciBub2RlVmVyc2lvbiA9IHV0aWxzLnJlZHVjZShwYXJ0cywgZnVuY3Rpb24oYSwgdikge1xcbiAgICAgIHJldHVybiBhIDw8IDggfCB2O1xcbiAgICB9KTtcXG5cXG4gICAgLy8gJ2Vycm5vJyB3YXMgcmVuYW1lZCB0byBwcm9jZXNzLl9lcnJubyBpbiB2MC45LjExLlxcblxcbiAgICBpZiAobm9kZVZlcnNpb24gPCAweDAwMDkwQikge1xcbiAgICAgIHJldHVybiBbJ2Vycm5vJ107XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBbXTtcXG59XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSlcXG59LHtcXFwiLi9wZW5kaW5nXFxcIjoxNixcXFwiLi9ydW5uYWJsZVxcXCI6MzUsXFxcIi4vdXRpbHNcXFwiOjM5LFxcXCJfcHJvY2Vzc1xcXCI6NTEsXFxcImRlYnVnXFxcIjoyLFxcXCJldmVudHNcXFwiOjN9XSwzNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xcbnZhciBIb29rID0gcmVxdWlyZSgnLi9ob29rJyk7XFxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xcbnZhciBpbmhlcml0cyA9IHV0aWxzLmluaGVyaXRzO1xcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ21vY2hhOnN1aXRlJyk7XFxudmFyIG1pbGxpc2Vjb25kcyA9IHJlcXVpcmUoJy4vbXMnKTtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYFN1aXRlYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBTdWl0ZTtcXG5cXG4vKipcXG4gKiBDcmVhdGUgYSBuZXcgYFN1aXRlYCB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZCBwYXJlbnQgYFN1aXRlYC4gV2hlbiBhIHN1aXRlXFxuICogd2l0aCB0aGUgc2FtZSB0aXRsZSBpcyBhbHJlYWR5IHByZXNlbnQsIHRoYXQgc3VpdGUgaXMgcmV0dXJuZWQgdG8gcHJvdmlkZVxcbiAqIG5pY2VyIHJlcG9ydGVyIGFuZCBtb3JlIGZsZXhpYmxlIG1ldGEtdGVzdGluZy5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtTdWl0ZX0gcGFyZW50XFxuICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXFxuICogQHJldHVybiB7U3VpdGV9XFxuICovXFxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbihwYXJlbnQsIHRpdGxlKSB7XFxuICB2YXIgc3VpdGUgPSBuZXcgU3VpdGUodGl0bGUsIHBhcmVudC5jdHgpO1xcbiAgc3VpdGUucGFyZW50ID0gcGFyZW50O1xcbiAgaWYgKHBhcmVudC5wZW5kaW5nKSB7XFxuICAgIHN1aXRlLnBlbmRpbmcgPSB0cnVlO1xcbiAgfVxcbiAgdGl0bGUgPSBzdWl0ZS5mdWxsVGl0bGUoKTtcXG4gIHBhcmVudC5hZGRTdWl0ZShzdWl0ZSk7XFxuICByZXR1cm4gc3VpdGU7XFxufTtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBTdWl0ZWAgd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYCBhbmQgYGN0eGAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcXG4gKiBAcGFyYW0ge0NvbnRleHR9IHBhcmVudENvbnRleHRcXG4gKi9cXG5mdW5jdGlvbiBTdWl0ZSh0aXRsZSwgcGFyZW50Q29udGV4dCkge1xcbiAgdGhpcy50aXRsZSA9IHRpdGxlO1xcbiAgZnVuY3Rpb24gQ29udGV4dCgpIHt9XFxuICBDb250ZXh0LnByb3RvdHlwZSA9IHBhcmVudENvbnRleHQ7XFxuICB0aGlzLmN0eCA9IG5ldyBDb250ZXh0KCk7XFxuICB0aGlzLnN1aXRlcyA9IFtdO1xcbiAgdGhpcy50ZXN0cyA9IFtdO1xcbiAgdGhpcy5wZW5kaW5nID0gZmFsc2U7XFxuICB0aGlzLl9iZWZvcmVFYWNoID0gW107XFxuICB0aGlzLl9iZWZvcmVBbGwgPSBbXTtcXG4gIHRoaXMuX2FmdGVyRWFjaCA9IFtdO1xcbiAgdGhpcy5fYWZ0ZXJBbGwgPSBbXTtcXG4gIHRoaXMucm9vdCA9ICF0aXRsZTtcXG4gIHRoaXMuX3RpbWVvdXQgPSAyMDAwO1xcbiAgdGhpcy5fZW5hYmxlVGltZW91dHMgPSB0cnVlO1xcbiAgdGhpcy5fc2xvdyA9IDc1O1xcbiAgdGhpcy5fYmFpbCA9IGZhbHNlO1xcbiAgdGhpcy5fcmV0cmllcyA9IC0xO1xcbiAgdGhpcy5kZWxheWVkID0gZmFsc2U7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgRXZlbnRFbWl0dGVyLnByb3RvdHlwZWAuXFxuICovXFxuaW5oZXJpdHMoU3VpdGUsIEV2ZW50RW1pdHRlcik7XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgY2xvbmUgb2YgdGhpcyBgU3VpdGVgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHJldHVybiB7U3VpdGV9XFxuICovXFxuU3VpdGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XFxuICB2YXIgc3VpdGUgPSBuZXcgU3VpdGUodGhpcy50aXRsZSk7XFxuICBkZWJ1ZygnY2xvbmUnKTtcXG4gIHN1aXRlLmN0eCA9IHRoaXMuY3R4O1xcbiAgc3VpdGUudGltZW91dCh0aGlzLnRpbWVvdXQoKSk7XFxuICBzdWl0ZS5yZXRyaWVzKHRoaXMucmV0cmllcygpKTtcXG4gIHN1aXRlLmVuYWJsZVRpbWVvdXRzKHRoaXMuZW5hYmxlVGltZW91dHMoKSk7XFxuICBzdWl0ZS5zbG93KHRoaXMuc2xvdygpKTtcXG4gIHN1aXRlLmJhaWwodGhpcy5iYWlsKCkpO1xcbiAgcmV0dXJuIHN1aXRlO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IHRpbWVvdXQgYG1zYCBvciBzaG9ydC1oYW5kIHN1Y2ggYXMgXFxcIjJzXFxcIi5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gbXNcXG4gKiBAcmV0dXJuIHtTdWl0ZXxudW1iZXJ9IGZvciBjaGFpbmluZ1xcbiAqL1xcblN1aXRlLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24obXMpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fdGltZW91dDtcXG4gIH1cXG4gIGlmIChtcy50b1N0cmluZygpID09PSAnMCcpIHtcXG4gICAgdGhpcy5fZW5hYmxlVGltZW91dHMgPSBmYWxzZTtcXG4gIH1cXG4gIGlmICh0eXBlb2YgbXMgPT09ICdzdHJpbmcnKSB7XFxuICAgIG1zID0gbWlsbGlzZWNvbmRzKG1zKTtcXG4gIH1cXG4gIGRlYnVnKCd0aW1lb3V0ICVkJywgbXMpO1xcbiAgdGhpcy5fdGltZW91dCA9IHBhcnNlSW50KG1zLCAxMCk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCBudW1iZXIgb2YgdGltZXMgdG8gcmV0cnkgYSBmYWlsZWQgdGVzdC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gblxcbiAqIEByZXR1cm4ge1N1aXRlfG51bWJlcn0gZm9yIGNoYWluaW5nXFxuICovXFxuU3VpdGUucHJvdG90eXBlLnJldHJpZXMgPSBmdW5jdGlvbihuKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX3JldHJpZXM7XFxuICB9XFxuICBkZWJ1ZygncmV0cmllcyAlZCcsIG4pO1xcbiAgdGhpcy5fcmV0cmllcyA9IHBhcnNlSW50KG4sIDEwKSB8fCAwO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gICogU2V0IHRpbWVvdXQgdG8gYGVuYWJsZWRgLlxcbiAgKlxcbiAgKiBAYXBpIHByaXZhdGVcXG4gICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXFxuICAqIEByZXR1cm4ge1N1aXRlfGJvb2xlYW59IHNlbGYgb3IgZW5hYmxlZFxcbiAgKi9cXG5TdWl0ZS5wcm90b3R5cGUuZW5hYmxlVGltZW91dHMgPSBmdW5jdGlvbihlbmFibGVkKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX2VuYWJsZVRpbWVvdXRzO1xcbiAgfVxcbiAgZGVidWcoJ2VuYWJsZVRpbWVvdXRzICVzJywgZW5hYmxlZCk7XFxuICB0aGlzLl9lbmFibGVUaW1lb3V0cyA9IGVuYWJsZWQ7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCBzbG93IGBtc2Agb3Igc2hvcnQtaGFuZCBzdWNoIGFzIFxcXCIyc1xcXCIuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG1zXFxuICogQHJldHVybiB7U3VpdGV8bnVtYmVyfSBmb3IgY2hhaW5pbmdcXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUuc2xvdyA9IGZ1bmN0aW9uKG1zKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX3Nsb3c7XFxuICB9XFxuICBpZiAodHlwZW9mIG1zID09PSAnc3RyaW5nJykge1xcbiAgICBtcyA9IG1pbGxpc2Vjb25kcyhtcyk7XFxuICB9XFxuICBkZWJ1Zygnc2xvdyAlZCcsIG1zKTtcXG4gIHRoaXMuX3Nsb3cgPSBtcztcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0cyB3aGV0aGVyIHRvIGJhaWwgYWZ0ZXIgZmlyc3QgZXJyb3IuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJhaWxcXG4gKiBAcmV0dXJuIHtTdWl0ZXxudW1iZXJ9IGZvciBjaGFpbmluZ1xcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5iYWlsID0gZnVuY3Rpb24oYmFpbCkge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLl9iYWlsO1xcbiAgfVxcbiAgZGVidWcoJ2JhaWwgJXMnLCBiYWlsKTtcXG4gIHRoaXMuX2JhaWwgPSBiYWlsO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gYGZuKHRlc3RbLCBkb25lXSlgIGJlZm9yZSBydW5uaW5nIHRlc3RzLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAcmV0dXJuIHtTdWl0ZX0gZm9yIGNoYWluaW5nXFxuICovXFxuU3VpdGUucHJvdG90eXBlLmJlZm9yZUFsbCA9IGZ1bmN0aW9uKHRpdGxlLCBmbikge1xcbiAgaWYgKHRoaXMucGVuZGluZykge1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG4gIGlmICh0eXBlb2YgdGl0bGUgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgZm4gPSB0aXRsZTtcXG4gICAgdGl0bGUgPSBmbi5uYW1lO1xcbiAgfVxcbiAgdGl0bGUgPSAnXFxcImJlZm9yZSBhbGxcXFwiIGhvb2snICsgKHRpdGxlID8gJzogJyArIHRpdGxlIDogJycpO1xcblxcbiAgdmFyIGhvb2sgPSBuZXcgSG9vayh0aXRsZSwgZm4pO1xcbiAgaG9vay5wYXJlbnQgPSB0aGlzO1xcbiAgaG9vay50aW1lb3V0KHRoaXMudGltZW91dCgpKTtcXG4gIGhvb2sucmV0cmllcyh0aGlzLnJldHJpZXMoKSk7XFxuICBob29rLmVuYWJsZVRpbWVvdXRzKHRoaXMuZW5hYmxlVGltZW91dHMoKSk7XFxuICBob29rLnNsb3codGhpcy5zbG93KCkpO1xcbiAgaG9vay5jdHggPSB0aGlzLmN0eDtcXG4gIHRoaXMuX2JlZm9yZUFsbC5wdXNoKGhvb2spO1xcbiAgdGhpcy5lbWl0KCdiZWZvcmVBbGwnLCBob29rKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogUnVuIGBmbih0ZXN0WywgZG9uZV0pYCBhZnRlciBydW5uaW5nIHRlc3RzLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAcmV0dXJuIHtTdWl0ZX0gZm9yIGNoYWluaW5nXFxuICovXFxuU3VpdGUucHJvdG90eXBlLmFmdGVyQWxsID0gZnVuY3Rpb24odGl0bGUsIGZuKSB7XFxuICBpZiAodGhpcy5wZW5kaW5nKSB7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcbiAgaWYgKHR5cGVvZiB0aXRsZSA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICBmbiA9IHRpdGxlO1xcbiAgICB0aXRsZSA9IGZuLm5hbWU7XFxuICB9XFxuICB0aXRsZSA9ICdcXFwiYWZ0ZXIgYWxsXFxcIiBob29rJyArICh0aXRsZSA/ICc6ICcgKyB0aXRsZSA6ICcnKTtcXG5cXG4gIHZhciBob29rID0gbmV3IEhvb2sodGl0bGUsIGZuKTtcXG4gIGhvb2sucGFyZW50ID0gdGhpcztcXG4gIGhvb2sudGltZW91dCh0aGlzLnRpbWVvdXQoKSk7XFxuICBob29rLnJldHJpZXModGhpcy5yZXRyaWVzKCkpO1xcbiAgaG9vay5lbmFibGVUaW1lb3V0cyh0aGlzLmVuYWJsZVRpbWVvdXRzKCkpO1xcbiAgaG9vay5zbG93KHRoaXMuc2xvdygpKTtcXG4gIGhvb2suY3R4ID0gdGhpcy5jdHg7XFxuICB0aGlzLl9hZnRlckFsbC5wdXNoKGhvb2spO1xcbiAgdGhpcy5lbWl0KCdhZnRlckFsbCcsIGhvb2spO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gYGZuKHRlc3RbLCBkb25lXSlgIGJlZm9yZSBlYWNoIHRlc3QgY2FzZS5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQHJldHVybiB7U3VpdGV9IGZvciBjaGFpbmluZ1xcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5iZWZvcmVFYWNoID0gZnVuY3Rpb24odGl0bGUsIGZuKSB7XFxuICBpZiAodGhpcy5wZW5kaW5nKSB7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcbiAgaWYgKHR5cGVvZiB0aXRsZSA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICBmbiA9IHRpdGxlO1xcbiAgICB0aXRsZSA9IGZuLm5hbWU7XFxuICB9XFxuICB0aXRsZSA9ICdcXFwiYmVmb3JlIGVhY2hcXFwiIGhvb2snICsgKHRpdGxlID8gJzogJyArIHRpdGxlIDogJycpO1xcblxcbiAgdmFyIGhvb2sgPSBuZXcgSG9vayh0aXRsZSwgZm4pO1xcbiAgaG9vay5wYXJlbnQgPSB0aGlzO1xcbiAgaG9vay50aW1lb3V0KHRoaXMudGltZW91dCgpKTtcXG4gIGhvb2sucmV0cmllcyh0aGlzLnJldHJpZXMoKSk7XFxuICBob29rLmVuYWJsZVRpbWVvdXRzKHRoaXMuZW5hYmxlVGltZW91dHMoKSk7XFxuICBob29rLnNsb3codGhpcy5zbG93KCkpO1xcbiAgaG9vay5jdHggPSB0aGlzLmN0eDtcXG4gIHRoaXMuX2JlZm9yZUVhY2gucHVzaChob29rKTtcXG4gIHRoaXMuZW1pdCgnYmVmb3JlRWFjaCcsIGhvb2spO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gYGZuKHRlc3RbLCBkb25lXSlgIGFmdGVyIGVhY2ggdGVzdCBjYXNlLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAcmV0dXJuIHtTdWl0ZX0gZm9yIGNoYWluaW5nXFxuICovXFxuU3VpdGUucHJvdG90eXBlLmFmdGVyRWFjaCA9IGZ1bmN0aW9uKHRpdGxlLCBmbikge1xcbiAgaWYgKHRoaXMucGVuZGluZykge1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG4gIGlmICh0eXBlb2YgdGl0bGUgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgZm4gPSB0aXRsZTtcXG4gICAgdGl0bGUgPSBmbi5uYW1lO1xcbiAgfVxcbiAgdGl0bGUgPSAnXFxcImFmdGVyIGVhY2hcXFwiIGhvb2snICsgKHRpdGxlID8gJzogJyArIHRpdGxlIDogJycpO1xcblxcbiAgdmFyIGhvb2sgPSBuZXcgSG9vayh0aXRsZSwgZm4pO1xcbiAgaG9vay5wYXJlbnQgPSB0aGlzO1xcbiAgaG9vay50aW1lb3V0KHRoaXMudGltZW91dCgpKTtcXG4gIGhvb2sucmV0cmllcyh0aGlzLnJldHJpZXMoKSk7XFxuICBob29rLmVuYWJsZVRpbWVvdXRzKHRoaXMuZW5hYmxlVGltZW91dHMoKSk7XFxuICBob29rLnNsb3codGhpcy5zbG93KCkpO1xcbiAgaG9vay5jdHggPSB0aGlzLmN0eDtcXG4gIHRoaXMuX2FmdGVyRWFjaC5wdXNoKGhvb2spO1xcbiAgdGhpcy5lbWl0KCdhZnRlckVhY2gnLCBob29rKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogQWRkIGEgdGVzdCBgc3VpdGVgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGVcXG4gKiBAcmV0dXJuIHtTdWl0ZX0gZm9yIGNoYWluaW5nXFxuICovXFxuU3VpdGUucHJvdG90eXBlLmFkZFN1aXRlID0gZnVuY3Rpb24oc3VpdGUpIHtcXG4gIHN1aXRlLnBhcmVudCA9IHRoaXM7XFxuICBzdWl0ZS50aW1lb3V0KHRoaXMudGltZW91dCgpKTtcXG4gIHN1aXRlLnJldHJpZXModGhpcy5yZXRyaWVzKCkpO1xcbiAgc3VpdGUuZW5hYmxlVGltZW91dHModGhpcy5lbmFibGVUaW1lb3V0cygpKTtcXG4gIHN1aXRlLnNsb3codGhpcy5zbG93KCkpO1xcbiAgc3VpdGUuYmFpbCh0aGlzLmJhaWwoKSk7XFxuICB0aGlzLnN1aXRlcy5wdXNoKHN1aXRlKTtcXG4gIHRoaXMuZW1pdCgnc3VpdGUnLCBzdWl0ZSk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIEFkZCBhIGB0ZXN0YCB0byB0aGlzIHN1aXRlLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtUZXN0fSB0ZXN0XFxuICogQHJldHVybiB7U3VpdGV9IGZvciBjaGFpbmluZ1xcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5hZGRUZXN0ID0gZnVuY3Rpb24odGVzdCkge1xcbiAgdGVzdC5wYXJlbnQgPSB0aGlzO1xcbiAgdGVzdC50aW1lb3V0KHRoaXMudGltZW91dCgpKTtcXG4gIHRlc3QucmV0cmllcyh0aGlzLnJldHJpZXMoKSk7XFxuICB0ZXN0LmVuYWJsZVRpbWVvdXRzKHRoaXMuZW5hYmxlVGltZW91dHMoKSk7XFxuICB0ZXN0LnNsb3codGhpcy5zbG93KCkpO1xcbiAgdGVzdC5jdHggPSB0aGlzLmN0eDtcXG4gIHRoaXMudGVzdHMucHVzaCh0ZXN0KTtcXG4gIHRoaXMuZW1pdCgndGVzdCcsIHRlc3QpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gdGhlIGZ1bGwgdGl0bGUgZ2VuZXJhdGVkIGJ5IHJlY3Vyc2l2ZWx5IGNvbmNhdGVuYXRpbmcgdGhlIHBhcmVudCdzXFxuICogZnVsbCB0aXRsZS5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5mdWxsVGl0bGUgPSBmdW5jdGlvbigpIHtcXG4gIGlmICh0aGlzLnBhcmVudCkge1xcbiAgICB2YXIgZnVsbCA9IHRoaXMucGFyZW50LmZ1bGxUaXRsZSgpO1xcbiAgICBpZiAoZnVsbCkge1xcbiAgICAgIHJldHVybiBmdWxsICsgJyAnICsgdGhpcy50aXRsZTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIHRoaXMudGl0bGU7XFxufTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gdGhlIHRvdGFsIG51bWJlciBvZiB0ZXN0cy5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHJldHVybiB7bnVtYmVyfVxcbiAqL1xcblN1aXRlLnByb3RvdHlwZS50b3RhbCA9IGZ1bmN0aW9uKCkge1xcbiAgcmV0dXJuIHV0aWxzLnJlZHVjZSh0aGlzLnN1aXRlcywgZnVuY3Rpb24oc3VtLCBzdWl0ZSkge1xcbiAgICByZXR1cm4gc3VtICsgc3VpdGUudG90YWwoKTtcXG4gIH0sIDApICsgdGhpcy50ZXN0cy5sZW5ndGg7XFxufTtcXG5cXG4vKipcXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGVhY2ggc3VpdGUgcmVjdXJzaXZlbHkgdG8gZmluZCBhbGwgdGVzdHMuIEFwcGxpZXMgYVxcbiAqIGZ1bmN0aW9uIGluIHRoZSBmb3JtYXQgYGZuKHRlc3QpYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQHJldHVybiB7U3VpdGV9XFxuICovXFxuU3VpdGUucHJvdG90eXBlLmVhY2hUZXN0ID0gZnVuY3Rpb24oZm4pIHtcXG4gIHV0aWxzLmZvckVhY2godGhpcy50ZXN0cywgZm4pO1xcbiAgdXRpbHMuZm9yRWFjaCh0aGlzLnN1aXRlcywgZnVuY3Rpb24oc3VpdGUpIHtcXG4gICAgc3VpdGUuZWFjaFRlc3QoZm4pO1xcbiAgfSk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFRoaXMgd2lsbCBydW4gdGhlIHJvb3Qgc3VpdGUgaWYgd2UgaGFwcGVuIHRvIGJlIHJ1bm5pbmcgaW4gZGVsYXllZCBtb2RlLlxcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4oKSB7XFxuICBpZiAodGhpcy5yb290KSB7XFxuICAgIHRoaXMuZW1pdCgncnVuJyk7XFxuICB9XFxufTtcXG5cXG59LHtcXFwiLi9ob29rXFxcIjo3LFxcXCIuL21zXFxcIjoxNSxcXFwiLi91dGlsc1xcXCI6MzksXFxcImRlYnVnXFxcIjoyLFxcXCJldmVudHNcXFwiOjN9XSwzODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgUnVubmFibGUgPSByZXF1aXJlKCcuL3J1bm5hYmxlJyk7XFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi91dGlscycpLmluaGVyaXRzO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgVGVzdGAuXFxuICovXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBUZXN0O1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYFRlc3RgIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAgYW5kIGNhbGxiYWNrIGBmbmAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge1N0cmluZ30gdGl0bGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqL1xcbmZ1bmN0aW9uIFRlc3QodGl0bGUsIGZuKSB7XFxuICBSdW5uYWJsZS5jYWxsKHRoaXMsIHRpdGxlLCBmbik7XFxuICB0aGlzLnBlbmRpbmcgPSAhZm47XFxuICB0aGlzLnR5cGUgPSAndGVzdCc7XFxuICB0aGlzLmJvZHkgPSAoZm4gfHwgJycpLnRvU3RyaW5nKCk7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgUnVubmFibGUucHJvdG90eXBlYC5cXG4gKi9cXG5pbmhlcml0cyhUZXN0LCBSdW5uYWJsZSk7XFxuXFxuVGVzdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcXG4gIHZhciB0ZXN0ID0gbmV3IFRlc3QodGhpcy50aXRsZSwgdGhpcy5mbik7XFxuICB0ZXN0LnRpbWVvdXQodGhpcy50aW1lb3V0KCkpO1xcbiAgdGVzdC5zbG93KHRoaXMuc2xvdygpKTtcXG4gIHRlc3QuZW5hYmxlVGltZW91dHModGhpcy5lbmFibGVUaW1lb3V0cygpKTtcXG4gIHRlc3QucmV0cmllcyh0aGlzLnJldHJpZXMoKSk7XFxuICB0ZXN0LmN1cnJlbnRSZXRyeSh0aGlzLmN1cnJlbnRSZXRyeSgpKTtcXG4gIHRlc3QuZ2xvYmFscyh0aGlzLmdsb2JhbHMoKSk7XFxuICB0ZXN0LnBhcmVudCA9IHRoaXMucGFyZW50O1xcbiAgdGVzdC5maWxlID0gdGhpcy5maWxlO1xcbiAgdGVzdC5jdHggPSB0aGlzLmN0eDtcXG4gIHJldHVybiB0ZXN0O1xcbn07XFxuXFxufSx7XFxcIi4vcnVubmFibGVcXFwiOjM1LFxcXCIuL3V0aWxzXFxcIjozOX1dLDM5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3MsQnVmZmVyKXtcXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cXG5cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBiYXNlbmFtZSA9IHJlcXVpcmUoJ3BhdGgnKS5iYXNlbmFtZTtcXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdtb2NoYTp3YXRjaCcpO1xcbnZhciBleGlzdHMgPSByZXF1aXJlKCdmcycpLmV4aXN0c1N5bmMgfHwgcmVxdWlyZSgncGF0aCcpLmV4aXN0c1N5bmM7XFxudmFyIGdsb2IgPSByZXF1aXJlKCdnbG9iJyk7XFxudmFyIGpvaW4gPSByZXF1aXJlKCdwYXRoJykuam9pbjtcXG52YXIgcmVhZGRpclN5bmMgPSByZXF1aXJlKCdmcycpLnJlYWRkaXJTeW5jO1xcbnZhciBzdGF0U3luYyA9IHJlcXVpcmUoJ2ZzJykuc3RhdFN5bmM7XFxudmFyIHdhdGNoRmlsZSA9IHJlcXVpcmUoJ2ZzJykud2F0Y2hGaWxlO1xcblxcbi8qKlxcbiAqIElnbm9yZWQgZGlyZWN0b3JpZXMuXFxuICovXFxuXFxudmFyIGlnbm9yZSA9IFsnbm9kZV9tb2R1bGVzJywgJy5naXQnXTtcXG5cXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xcblxcbi8qKlxcbiAqIEVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gdGhlIGdpdmVuIHN0cmluZyBvZiBodG1sLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtICB7c3RyaW5nfSBodG1sXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmV4cG9ydHMuZXNjYXBlID0gZnVuY3Rpb24oaHRtbCkge1xcbiAgcmV0dXJuIFN0cmluZyhodG1sKVxcbiAgICAucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxcbiAgICAucmVwbGFjZSgvXFxcIi9nLCAnJnF1b3Q7JylcXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xcbn07XFxuXFxuLyoqXFxuICogQXJyYXkjZm9yRWFjaCAoPD1JRTgpXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZVxcbiAqL1xcbmV4cG9ydHMuZm9yRWFjaCA9IGZ1bmN0aW9uKGFyciwgZm4sIHNjb3BlKSB7XFxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgZm4uY2FsbChzY29wZSwgYXJyW2ldLCBpKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIFRlc3QgaWYgdGhlIGdpdmVuIG9iaiBpcyB0eXBlIG9mIHN0cmluZy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcXG4gKiBAcmV0dXJuIHtib29sZWFufVxcbiAqL1xcbmV4cG9ydHMuaXNTdHJpbmcgPSBmdW5jdGlvbihvYmopIHtcXG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSAnc3RyaW5nJztcXG59O1xcblxcbi8qKlxcbiAqIEFycmF5I21hcCAoPD1JRTgpXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZVxcbiAqIEByZXR1cm4ge0FycmF5fVxcbiAqL1xcbmV4cG9ydHMubWFwID0gZnVuY3Rpb24oYXJyLCBmbiwgc2NvcGUpIHtcXG4gIHZhciByZXN1bHQgPSBbXTtcXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xcbiAgICByZXN1bHQucHVzaChmbi5jYWxsKHNjb3BlLCBhcnJbaV0sIGksIGFycikpO1xcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59O1xcblxcbi8qKlxcbiAqIEFycmF5I2luZGV4T2YgKDw9SUU4KVxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtBcnJheX0gYXJyXFxuICogQHBhcmFtIHtPYmplY3R9IG9iaiB0byBmaW5kIGluZGV4IG9mXFxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XFxuICogQHJldHVybiB7bnVtYmVyfVxcbiAqL1xcbmV4cG9ydHMuaW5kZXhPZiA9IGZ1bmN0aW9uKGFyciwgb2JqLCBzdGFydCkge1xcbiAgZm9yICh2YXIgaSA9IHN0YXJ0IHx8IDAsIGwgPSBhcnIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgIGlmIChhcnJbaV0gPT09IG9iaikge1xcbiAgICAgIHJldHVybiBpO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gLTE7XFxufTtcXG5cXG4vKipcXG4gKiBBcnJheSNyZWR1Y2UgKDw9SUU4KVxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtBcnJheX0gYXJyXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIEluaXRpYWwgdmFsdWUuXFxuICogQHJldHVybiB7Kn1cXG4gKi9cXG5leHBvcnRzLnJlZHVjZSA9IGZ1bmN0aW9uKGFyciwgZm4sIHZhbCkge1xcbiAgdmFyIHJ2YWwgPSB2YWw7XFxuXFxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgcnZhbCA9IGZuKHJ2YWwsIGFycltpXSwgaSwgYXJyKTtcXG4gIH1cXG5cXG4gIHJldHVybiBydmFsO1xcbn07XFxuXFxuLyoqXFxuICogQXJyYXkjZmlsdGVyICg8PUlFOClcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQHJldHVybiB7QXJyYXl9XFxuICovXFxuZXhwb3J0cy5maWx0ZXIgPSBmdW5jdGlvbihhcnIsIGZuKSB7XFxuICB2YXIgcmV0ID0gW107XFxuXFxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgdmFyIHZhbCA9IGFycltpXTtcXG4gICAgaWYgKGZuKHZhbCwgaSwgYXJyKSkge1xcbiAgICAgIHJldC5wdXNoKHZhbCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiByZXQ7XFxufTtcXG5cXG4vKipcXG4gKiBPYmplY3Qua2V5cyAoPD1JRTgpXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXFxuICogQHJldHVybiB7QXJyYXl9IGtleXNcXG4gKi9cXG5leHBvcnRzLmtleXMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3Qua2V5cyA6IGZ1bmN0aW9uKG9iaikge1xcbiAgdmFyIGtleXMgPSBbXTtcXG4gIHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5OyAvLyBmb3IgYHdpbmRvd2Agb24gPD1JRThcXG5cXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcXG4gICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xcbiAgICAgIGtleXMucHVzaChrZXkpO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4ga2V5cztcXG59O1xcblxcbi8qKlxcbiAqIFdhdGNoIHRoZSBnaXZlbiBgZmlsZXNgIGZvciBjaGFuZ2VzXFxuICogYW5kIGludm9rZSBgZm4oZmlsZSlgIG9uIG1vZGlmaWNhdGlvbi5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7QXJyYXl9IGZpbGVzXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKi9cXG5leHBvcnRzLndhdGNoID0gZnVuY3Rpb24oZmlsZXMsIGZuKSB7XFxuICB2YXIgb3B0aW9ucyA9IHsgaW50ZXJ2YWw6IDEwMCB9O1xcbiAgZmlsZXMuZm9yRWFjaChmdW5jdGlvbihmaWxlKSB7XFxuICAgIGRlYnVnKCdmaWxlICVzJywgZmlsZSk7XFxuICAgIHdhdGNoRmlsZShmaWxlLCBvcHRpb25zLCBmdW5jdGlvbihjdXJyLCBwcmV2KSB7XFxuICAgICAgaWYgKHByZXYubXRpbWUgPCBjdXJyLm10aW1lKSB7XFxuICAgICAgICBmbihmaWxlKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfSk7XFxufTtcXG5cXG4vKipcXG4gKiBBcnJheS5pc0FycmF5ICg8PUlFOClcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcXG4gKiBAcmV0dXJuIHtCb29sZWFufVxcbiAqL1xcbnZhciBpc0FycmF5ID0gdHlwZW9mIEFycmF5LmlzQXJyYXkgPT09ICdmdW5jdGlvbicgPyBBcnJheS5pc0FycmF5IDogZnVuY3Rpb24ob2JqKSB7XFxuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XFxufTtcXG5cXG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xcblxcbi8qKlxcbiAqIEJ1ZmZlci5wcm90b3R5cGUudG9KU09OIHBvbHlmaWxsLlxcbiAqXFxuICogQHR5cGUge0Z1bmN0aW9ufVxcbiAqL1xcbmlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBCdWZmZXIucHJvdG90eXBlKSB7XFxuICBCdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IEJ1ZmZlci5wcm90b3R5cGUudG9KU09OIHx8IGZ1bmN0aW9uKCkge1xcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcywgMCk7XFxuICB9O1xcbn1cXG5cXG4vKipcXG4gKiBJZ25vcmVkIGZpbGVzLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcXG4gKiBAcmV0dXJuIHtib29sZWFufVxcbiAqL1xcbmZ1bmN0aW9uIGlnbm9yZWQocGF0aCkge1xcbiAgcmV0dXJuICF+aWdub3JlLmluZGV4T2YocGF0aCk7XFxufVxcblxcbi8qKlxcbiAqIExvb2t1cCBmaWxlcyBpbiB0aGUgZ2l2ZW4gYGRpcmAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlyXFxuICogQHBhcmFtIHtzdHJpbmdbXX0gW2V4dD1bJy5qcyddXVxcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXQ9W11dXFxuICogQHJldHVybiB7QXJyYXl9XFxuICovXFxuZXhwb3J0cy5maWxlcyA9IGZ1bmN0aW9uKGRpciwgZXh0LCByZXQpIHtcXG4gIHJldCA9IHJldCB8fCBbXTtcXG4gIGV4dCA9IGV4dCB8fCBbJ2pzJ107XFxuXFxuICB2YXIgcmUgPSBuZXcgUmVnRXhwKCdcXFxcXFxcXC4oJyArIGV4dC5qb2luKCd8JykgKyAnKSQnKTtcXG5cXG4gIHJlYWRkaXJTeW5jKGRpcilcXG4gICAgLmZpbHRlcihpZ25vcmVkKVxcbiAgICAuZm9yRWFjaChmdW5jdGlvbihwYXRoKSB7XFxuICAgICAgcGF0aCA9IGpvaW4oZGlyLCBwYXRoKTtcXG4gICAgICBpZiAoc3RhdFN5bmMocGF0aCkuaXNEaXJlY3RvcnkoKSkge1xcbiAgICAgICAgZXhwb3J0cy5maWxlcyhwYXRoLCBleHQsIHJldCk7XFxuICAgICAgfSBlbHNlIGlmIChwYXRoLm1hdGNoKHJlKSkge1xcbiAgICAgICAgcmV0LnB1c2gocGF0aCk7XFxuICAgICAgfVxcbiAgICB9KTtcXG5cXG4gIHJldHVybiByZXQ7XFxufTtcXG5cXG4vKipcXG4gKiBDb21wdXRlIGEgc2x1ZyBmcm9tIHRoZSBnaXZlbiBgc3RyYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZXhwb3J0cy5zbHVnID0gZnVuY3Rpb24oc3RyKSB7XFxuICByZXR1cm4gc3RyXFxuICAgIC50b0xvd2VyQ2FzZSgpXFxuICAgIC5yZXBsYWNlKC8gKy9nLCAnLScpXFxuICAgIC5yZXBsYWNlKC9bXi1cXFxcd10vZywgJycpO1xcbn07XFxuXFxuLyoqXFxuICogU3RyaXAgdGhlIGZ1bmN0aW9uIGRlZmluaXRpb24gZnJvbSBgc3RyYCwgYW5kIHJlLWluZGVudCBmb3IgcHJlIHdoaXRlc3BhY2UuXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmV4cG9ydHMuY2xlYW4gPSBmdW5jdGlvbihzdHIpIHtcXG4gIHN0ciA9IHN0clxcbiAgICAucmVwbGFjZSgvXFxcXHJcXFxcbj98W1xcXFxuXFxcXHUyMDI4XFxcXHUyMDI5XS9nLCAnXFxcXG4nKS5yZXBsYWNlKC9eXFxcXHVGRUZGLywgJycpXFxuICAgIC5yZXBsYWNlKC9eZnVuY3Rpb24gKlxcXFwoLipcXFxcKVxcXFxzKlxcXFx7fFxcXFwoLipcXFxcKSAqPT4gKlxcXFx7Py8sICcnKVxcbiAgICAucmVwbGFjZSgvXFxcXHMrXFxcXH0kLywgJycpO1xcblxcbiAgdmFyIHNwYWNlcyA9IHN0ci5tYXRjaCgvXlxcXFxuPyggKikvKVsxXS5sZW5ndGg7XFxuICB2YXIgdGFicyA9IHN0ci5tYXRjaCgvXlxcXFxuPyhcXFxcdCopLylbMV0ubGVuZ3RoO1xcbiAgdmFyIHJlID0gbmV3IFJlZ0V4cCgnXlxcXFxuPycgKyAodGFicyA/ICdcXFxcdCcgOiAnICcpICsgJ3snICsgKHRhYnMgPyB0YWJzIDogc3BhY2VzKSArICd9JywgJ2dtJyk7XFxuXFxuICBzdHIgPSBzdHIucmVwbGFjZShyZSwgJycpO1xcblxcbiAgcmV0dXJuIGV4cG9ydHMudHJpbShzdHIpO1xcbn07XFxuXFxuLyoqXFxuICogVHJpbSB0aGUgZ2l2ZW4gYHN0cmAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmV4cG9ydHMudHJpbSA9IGZ1bmN0aW9uKHN0cikge1xcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxcXHMrfFxcXFxzKyQvZywgJycpO1xcbn07XFxuXFxuLyoqXFxuICogUGFyc2UgdGhlIGdpdmVuIGBxc2AuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gcXNcXG4gKiBAcmV0dXJuIHtPYmplY3R9XFxuICovXFxuZXhwb3J0cy5wYXJzZVF1ZXJ5ID0gZnVuY3Rpb24ocXMpIHtcXG4gIHJldHVybiBleHBvcnRzLnJlZHVjZShxcy5yZXBsYWNlKCc/JywgJycpLnNwbGl0KCcmJyksIGZ1bmN0aW9uKG9iaiwgcGFpcikge1xcbiAgICB2YXIgaSA9IHBhaXIuaW5kZXhPZignPScpO1xcbiAgICB2YXIga2V5ID0gcGFpci5zbGljZSgwLCBpKTtcXG4gICAgdmFyIHZhbCA9IHBhaXIuc2xpY2UoKytpKTtcXG5cXG4gICAgb2JqW2tleV0gPSBkZWNvZGVVUklDb21wb25lbnQodmFsKTtcXG4gICAgcmV0dXJuIG9iajtcXG4gIH0sIHt9KTtcXG59O1xcblxcbi8qKlxcbiAqIEhpZ2hsaWdodCB0aGUgZ2l2ZW4gc3RyaW5nIG9mIGBqc2AuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30ganNcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZnVuY3Rpb24gaGlnaGxpZ2h0KGpzKSB7XFxuICByZXR1cm4ganNcXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXFxuICAgIC5yZXBsYWNlKC9cXFxcL1xcXFwvKC4qKS9nbSwgJzxzcGFuIGNsYXNzPVxcXCJjb21tZW50XFxcIj4vLyQxPC9zcGFuPicpXFxuICAgIC5yZXBsYWNlKC8oJy4qPycpL2dtLCAnPHNwYW4gY2xhc3M9XFxcInN0cmluZ1xcXCI+JDE8L3NwYW4+JylcXG4gICAgLnJlcGxhY2UoLyhcXFxcZCtcXFxcLlxcXFxkKykvZ20sICc8c3BhbiBjbGFzcz1cXFwibnVtYmVyXFxcIj4kMTwvc3Bhbj4nKVxcbiAgICAucmVwbGFjZSgvKFxcXFxkKykvZ20sICc8c3BhbiBjbGFzcz1cXFwibnVtYmVyXFxcIj4kMTwvc3Bhbj4nKVxcbiAgICAucmVwbGFjZSgvXFxcXGJuZXdbIFxcXFx0XSsoXFxcXHcrKS9nbSwgJzxzcGFuIGNsYXNzPVxcXCJrZXl3b3JkXFxcIj5uZXc8L3NwYW4+IDxzcGFuIGNsYXNzPVxcXCJpbml0XFxcIj4kMTwvc3Bhbj4nKVxcbiAgICAucmVwbGFjZSgvXFxcXGIoZnVuY3Rpb258bmV3fHRocm93fHJldHVybnx2YXJ8aWZ8ZWxzZSlcXFxcYi9nbSwgJzxzcGFuIGNsYXNzPVxcXCJrZXl3b3JkXFxcIj4kMTwvc3Bhbj4nKTtcXG59XFxuXFxuLyoqXFxuICogSGlnaGxpZ2h0IHRoZSBjb250ZW50cyBvZiB0YWcgYG5hbWVgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcXG4gKi9cXG5leHBvcnRzLmhpZ2hsaWdodFRhZ3MgPSBmdW5jdGlvbihuYW1lKSB7XFxuICB2YXIgY29kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2NoYScpLmdldEVsZW1lbnRzQnlUYWdOYW1lKG5hbWUpO1xcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcXG4gICAgY29kZVtpXS5pbm5lckhUTUwgPSBoaWdobGlnaHQoY29kZVtpXS5pbm5lckhUTUwpO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogSWYgYSB2YWx1ZSBjb3VsZCBoYXZlIHByb3BlcnRpZXMsIGFuZCBoYXMgbm9uZSwgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQsXFxuICogd2hpY2ggcmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZW1wdHkgdmFsdWUuXFxuICpcXG4gKiBGdW5jdGlvbnMgdy8gbm8gcHJvcGVydGllcyByZXR1cm4gYCdbRnVuY3Rpb25dJ2BcXG4gKiBBcnJheXMgdy8gbGVuZ3RoID09PSAwIHJldHVybiBgJ1tdJ2BcXG4gKiBPYmplY3RzIHcvIG5vIHByb3BlcnRpZXMgcmV0dXJuIGAne30nYFxcbiAqIEFsbCBlbHNlOiByZXR1cm4gcmVzdWx0IG9mIGB2YWx1ZS50b1N0cmluZygpYFxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSwgaWYga25vd24uXFxuICogQHJldHVybnMge3N0cmluZ31cXG4gKi9cXG5mdW5jdGlvbiBlbXB0eVJlcHJlc2VudGF0aW9uKHZhbHVlLCB0eXBlKSB7XFxuICB0eXBlID0gdHlwZSB8fCBleHBvcnRzLnR5cGUodmFsdWUpO1xcblxcbiAgc3dpdGNoICh0eXBlKSB7XFxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcXG4gICAgICByZXR1cm4gJ1tGdW5jdGlvbl0nO1xcbiAgICBjYXNlICdvYmplY3QnOlxcbiAgICAgIHJldHVybiAne30nO1xcbiAgICBjYXNlICdhcnJheSc6XFxuICAgICAgcmV0dXJuICdbXSc7XFxuICAgIGRlZmF1bHQ6XFxuICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIFRha2VzIHNvbWUgdmFyaWFibGUgYW5kIGFza3MgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKWAgd2hhdCBpdCB0aGlua3MgaXRcXG4gKiBpcy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L3RvU3RyaW5nXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdC5cXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxcbiAqIEBleGFtcGxlXFxuICogdHlwZSh7fSkgLy8gJ29iamVjdCdcXG4gKiB0eXBlKFtdKSAvLyAnYXJyYXknXFxuICogdHlwZSgxKSAvLyAnbnVtYmVyJ1xcbiAqIHR5cGUoZmFsc2UpIC8vICdib29sZWFuJ1xcbiAqIHR5cGUoSW5maW5pdHkpIC8vICdudW1iZXInXFxuICogdHlwZShudWxsKSAvLyAnbnVsbCdcXG4gKiB0eXBlKG5ldyBEYXRlKCkpIC8vICdkYXRlJ1xcbiAqIHR5cGUoL2Zvby8pIC8vICdyZWdleHAnXFxuICogdHlwZSgndHlwZScpIC8vICdzdHJpbmcnXFxuICogdHlwZShnbG9iYWwpIC8vICdnbG9iYWwnXFxuICovXFxuZXhwb3J0cy50eXBlID0gZnVuY3Rpb24gdHlwZSh2YWx1ZSkge1xcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcXG4gICAgcmV0dXJuICd1bmRlZmluZWQnO1xcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xcbiAgICByZXR1cm4gJ251bGwnO1xcbiAgfSBlbHNlIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XFxuICAgIHJldHVybiAnYnVmZmVyJztcXG4gIH1cXG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpXFxuICAgIC5yZXBsYWNlKC9eXFxcXFsuK1xcXFxzKC4rPylcXFxcXSQvLCAnJDEnKVxcbiAgICAudG9Mb3dlckNhc2UoKTtcXG59O1xcblxcbi8qKlxcbiAqIFN0cmluZ2lmeSBgdmFsdWVgLiBEaWZmZXJlbnQgYmVoYXZpb3IgZGVwZW5kaW5nIG9uIHR5cGUgb2YgdmFsdWU6XFxuICpcXG4gKiAtIElmIGB2YWx1ZWAgaXMgdW5kZWZpbmVkIG9yIG51bGwsIHJldHVybiBgJ1t1bmRlZmluZWRdJ2Agb3IgYCdbbnVsbF0nYCwgcmVzcGVjdGl2ZWx5LlxcbiAqIC0gSWYgYHZhbHVlYCBpcyBub3QgYW4gb2JqZWN0LCBmdW5jdGlvbiBvciBhcnJheSwgcmV0dXJuIHJlc3VsdCBvZiBgdmFsdWUudG9TdHJpbmcoKWAgd3JhcHBlZCBpbiBkb3VibGUtcXVvdGVzLlxcbiAqIC0gSWYgYHZhbHVlYCBpcyBhbiAqZW1wdHkqIG9iamVjdCwgZnVuY3Rpb24sIG9yIGFycmF5LCByZXR1cm4gcmVzdWx0IG9mIGZ1bmN0aW9uXFxuICogICB7QGxpbmsgZW1wdHlSZXByZXNlbnRhdGlvbn0uXFxuICogLSBJZiBgdmFsdWVgIGhhcyBwcm9wZXJ0aWVzLCBjYWxsIHtAbGluayBleHBvcnRzLmNhbm9uaWNhbGl6ZX0gb24gaXQsIHRoZW4gcmV0dXJuIHJlc3VsdCBvZlxcbiAqICAgSlNPTi5zdHJpbmdpZnkoKS5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBzZWUgZXhwb3J0cy50eXBlXFxuICogQHBhcmFtIHsqfSB2YWx1ZVxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5leHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uKHZhbHVlKSB7XFxuICB2YXIgdHlwZSA9IGV4cG9ydHMudHlwZSh2YWx1ZSk7XFxuXFxuICBpZiAoIX5leHBvcnRzLmluZGV4T2YoWydvYmplY3QnLCAnYXJyYXknLCAnZnVuY3Rpb24nXSwgdHlwZSkpIHtcXG4gICAgaWYgKHR5cGUgIT09ICdidWZmZXInKSB7XFxuICAgICAgcmV0dXJuIGpzb25TdHJpbmdpZnkodmFsdWUpO1xcbiAgICB9XFxuICAgIHZhciBqc29uID0gdmFsdWUudG9KU09OKCk7XFxuICAgIC8vIEJhc2VkIG9uIHRoZSB0b0pTT04gcmVzdWx0XFxuICAgIHJldHVybiBqc29uU3RyaW5naWZ5KGpzb24uZGF0YSAmJiBqc29uLnR5cGUgPyBqc29uLmRhdGEgOiBqc29uLCAyKVxcbiAgICAgIC5yZXBsYWNlKC8sKFxcXFxufCQpL2csICckMScpO1xcbiAgfVxcblxcbiAgZm9yICh2YXIgcHJvcCBpbiB2YWx1ZSkge1xcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBwcm9wKSkge1xcbiAgICAgIHJldHVybiBqc29uU3RyaW5naWZ5KGV4cG9ydHMuY2Fub25pY2FsaXplKHZhbHVlKSwgMikucmVwbGFjZSgvLChcXFxcbnwkKS9nLCAnJDEnKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIGVtcHR5UmVwcmVzZW50YXRpb24odmFsdWUsIHR5cGUpO1xcbn07XFxuXFxuLyoqXFxuICogbGlrZSBKU09OLnN0cmluZ2lmeSBidXQgbW9yZSBzZW5zZS5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7T2JqZWN0fSAgb2JqZWN0XFxuICogQHBhcmFtIHtudW1iZXI9fSBzcGFjZXNcXG4gKiBAcGFyYW0ge251bWJlcj19IGRlcHRoXFxuICogQHJldHVybnMgeyp9XFxuICovXFxuZnVuY3Rpb24ganNvblN0cmluZ2lmeShvYmplY3QsIHNwYWNlcywgZGVwdGgpIHtcXG4gIGlmICh0eXBlb2Ygc3BhY2VzID09PSAndW5kZWZpbmVkJykge1xcbiAgICAvLyBwcmltaXRpdmUgdHlwZXNcXG4gICAgcmV0dXJuIF9zdHJpbmdpZnkob2JqZWN0KTtcXG4gIH1cXG5cXG4gIGRlcHRoID0gZGVwdGggfHwgMTtcXG4gIHZhciBzcGFjZSA9IHNwYWNlcyAqIGRlcHRoO1xcbiAgdmFyIHN0ciA9IGlzQXJyYXkob2JqZWN0KSA/ICdbJyA6ICd7JztcXG4gIHZhciBlbmQgPSBpc0FycmF5KG9iamVjdCkgPyAnXScgOiAnfSc7XFxuICB2YXIgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aCB8fCBleHBvcnRzLmtleXMob2JqZWN0KS5sZW5ndGg7XFxuICAvLyBgLnJlcGVhdCgpYCBwb2x5ZmlsbFxcbiAgZnVuY3Rpb24gcmVwZWF0KHMsIG4pIHtcXG4gICAgcmV0dXJuIG5ldyBBcnJheShuKS5qb2luKHMpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gX3N0cmluZ2lmeSh2YWwpIHtcXG4gICAgc3dpdGNoIChleHBvcnRzLnR5cGUodmFsKSkge1xcbiAgICAgIGNhc2UgJ251bGwnOlxcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XFxuICAgICAgICB2YWwgPSAnWycgKyB2YWwgKyAnXSc7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlICdhcnJheSc6XFxuICAgICAgY2FzZSAnb2JqZWN0JzpcXG4gICAgICAgIHZhbCA9IGpzb25TdHJpbmdpZnkodmFsLCBzcGFjZXMsIGRlcHRoICsgMSk7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlICdib29sZWFuJzpcXG4gICAgICBjYXNlICdyZWdleHAnOlxcbiAgICAgIGNhc2UgJ251bWJlcic6XFxuICAgICAgICB2YWwgPSB2YWwgPT09IDAgJiYgKDEgLyB2YWwpID09PSAtSW5maW5pdHkgLy8gYC0wYFxcbiAgICAgICAgICA/ICctMCdcXG4gICAgICAgICAgOiB2YWwudG9TdHJpbmcoKTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgJ2RhdGUnOlxcbiAgICAgICAgdmFyIHNEYXRlID0gaXNOYU4odmFsLmdldFRpbWUoKSkgICAgICAgIC8vIEludmFsaWQgZGF0ZVxcbiAgICAgICAgICA/IHZhbC50b1N0cmluZygpXFxuICAgICAgICAgIDogdmFsLnRvSVNPU3RyaW5nKCk7XFxuICAgICAgICB2YWwgPSAnW0RhdGU6ICcgKyBzRGF0ZSArICddJztcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgJ2J1ZmZlcic6XFxuICAgICAgICB2YXIganNvbiA9IHZhbC50b0pTT04oKTtcXG4gICAgICAgIC8vIEJhc2VkIG9uIHRoZSB0b0pTT04gcmVzdWx0XFxuICAgICAgICBqc29uID0ganNvbi5kYXRhICYmIGpzb24udHlwZSA/IGpzb24uZGF0YSA6IGpzb247XFxuICAgICAgICB2YWwgPSAnW0J1ZmZlcjogJyArIGpzb25TdHJpbmdpZnkoanNvbiwgMiwgZGVwdGggKyAxKSArICddJztcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGRlZmF1bHQ6XFxuICAgICAgICB2YWwgPSAodmFsID09PSAnW0Z1bmN0aW9uXScgfHwgdmFsID09PSAnW0NpcmN1bGFyXScpXFxuICAgICAgICAgID8gdmFsXFxuICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkodmFsKTsgLy8gc3RyaW5nXFxuICAgIH1cXG4gICAgcmV0dXJuIHZhbDtcXG4gIH1cXG5cXG4gIGZvciAodmFyIGkgaW4gb2JqZWN0KSB7XFxuICAgIGlmICghb2JqZWN0Lmhhc093blByb3BlcnR5KGkpKSB7XFxuICAgICAgY29udGludWU7IC8vIG5vdCBteSBidXNpbmVzc1xcbiAgICB9XFxuICAgIC0tbGVuZ3RoO1xcbiAgICBzdHIgKz0gJ1xcXFxuICcgKyByZXBlYXQoJyAnLCBzcGFjZSlcXG4gICAgICArIChpc0FycmF5KG9iamVjdCkgPyAnJyA6ICdcXFwiJyArIGkgKyAnXFxcIjogJykgLy8ga2V5XFxuICAgICAgKyBfc3RyaW5naWZ5KG9iamVjdFtpXSkgICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZVxcbiAgICAgICsgKGxlbmd0aCA/ICcsJyA6ICcnKTsgICAgICAgICAgICAgICAgICAgICAvLyBjb21tYVxcbiAgfVxcblxcbiAgcmV0dXJuIHN0clxcbiAgICAvLyBbXSwge31cXG4gICAgKyAoc3RyLmxlbmd0aCAhPT0gMSA/ICdcXFxcbicgKyByZXBlYXQoJyAnLCAtLXNwYWNlKSArIGVuZCA6IGVuZCk7XFxufVxcblxcbi8qKlxcbiAqIFRlc3QgaWYgYSB2YWx1ZSBpcyBhIGJ1ZmZlci5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3QuXFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcXG4gKi9cXG5leHBvcnRzLmlzQnVmZmVyID0gZnVuY3Rpb24odmFsdWUpIHtcXG4gIHJldHVybiB0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBCdWZmZXIuaXNCdWZmZXIodmFsdWUpO1xcbn07XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgbmV3IFRoaW5nIHRoYXQgaGFzIHRoZSBrZXlzIGluIHNvcnRlZCBvcmRlci4gUmVjdXJzaXZlLlxcbiAqXFxuICogSWYgdGhlIFRoaW5nLi4uXFxuICogLSBoYXMgYWxyZWFkeSBiZWVuIHNlZW4sIHJldHVybiBzdHJpbmcgYCdbQ2lyY3VsYXJdJ2BcXG4gKiAtIGlzIGB1bmRlZmluZWRgLCByZXR1cm4gc3RyaW5nIGAnW3VuZGVmaW5lZF0nYFxcbiAqIC0gaXMgYG51bGxgLCByZXR1cm4gdmFsdWUgYG51bGxgXFxuICogLSBpcyBzb21lIG90aGVyIHByaW1pdGl2ZSwgcmV0dXJuIHRoZSB2YWx1ZVxcbiAqIC0gaXMgbm90IGEgcHJpbWl0aXZlIG9yIGFuIGBBcnJheWAsIGBPYmplY3RgLCBvciBgRnVuY3Rpb25gLCByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBUaGluZydzIGB0b1N0cmluZygpYCBtZXRob2RcXG4gKiAtIGlzIGEgbm9uLWVtcHR5IGBBcnJheWAsIGBPYmplY3RgLCBvciBgRnVuY3Rpb25gLCByZXR1cm4gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoaXMgZnVuY3Rpb24gYWdhaW4uXFxuICogLSBpcyBhbiBlbXB0eSBgQXJyYXlgLCBgT2JqZWN0YCwgb3IgYEZ1bmN0aW9uYCwgcmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZW1wdHlSZXByZXNlbnRhdGlvbigpYFxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHNlZSB7QGxpbmsgZXhwb3J0cy5zdHJpbmdpZnl9XFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGluZyB0byBpbnNwZWN0LiAgTWF5IG9yIG1heSBub3QgaGF2ZSBwcm9wZXJ0aWVzLlxcbiAqIEBwYXJhbSB7QXJyYXl9IFtzdGFjaz1bXV0gU3RhY2sgb2Ygc2VlbiB2YWx1ZXNcXG4gKiBAcmV0dXJuIHsoT2JqZWN0fEFycmF5fEZ1bmN0aW9ufHN0cmluZ3x1bmRlZmluZWQpfVxcbiAqL1xcbmV4cG9ydHMuY2Fub25pY2FsaXplID0gZnVuY3Rpb24odmFsdWUsIHN0YWNrKSB7XFxuICB2YXIgY2Fub25pY2FsaXplZE9iajtcXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXFxuICB2YXIgcHJvcDtcXG4gIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cXG4gIHZhciB0eXBlID0gZXhwb3J0cy50eXBlKHZhbHVlKTtcXG4gIGZ1bmN0aW9uIHdpdGhTdGFjayh2YWx1ZSwgZm4pIHtcXG4gICAgc3RhY2sucHVzaCh2YWx1ZSk7XFxuICAgIGZuKCk7XFxuICAgIHN0YWNrLnBvcCgpO1xcbiAgfVxcblxcbiAgc3RhY2sgPSBzdGFjayB8fCBbXTtcXG5cXG4gIGlmIChleHBvcnRzLmluZGV4T2Yoc3RhY2ssIHZhbHVlKSAhPT0gLTEpIHtcXG4gICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcXG4gIH1cXG5cXG4gIHN3aXRjaCAodHlwZSkge1xcbiAgICBjYXNlICd1bmRlZmluZWQnOlxcbiAgICBjYXNlICdidWZmZXInOlxcbiAgICBjYXNlICdudWxsJzpcXG4gICAgICBjYW5vbmljYWxpemVkT2JqID0gdmFsdWU7XFxuICAgICAgYnJlYWs7XFxuICAgIGNhc2UgJ2FycmF5JzpcXG4gICAgICB3aXRoU3RhY2sodmFsdWUsIGZ1bmN0aW9uKCkge1xcbiAgICAgICAgY2Fub25pY2FsaXplZE9iaiA9IGV4cG9ydHMubWFwKHZhbHVlLCBmdW5jdGlvbihpdGVtKSB7XFxuICAgICAgICAgIHJldHVybiBleHBvcnRzLmNhbm9uaWNhbGl6ZShpdGVtLCBzdGFjayk7XFxuICAgICAgICB9KTtcXG4gICAgICB9KTtcXG4gICAgICBicmVhaztcXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIGd1YXJkLWZvci1pbiAqL1xcbiAgICAgIGZvciAocHJvcCBpbiB2YWx1ZSkge1xcbiAgICAgICAgY2Fub25pY2FsaXplZE9iaiA9IHt9O1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcbiAgICAgIC8qIGVzbGludC1lbmFibGUgZ3VhcmQtZm9yLWluICovXFxuICAgICAgaWYgKCFjYW5vbmljYWxpemVkT2JqKSB7XFxuICAgICAgICBjYW5vbmljYWxpemVkT2JqID0gZW1wdHlSZXByZXNlbnRhdGlvbih2YWx1ZSwgdHlwZSk7XFxuICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cXG4gICAgY2FzZSAnb2JqZWN0JzpcXG4gICAgICBjYW5vbmljYWxpemVkT2JqID0gY2Fub25pY2FsaXplZE9iaiB8fCB7fTtcXG4gICAgICB3aXRoU3RhY2sodmFsdWUsIGZ1bmN0aW9uKCkge1xcbiAgICAgICAgZXhwb3J0cy5mb3JFYWNoKGV4cG9ydHMua2V5cyh2YWx1ZSkuc29ydCgpLCBmdW5jdGlvbihrZXkpIHtcXG4gICAgICAgICAgY2Fub25pY2FsaXplZE9ialtrZXldID0gZXhwb3J0cy5jYW5vbmljYWxpemUodmFsdWVba2V5XSwgc3RhY2spO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSk7XFxuICAgICAgYnJlYWs7XFxuICAgIGNhc2UgJ2RhdGUnOlxcbiAgICBjYXNlICdudW1iZXInOlxcbiAgICBjYXNlICdyZWdleHAnOlxcbiAgICBjYXNlICdib29sZWFuJzpcXG4gICAgICBjYW5vbmljYWxpemVkT2JqID0gdmFsdWU7XFxuICAgICAgYnJlYWs7XFxuICAgIGRlZmF1bHQ6XFxuICAgICAgY2Fub25pY2FsaXplZE9iaiA9IHZhbHVlICsgJyc7XFxuICB9XFxuXFxuICByZXR1cm4gY2Fub25pY2FsaXplZE9iajtcXG59O1xcblxcbi8qKlxcbiAqIExvb2t1cCBmaWxlIG5hbWVzIGF0IHRoZSBnaXZlbiBgcGF0aGAuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIEJhc2UgcGF0aCB0byBzdGFydCBzZWFyY2hpbmcgZnJvbS5cXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBleHRlbnNpb25zIEZpbGUgZXh0ZW5zaW9ucyB0byBsb29rIGZvci5cXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHJlY3Vyc2l2ZSBXaGV0aGVyIG9yIG5vdCB0byByZWN1cnNlIGludG8gc3ViZGlyZWN0b3JpZXMuXFxuICogQHJldHVybiB7c3RyaW5nW119IEFuIGFycmF5IG9mIHBhdGhzLlxcbiAqL1xcbmV4cG9ydHMubG9va3VwRmlsZXMgPSBmdW5jdGlvbiBsb29rdXBGaWxlcyhwYXRoLCBleHRlbnNpb25zLCByZWN1cnNpdmUpIHtcXG4gIHZhciBmaWxlcyA9IFtdO1xcbiAgdmFyIHJlID0gbmV3IFJlZ0V4cCgnXFxcXFxcXFwuKCcgKyBleHRlbnNpb25zLmpvaW4oJ3wnKSArICcpJCcpO1xcblxcbiAgaWYgKCFleGlzdHMocGF0aCkpIHtcXG4gICAgaWYgKGV4aXN0cyhwYXRoICsgJy5qcycpKSB7XFxuICAgICAgcGF0aCArPSAnLmpzJztcXG4gICAgfSBlbHNlIHtcXG4gICAgICBmaWxlcyA9IGdsb2Iuc3luYyhwYXRoKTtcXG4gICAgICBpZiAoIWZpbGVzLmxlbmd0aCkge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJjYW5ub3QgcmVzb2x2ZSBwYXRoIChvciBwYXR0ZXJuKSAnXFxcIiArIHBhdGggKyBcXFwiJ1xcXCIpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gZmlsZXM7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHRyeSB7XFxuICAgIHZhciBzdGF0ID0gc3RhdFN5bmMocGF0aCk7XFxuICAgIGlmIChzdGF0LmlzRmlsZSgpKSB7XFxuICAgICAgcmV0dXJuIHBhdGg7XFxuICAgIH1cXG4gIH0gY2F0Y2ggKGVycikge1xcbiAgICAvLyBpZ25vcmUgZXJyb3JcXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgcmVhZGRpclN5bmMocGF0aCkuZm9yRWFjaChmdW5jdGlvbihmaWxlKSB7XFxuICAgIGZpbGUgPSBqb2luKHBhdGgsIGZpbGUpO1xcbiAgICB0cnkge1xcbiAgICAgIHZhciBzdGF0ID0gc3RhdFN5bmMoZmlsZSk7XFxuICAgICAgaWYgKHN0YXQuaXNEaXJlY3RvcnkoKSkge1xcbiAgICAgICAgaWYgKHJlY3Vyc2l2ZSkge1xcbiAgICAgICAgICBmaWxlcyA9IGZpbGVzLmNvbmNhdChsb29rdXBGaWxlcyhmaWxlLCBleHRlbnNpb25zLCByZWN1cnNpdmUpKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgIC8vIGlnbm9yZSBlcnJvclxcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBpZiAoIXN0YXQuaXNGaWxlKCkgfHwgIXJlLnRlc3QoZmlsZSkgfHwgYmFzZW5hbWUoZmlsZSlbMF0gPT09ICcuJykge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBmaWxlcy5wdXNoKGZpbGUpO1xcbiAgfSk7XFxuXFxuICByZXR1cm4gZmlsZXM7XFxufTtcXG5cXG4vKipcXG4gKiBHZW5lcmF0ZSBhbiB1bmRlZmluZWQgZXJyb3Igd2l0aCBhIG1lc3NhZ2Ugd2FybmluZyB0aGUgdXNlci5cXG4gKlxcbiAqIEByZXR1cm4ge0Vycm9yfVxcbiAqL1xcblxcbmV4cG9ydHMudW5kZWZpbmVkRXJyb3IgPSBmdW5jdGlvbigpIHtcXG4gIHJldHVybiBuZXcgRXJyb3IoJ0NhdWdodCB1bmRlZmluZWQgZXJyb3IsIGRpZCB5b3UgdGhyb3cgd2l0aG91dCBzcGVjaWZ5aW5nIHdoYXQ/Jyk7XFxufTtcXG5cXG4vKipcXG4gKiBHZW5lcmF0ZSBhbiB1bmRlZmluZWQgZXJyb3IgaWYgYGVycmAgaXMgbm90IGRlZmluZWQuXFxuICpcXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcXG4gKiBAcmV0dXJuIHtFcnJvcn1cXG4gKi9cXG5cXG5leHBvcnRzLmdldEVycm9yID0gZnVuY3Rpb24oZXJyKSB7XFxuICByZXR1cm4gZXJyIHx8IGV4cG9ydHMudW5kZWZpbmVkRXJyb3IoKTtcXG59O1xcblxcbi8qKlxcbiAqIEBzdW1tYXJ5XFxuICogVGhpcyBGaWx0ZXIgYmFzZWQgb24gYG1vY2hhLWNsZWFuYCBtb2R1bGUuKHNlZTogYGdpdGh1Yi5jb20vcnN0YWNydXovbW9jaGEtY2xlYW5gKVxcbiAqIEBkZXNjcmlwdGlvblxcbiAqIFdoZW4gaW52b2tpbmcgdGhpcyBmdW5jdGlvbiB5b3UgZ2V0IGEgZmlsdGVyIGZ1bmN0aW9uIHRoYXQgZ2V0IHRoZSBFcnJvci5zdGFjayBhcyBhbiBpbnB1dCxcXG4gKiBhbmQgcmV0dXJuIGEgcHJldHRpZnkgb3V0cHV0LlxcbiAqIChpLmU6IHN0cmlwIE1vY2hhIGFuZCBpbnRlcm5hbCBub2RlIGZ1bmN0aW9ucyBmcm9tIHN0YWNrIHRyYWNlKS5cXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XFxuICovXFxuZXhwb3J0cy5zdGFja1RyYWNlRmlsdGVyID0gZnVuY3Rpb24oKSB7XFxuICAvLyBUT0RPOiBSZXBsYWNlIHdpdGggYHByb2Nlc3MuYnJvd3NlcmBcXG4gIHZhciBzbGFzaCA9ICcvJztcXG4gIHZhciBpcyA9IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgPyB7IG5vZGU6IHRydWUgfSA6IHsgYnJvd3NlcjogdHJ1ZSB9O1xcbiAgdmFyIGN3ZCA9IGlzLm5vZGVcXG4gICAgICA/IHByb2Nlc3MuY3dkKCkgKyBzbGFzaFxcbiAgICAgIDogKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cubG9jYXRpb24gOiBsb2NhdGlvbikuaHJlZi5yZXBsYWNlKC9cXFxcL1teXFxcXC9dKiQvLCAnLycpO1xcblxcbiAgZnVuY3Rpb24gaXNNb2NoYUludGVybmFsKGxpbmUpIHtcXG4gICAgcmV0dXJuICh+bGluZS5pbmRleE9mKCdub2RlX21vZHVsZXMnICsgc2xhc2ggKyAnbW9jaGEnICsgc2xhc2gpKVxcbiAgICAgIHx8ICh+bGluZS5pbmRleE9mKCdjb21wb25lbnRzJyArIHNsYXNoICsgJ21vY2hhanMnICsgc2xhc2gpKVxcbiAgICAgIHx8ICh+bGluZS5pbmRleE9mKCdjb21wb25lbnRzJyArIHNsYXNoICsgJ21vY2hhJyArIHNsYXNoKSlcXG4gICAgICB8fCAofmxpbmUuaW5kZXhPZihzbGFzaCArICdtb2NoYS5qcycpKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGlzTm9kZUludGVybmFsKGxpbmUpIHtcXG4gICAgcmV0dXJuICh+bGluZS5pbmRleE9mKCcodGltZXJzLmpzOicpKVxcbiAgICAgIHx8ICh+bGluZS5pbmRleE9mKCcoZXZlbnRzLmpzOicpKVxcbiAgICAgIHx8ICh+bGluZS5pbmRleE9mKCcobm9kZS5qczonKSlcXG4gICAgICB8fCAofmxpbmUuaW5kZXhPZignKG1vZHVsZS5qczonKSlcXG4gICAgICB8fCAofmxpbmUuaW5kZXhPZignR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUubmV4dCAobmF0aXZlKScpKVxcbiAgICAgIHx8IGZhbHNlO1xcbiAgfVxcblxcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0YWNrKSB7XFxuICAgIHN0YWNrID0gc3RhY2suc3BsaXQoJ1xcXFxuJyk7XFxuXFxuICAgIHN0YWNrID0gZXhwb3J0cy5yZWR1Y2Uoc3RhY2ssIGZ1bmN0aW9uKGxpc3QsIGxpbmUpIHtcXG4gICAgICBpZiAoaXNNb2NoYUludGVybmFsKGxpbmUpKSB7XFxuICAgICAgICByZXR1cm4gbGlzdDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGlzLm5vZGUgJiYgaXNOb2RlSW50ZXJuYWwobGluZSkpIHtcXG4gICAgICAgIHJldHVybiBsaXN0O1xcbiAgICAgIH1cXG5cXG4gICAgICAvLyBDbGVhbiB1cCBjd2QoYWJzb2x1dGUpXFxuICAgICAgbGlzdC5wdXNoKGxpbmUucmVwbGFjZShjd2QsICcnKSk7XFxuICAgICAgcmV0dXJuIGxpc3Q7XFxuICAgIH0sIFtdKTtcXG5cXG4gICAgcmV0dXJuIHN0YWNrLmpvaW4oJ1xcXFxuJyk7XFxuICB9O1xcbn07XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykscmVxdWlyZShcXFwiYnVmZmVyXFxcIikuQnVmZmVyKVxcbn0se1xcXCJfcHJvY2Vzc1xcXCI6NTEsXFxcImJ1ZmZlclxcXCI6NDMsXFxcImRlYnVnXFxcIjoyLFxcXCJmc1xcXCI6NDEsXFxcImdsb2JcXFwiOjQxLFxcXCJwYXRoXFxcIjo0MSxcXFwidXRpbFxcXCI6NjZ9XSw0MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG52YXIgV3JpdGFibGVTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5Xcml0YWJsZVxcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0c1xcblxcbm1vZHVsZS5leHBvcnRzID0gQnJvd3NlclN0ZG91dFxcblxcblxcbmluaGVyaXRzKEJyb3dzZXJTdGRvdXQsIFdyaXRhYmxlU3RyZWFtKVxcblxcbmZ1bmN0aW9uIEJyb3dzZXJTdGRvdXQob3B0cykge1xcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJyb3dzZXJTdGRvdXQpKSByZXR1cm4gbmV3IEJyb3dzZXJTdGRvdXQob3B0cylcXG5cXG4gIG9wdHMgPSBvcHRzIHx8IHt9XFxuICBXcml0YWJsZVN0cmVhbS5jYWxsKHRoaXMsIG9wdHMpXFxuICB0aGlzLmxhYmVsID0gKG9wdHMubGFiZWwgIT09IHVuZGVmaW5lZCkgPyBvcHRzLmxhYmVsIDogJ3N0ZG91dCdcXG59XFxuXFxuQnJvd3NlclN0ZG91dC5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmtzLCBlbmNvZGluZywgY2IpIHtcXG4gIHZhciBvdXRwdXQgPSBjaHVua3MudG9TdHJpbmcgPyBjaHVua3MudG9TdHJpbmcoKSA6IGNodW5rc1xcbiAgaWYgKHRoaXMubGFiZWwgPT09IGZhbHNlKSB7XFxuICAgIGNvbnNvbGUubG9nKG91dHB1dClcXG4gIH0gZWxzZSB7XFxuICAgIGNvbnNvbGUubG9nKHRoaXMubGFiZWwrJzonLCBvdXRwdXQpXFxuICB9XFxuICBwcm9jZXNzLm5leHRUaWNrKGNiKVxcbn1cXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiX3Byb2Nlc3NcXFwiOjUxLFxcXCJzdHJlYW1cXFwiOjYzLFxcXCJ1dGlsXFxcIjo2Nn1dLDQxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5cXG59LHt9XSw0MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuYXJndW1lbnRzWzRdWzQxXVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cylcXG59LHtcXFwiZHVwXFxcIjo0MX1dLDQzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vKiFcXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cXG4gKlxcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxcbiAqIEBsaWNlbnNlICBNSVRcXG4gKi9cXG5cXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXMtYXJyYXknKVxcblxcbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXFxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxcbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxcblxcbnZhciByb290UGFyZW50ID0ge31cXG5cXG4vKipcXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXFxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxcbiAqXFxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cXG4gKlxcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cXG4gKlxcbiAqIE5vdGU6XFxuICpcXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cXG4gKlxcbiAqICAgLSBTYWZhcmkgNS03IGxhY2tzIHN1cHBvcnQgZm9yIGNoYW5naW5nIHRoZSBgT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvcmAgcHJvcGVydHlcXG4gKiAgICAgb24gb2JqZWN0cy5cXG4gKlxcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxcbiAqXFxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXFxuXFxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcXG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cXG4gKi9cXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IChmdW5jdGlvbiAoKSB7XFxuICBmdW5jdGlvbiBCYXIgKCkge31cXG4gIHRyeSB7XFxuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxcbiAgICBhcnIuY29uc3RydWN0b3IgPSBCYXJcXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcXG4gICAgICAgIGFyci5jb25zdHJ1Y3RvciA9PT0gQmFyICYmIC8vIGNvbnN0cnVjdG9yIGNhbiBiZSBzZXRcXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxcbiAgfSBjYXRjaCAoZSkge1xcbiAgICByZXR1cm4gZmFsc2VcXG4gIH1cXG59KSgpXFxuXFxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XFxuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcXG4gICAgPyAweDdmZmZmZmZmXFxuICAgIDogMHgzZmZmZmZmZlxcbn1cXG5cXG4vKipcXG4gKiBDbGFzczogQnVmZmVyXFxuICogPT09PT09PT09PT09PVxcbiAqXFxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXFxuICogd2l0aCBmdW5jdGlvbiBwcm9wZXJ0aWVzIGZvciBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgQVBJIGZ1bmN0aW9ucy4gV2UgdXNlXFxuICogYFVpbnQ4QXJyYXlgIHNvIHRoYXQgc3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXQgcmV0dXJuc1xcbiAqIGEgc2luZ2xlIG9jdGV0LlxcbiAqXFxuICogQnkgYXVnbWVudGluZyB0aGUgaW5zdGFuY2VzLCB3ZSBjYW4gYXZvaWQgbW9kaWZ5aW5nIHRoZSBgVWludDhBcnJheWBcXG4gKiBwcm90b3R5cGUuXFxuICovXFxuZnVuY3Rpb24gQnVmZmVyIChhcmcpIHtcXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XFxuICAgIC8vIEF2b2lkIGdvaW5nIHRocm91Z2ggYW4gQXJndW1lbnRzQWRhcHRvclRyYW1wb2xpbmUgaW4gdGhlIGNvbW1vbiBjYXNlLlxcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHJldHVybiBuZXcgQnVmZmVyKGFyZywgYXJndW1lbnRzWzFdKVxcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcpXFxuICB9XFxuXFxuICB0aGlzLmxlbmd0aCA9IDBcXG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkXFxuXFxuICAvLyBDb21tb24gY2FzZS5cXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xcbiAgICByZXR1cm4gZnJvbU51bWJlcih0aGlzLCBhcmcpXFxuICB9XFxuXFxuICAvLyBTbGlnaHRseSBsZXNzIGNvbW1vbiBjYXNlLlxcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XFxuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoaXMsIGFyZywgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiAndXRmOCcpXFxuICB9XFxuXFxuICAvLyBVbnVzdWFsLlxcbiAgcmV0dXJuIGZyb21PYmplY3QodGhpcywgYXJnKVxcbn1cXG5cXG5mdW5jdGlvbiBmcm9tTnVtYmVyICh0aGF0LCBsZW5ndGgpIHtcXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGggPCAwID8gMCA6IGNoZWNrZWQobGVuZ3RoKSB8IDApXFxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcXG4gICAgICB0aGF0W2ldID0gMFxcbiAgICB9XFxuICB9XFxuICByZXR1cm4gdGhhdFxcbn1cXG5cXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XFxuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIGVuY29kaW5nID0gJ3V0ZjgnXFxuXFxuICAvLyBBc3N1bXB0aW9uOiBieXRlTGVuZ3RoKCkgcmV0dXJuIHZhbHVlIGlzIGFsd2F5cyA8IGtNYXhMZW5ndGguXFxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXFxuXFxuICB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXFxuICByZXR1cm4gdGhhdFxcbn1cXG5cXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmplY3QpIHtcXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqZWN0KSkgcmV0dXJuIGZyb21CdWZmZXIodGhhdCwgb2JqZWN0KVxcblxcbiAgaWYgKGlzQXJyYXkob2JqZWN0KSkgcmV0dXJuIGZyb21BcnJheSh0aGF0LCBvYmplY3QpXFxuXFxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbXVzdCBzdGFydCB3aXRoIG51bWJlciwgYnVmZmVyLCBhcnJheSBvciBzdHJpbmcnKVxcbiAgfVxcblxcbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgaWYgKG9iamVjdC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xcbiAgICAgIHJldHVybiBmcm9tVHlwZWRBcnJheSh0aGF0LCBvYmplY3QpXFxuICAgIH1cXG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XFxuICAgICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCBvYmplY3QpXFxuICAgIH1cXG4gIH1cXG5cXG4gIGlmIChvYmplY3QubGVuZ3RoKSByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmplY3QpXFxuXFxuICByZXR1cm4gZnJvbUpzb25PYmplY3QodGhhdCwgb2JqZWN0KVxcbn1cXG5cXG5mdW5jdGlvbiBmcm9tQnVmZmVyICh0aGF0LCBidWZmZXIpIHtcXG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGJ1ZmZlci5sZW5ndGgpIHwgMFxcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcXG4gIGJ1ZmZlci5jb3B5KHRoYXQsIDAsIDAsIGxlbmd0aClcXG4gIHJldHVybiB0aGF0XFxufVxcblxcbmZ1bmN0aW9uIGZyb21BcnJheSAodGhhdCwgYXJyYXkpIHtcXG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcXG4gIH1cXG4gIHJldHVybiB0aGF0XFxufVxcblxcbi8vIER1cGxpY2F0ZSBvZiBmcm9tQXJyYXkoKSB0byBrZWVwIGZyb21BcnJheSgpIG1vbm9tb3JwaGljLlxcbmZ1bmN0aW9uIGZyb21UeXBlZEFycmF5ICh0aGF0LCBhcnJheSkge1xcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXFxuICAvLyBUcnVuY2F0aW5nIHRoZSBlbGVtZW50cyBpcyBwcm9iYWJseSBub3Qgd2hhdCBwZW9wbGUgZXhwZWN0IGZyb20gdHlwZWRcXG4gIC8vIGFycmF5cyB3aXRoIEJZVEVTX1BFUl9FTEVNRU5UID4gMSBidXQgaXQncyBjb21wYXRpYmxlIHdpdGggdGhlIGJlaGF2aW9yXFxuICAvLyBvZiB0aGUgb2xkIEJ1ZmZlciBjb25zdHJ1Y3Rvci5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XFxuICB9XFxuICByZXR1cm4gdGhhdFxcbn1cXG5cXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5KSB7XFxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcXG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXFxuICAgIGFycmF5LmJ5dGVMZW5ndGhcXG4gICAgdGhhdCA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShhcnJheSkpXFxuICB9IGVsc2Uge1xcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXFxuICAgIHRoYXQgPSBmcm9tVHlwZWRBcnJheSh0aGF0LCBuZXcgVWludDhBcnJheShhcnJheSkpXFxuICB9XFxuICByZXR1cm4gdGhhdFxcbn1cXG5cXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XFxuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxcbiAgfVxcbiAgcmV0dXJuIHRoYXRcXG59XFxuXFxuLy8gRGVzZXJpYWxpemUgeyB0eXBlOiAnQnVmZmVyJywgZGF0YTogWzEsMiwzLC4uLl0gfSBpbnRvIGEgQnVmZmVyIG9iamVjdC5cXG4vLyBSZXR1cm5zIGEgemVyby1sZW5ndGggYnVmZmVyIGZvciBpbnB1dHMgdGhhdCBkb24ndCBjb25mb3JtIHRvIHRoZSBzcGVjLlxcbmZ1bmN0aW9uIGZyb21Kc29uT2JqZWN0ICh0aGF0LCBvYmplY3QpIHtcXG4gIHZhciBhcnJheVxcbiAgdmFyIGxlbmd0aCA9IDBcXG5cXG4gIGlmIChvYmplY3QudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmplY3QuZGF0YSkpIHtcXG4gICAgYXJyYXkgPSBvYmplY3QuZGF0YVxcbiAgICBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXFxuICB9XFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcXG4gIH1cXG4gIHJldHVybiB0aGF0XFxufVxcblxcbmZ1bmN0aW9uIGFsbG9jYXRlICh0aGF0LCBsZW5ndGgpIHtcXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcXG4gICAgdGhhdCA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKVxcbiAgfSBlbHNlIHtcXG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xcbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxcbiAgICB0aGF0Ll9pc0J1ZmZlciA9IHRydWVcXG4gIH1cXG5cXG4gIHZhciBmcm9tUG9vbCA9IGxlbmd0aCAhPT0gMCAmJiBsZW5ndGggPD0gQnVmZmVyLnBvb2xTaXplID4+PiAxXFxuICBpZiAoZnJvbVBvb2wpIHRoYXQucGFyZW50ID0gcm9vdFBhcmVudFxcblxcbiAgcmV0dXJuIHRoYXRcXG59XFxuXFxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XFxuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXFxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxcbiAgfVxcbiAgcmV0dXJuIGxlbmd0aCB8IDBcXG59XFxuXFxuZnVuY3Rpb24gU2xvd0J1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcpIHtcXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTbG93QnVmZmVyKSkgcmV0dXJuIG5ldyBTbG93QnVmZmVyKHN1YmplY3QsIGVuY29kaW5nKVxcblxcbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcpXFxuICBkZWxldGUgYnVmLnBhcmVudFxcbiAgcmV0dXJuIGJ1Zlxcbn1cXG5cXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcXG59XFxuXFxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XFxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxcbiAgfVxcblxcbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXFxuXFxuICB2YXIgeCA9IGEubGVuZ3RoXFxuICB2YXIgeSA9IGIubGVuZ3RoXFxuXFxuICB2YXIgaSA9IDBcXG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxcbiAgd2hpbGUgKGkgPCBsZW4pIHtcXG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIGJyZWFrXFxuXFxuICAgICsraVxcbiAgfVxcblxcbiAgaWYgKGkgIT09IGxlbikge1xcbiAgICB4ID0gYVtpXVxcbiAgICB5ID0gYltpXVxcbiAgfVxcblxcbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcXG4gIHJldHVybiAwXFxufVxcblxcbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcXG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XFxuICAgIGNhc2UgJ2hleCc6XFxuICAgIGNhc2UgJ3V0ZjgnOlxcbiAgICBjYXNlICd1dGYtOCc6XFxuICAgIGNhc2UgJ2FzY2lpJzpcXG4gICAgY2FzZSAnYmluYXJ5JzpcXG4gICAgY2FzZSAnYmFzZTY0JzpcXG4gICAgY2FzZSAncmF3JzpcXG4gICAgY2FzZSAndWNzMic6XFxuICAgIGNhc2UgJ3Vjcy0yJzpcXG4gICAgY2FzZSAndXRmMTZsZSc6XFxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcXG4gICAgICByZXR1cm4gdHJ1ZVxcbiAgICBkZWZhdWx0OlxcbiAgICAgIHJldHVybiBmYWxzZVxcbiAgfVxcbn1cXG5cXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcXG4gIGlmICghaXNBcnJheShsaXN0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignbGlzdCBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMuJylcXG5cXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKVxcbiAgfVxcblxcbiAgdmFyIGlcXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xcbiAgICBsZW5ndGggPSAwXFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XFxuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXFxuICAgIH1cXG4gIH1cXG5cXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKGxlbmd0aClcXG4gIHZhciBwb3MgPSAwXFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxcbiAgICBwb3MgKz0gaXRlbS5sZW5ndGhcXG4gIH1cXG4gIHJldHVybiBidWZcXG59XFxuXFxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSBzdHJpbmcgPSAnJyArIHN0cmluZ1xcblxcbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXFxuXFxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXFxuICBmb3IgKDs7KSB7XFxuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcXG4gICAgICBjYXNlICdhc2NpaSc6XFxuICAgICAgY2FzZSAnYmluYXJ5JzpcXG4gICAgICAvLyBEZXByZWNhdGVkXFxuICAgICAgY2FzZSAncmF3JzpcXG4gICAgICBjYXNlICdyYXdzJzpcXG4gICAgICAgIHJldHVybiBsZW5cXG4gICAgICBjYXNlICd1dGY4JzpcXG4gICAgICBjYXNlICd1dGYtOCc6XFxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcXG4gICAgICBjYXNlICd1Y3MyJzpcXG4gICAgICBjYXNlICd1Y3MtMic6XFxuICAgICAgY2FzZSAndXRmMTZsZSc6XFxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcXG4gICAgICBjYXNlICdoZXgnOlxcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XFxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxcbiAgICAgIGRlZmF1bHQ6XFxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXFxuICAgIH1cXG4gIH1cXG59XFxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXFxuXFxuLy8gcHJlLXNldCBmb3IgdmFsdWVzIHRoYXQgbWF5IGV4aXN0IGluIHRoZSBmdXR1cmVcXG5CdWZmZXIucHJvdG90eXBlLmxlbmd0aCA9IHVuZGVmaW5lZFxcbkJ1ZmZlci5wcm90b3R5cGUucGFyZW50ID0gdW5kZWZpbmVkXFxuXFxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcXG5cXG4gIHN0YXJ0ID0gc3RhcnQgfCAwXFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPT09IEluZmluaXR5ID8gdGhpcy5sZW5ndGggOiBlbmQgfCAwXFxuXFxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xcbiAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXFxuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXFxuICBpZiAoZW5kIDw9IHN0YXJ0KSByZXR1cm4gJydcXG5cXG4gIHdoaWxlICh0cnVlKSB7XFxuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcXG4gICAgICBjYXNlICdoZXgnOlxcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXFxuXFxuICAgICAgY2FzZSAndXRmOCc6XFxuICAgICAgY2FzZSAndXRmLTgnOlxcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxcblxcbiAgICAgIGNhc2UgJ2FzY2lpJzpcXG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXFxuXFxuICAgICAgY2FzZSAnYmluYXJ5JzpcXG4gICAgICAgIHJldHVybiBiaW5hcnlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxcblxcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XFxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcXG5cXG4gICAgICBjYXNlICd1Y3MyJzpcXG4gICAgICBjYXNlICd1Y3MtMic6XFxuICAgICAgY2FzZSAndXRmMTZsZSc6XFxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxcblxcbiAgICAgIGRlZmF1bHQ6XFxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxcbiAgICB9XFxuICB9XFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XFxuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXFxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XFxuICB2YXIgc3RyID0gJydcXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXFxuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XFxuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXFxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcXG4gIH1cXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGIpIHtcXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gMFxcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCkge1xcbiAgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxcbiAgZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcXG4gIGJ5dGVPZmZzZXQgPj49IDBcXG5cXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXFxuICBpZiAoYnl0ZU9mZnNldCA+PSB0aGlzLmxlbmd0aCkgcmV0dXJuIC0xXFxuXFxuICAvLyBOZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXFxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBNYXRoLm1heCh0aGlzLmxlbmd0aCArIGJ5dGVPZmZzZXQsIDApXFxuXFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHJldHVybiAtMSAvLyBzcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZyBhbHdheXMgZmFpbHNcXG4gICAgcmV0dXJuIFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcXG4gIH1cXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xcbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcXG4gIH1cXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxcbiAgICB9XFxuICAgIHJldHVybiBhcnJheUluZGV4T2YodGhpcywgWyB2YWwgXSwgYnl0ZU9mZnNldClcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQpIHtcXG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxcbiAgICBmb3IgKHZhciBpID0gMDsgYnl0ZU9mZnNldCArIGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcXG4gICAgICBpZiAoYXJyW2J5dGVPZmZzZXQgKyBpXSA9PT0gdmFsW2ZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4XSkge1xcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsLmxlbmd0aCkgcmV0dXJuIGJ5dGVPZmZzZXQgKyBmb3VuZEluZGV4XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gLTFcXG4gIH1cXG5cXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXFxufVxcblxcbi8vIGBnZXRgIGlzIGRlcHJlY2F0ZWRcXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAob2Zmc2V0KSB7XFxuICBjb25zb2xlLmxvZygnLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXFxufVxcblxcbi8vIGBzZXRgIGlzIGRlcHJlY2F0ZWRcXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAodiwgb2Zmc2V0KSB7XFxuICBjb25zb2xlLmxvZygnLnNldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxcbn1cXG5cXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XFxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxcbiAgaWYgKCFsZW5ndGgpIHtcXG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXFxuICB9IGVsc2Uge1xcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XFxuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXFxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcXG5cXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XFxuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcXG4gIH1cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcXG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXFxuICB9XFxuICByZXR1cm4gaVxcbn1cXG5cXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcXG59XFxuXFxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XFxuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcXG59XFxuXFxuZnVuY3Rpb24gYmluYXJ5V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxcbn1cXG5cXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XFxuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXFxufVxcblxcbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XFxuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIGVuY29kaW5nID0gJ3V0ZjgnXFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXFxuICAgIG9mZnNldCA9IDBcXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xcbiAgICBlbmNvZGluZyA9IG9mZnNldFxcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxcbiAgICBvZmZzZXQgPSAwXFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XFxuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcXG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXFxuICAgIH0gZWxzZSB7XFxuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcXG4gICAgfVxcbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xcbiAgfSBlbHNlIHtcXG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZ1xcbiAgICBlbmNvZGluZyA9IG9mZnNldFxcbiAgICBvZmZzZXQgPSBsZW5ndGggfCAwXFxuICAgIGxlbmd0aCA9IHN3YXBcXG4gIH1cXG5cXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXFxuXFxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxcbiAgfVxcblxcbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcXG5cXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXFxuICBmb3IgKDs7KSB7XFxuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcXG4gICAgICBjYXNlICdoZXgnOlxcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXFxuXFxuICAgICAgY2FzZSAndXRmOCc6XFxuICAgICAgY2FzZSAndXRmLTgnOlxcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxcblxcbiAgICAgIGNhc2UgJ2FzY2lpJzpcXG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXFxuXFxuICAgICAgY2FzZSAnYmluYXJ5JzpcXG4gICAgICAgIHJldHVybiBiaW5hcnlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxcblxcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XFxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXFxuXFxuICAgICAgY2FzZSAndWNzMic6XFxuICAgICAgY2FzZSAndWNzLTInOlxcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcXG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcXG5cXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXFxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XFxuICByZXR1cm4ge1xcbiAgICB0eXBlOiAnQnVmZmVyJyxcXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcXG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XFxuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXFxuICB2YXIgcmVzID0gW11cXG5cXG4gIHZhciBpID0gc3RhcnRcXG4gIHdoaWxlIChpIDwgZW5kKSB7XFxuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXFxuICAgICAgOiAxXFxuXFxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcXG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XFxuXFxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XFxuICAgICAgICBjYXNlIDE6XFxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XFxuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXFxuICAgICAgICAgIH1cXG4gICAgICAgICAgYnJlYWtcXG4gICAgICAgIGNhc2UgMjpcXG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcXG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcXG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgYnJlYWtcXG4gICAgICAgIGNhc2UgMzpcXG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxcbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcXG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XFxuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIGJyZWFrXFxuICAgICAgICBjYXNlIDQ6XFxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXFxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcXG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcXG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXFxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcXG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXFxuICAgIH1cXG5cXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcXG4gIH1cXG5cXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxcbn1cXG5cXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXFxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxcblxcbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XFxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxcbiAgfVxcblxcbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcXFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXFxcIi5cXG4gIHZhciByZXMgPSAnJ1xcbiAgdmFyIGkgPSAwXFxuICB3aGlsZSAoaSA8IGxlbikge1xcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcXG4gICAgICBTdHJpbmcsXFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxcbiAgICApXFxuICB9XFxuICByZXR1cm4gcmVzXFxufVxcblxcbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xcbiAgdmFyIHJldCA9ICcnXFxuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXFxuXFxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxcbiAgfVxcbiAgcmV0dXJuIHJldFxcbn1cXG5cXG5mdW5jdGlvbiBiaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XFxuICB2YXIgcmV0ID0gJydcXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcXG5cXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XFxuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcXG4gIH1cXG4gIHJldHVybiByZXRcXG59XFxuXFxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcXG5cXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cXG5cXG4gIHZhciBvdXQgPSAnJ1xcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcXG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcXG4gIH1cXG4gIHJldHVybiBvdXRcXG59XFxuXFxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcXG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxcbiAgdmFyIHJlcyA9ICcnXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XFxuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxcbiAgfVxcbiAgcmV0dXJuIHJlc1xcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcXG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxcbiAgc3RhcnQgPSB+fnN0YXJ0XFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXFxuXFxuICBpZiAoc3RhcnQgPCAwKSB7XFxuICAgIHN0YXJ0ICs9IGxlblxcbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcXG4gICAgc3RhcnQgPSBsZW5cXG4gIH1cXG5cXG4gIGlmIChlbmQgPCAwKSB7XFxuICAgIGVuZCArPSBsZW5cXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XFxuICAgIGVuZCA9IGxlblxcbiAgfVxcblxcbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxcblxcbiAgdmFyIG5ld0J1ZlxcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XFxuICAgIG5ld0J1ZiA9IEJ1ZmZlci5fYXVnbWVudCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpKVxcbiAgfSBlbHNlIHtcXG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcXG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyBpKyspIHtcXG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cXG4gICAgfVxcbiAgfVxcblxcbiAgaWYgKG5ld0J1Zi5sZW5ndGgpIG5ld0J1Zi5wYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzXFxuXFxuICByZXR1cm4gbmV3QnVmXFxufVxcblxcbi8qXFxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXFxuICovXFxuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcXG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXFxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcXG5cXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cXG4gIHZhciBtdWwgPSAxXFxuICB2YXIgaSA9IDBcXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XFxuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXFxuICB9XFxuXFxuICByZXR1cm4gdmFsXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxcbiAgaWYgKCFub0Fzc2VydCkge1xcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxcbiAgfVxcblxcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxcbiAgdmFyIG11bCA9IDFcXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXFxuICB9XFxuXFxuICByZXR1cm4gdmFsXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcXG5cXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcXG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXFxuXFxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcXG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxcbiAgICB0aGlzW29mZnNldCArIDNdKVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxcblxcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxcbiAgdmFyIG11bCA9IDFcXG4gIHZhciBpID0gMFxcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcXG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcXG4gIH1cXG4gIG11bCAqPSAweDgwXFxuXFxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxcblxcbiAgcmV0dXJuIHZhbFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxcblxcbiAgdmFyIGkgPSBieXRlTGVuZ3RoXFxuICB2YXIgbXVsID0gMVxcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxcbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XFxuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcXG4gIH1cXG4gIG11bCAqPSAweDgwXFxuXFxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxcblxcbiAgcmV0dXJuIHZhbFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXFxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXFxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXFxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXFxuXFxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXFxuXFxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XFxuICAgICh0aGlzW29mZnNldCArIDNdKVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXFxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXFxufVxcblxcbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J1ZmZlciBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCksIDApXFxuXFxuICB2YXIgbXVsID0gMVxcbiAgdmFyIGkgPSAwXFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XFxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxcbiAgfVxcblxcbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpLCAwKVxcblxcbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxcbiAgdmFyIG11bCA9IDFcXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcXG4gIH1cXG5cXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXFxuICByZXR1cm4gb2Zmc2V0ICsgMVxcbn1cXG5cXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXFxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgaSsrKSB7XFxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XFxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XFxuICB9XFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XFxuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXFxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXFxuICB9IGVsc2Uge1xcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxcbiAgfVxcbiAgcmV0dXJuIG9mZnNldCArIDJcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXFxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxcbiAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWVcXG4gIH0gZWxzZSB7XFxuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxcbiAgfVxcbiAgcmV0dXJuIG9mZnNldCArIDJcXG59XFxuXFxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XFxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyBpKyspIHtcXG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxcbiAgfVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXFxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXFxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxcbiAgfSBlbHNlIHtcXG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcXG4gIH1cXG4gIHJldHVybiBvZmZzZXQgKyA0XFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlXFxuICB9IGVsc2Uge1xcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcXG4gIH1cXG4gIHJldHVybiBvZmZzZXQgKyA0XFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgaWYgKCFub0Fzc2VydCkge1xcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXFxuXFxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxcbiAgfVxcblxcbiAgdmFyIGkgPSAwXFxuICB2YXIgbXVsID0gMVxcbiAgdmFyIHN1YiA9IHZhbHVlIDwgMCA/IDEgOiAwXFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XFxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcXG4gIH1cXG5cXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgaWYgKCFub0Fzc2VydCkge1xcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXFxuXFxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxcbiAgfVxcblxcbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxcbiAgdmFyIG11bCA9IDFcXG4gIHZhciBzdWIgPSB2YWx1ZSA8IDAgPyAxIDogMFxcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XFxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcXG4gIH1cXG5cXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxcbiAgcmV0dXJuIG9mZnNldCArIDFcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XFxuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXFxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXFxuICB9IGVsc2Uge1xcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxcbiAgfVxcbiAgcmV0dXJuIG9mZnNldCArIDJcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XFxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlXFxuICB9IGVsc2Uge1xcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcXG4gIH1cXG4gIHJldHVybiBvZmZzZXQgKyAyXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XFxuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXFxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXFxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcXG4gIH0gZWxzZSB7XFxuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXFxuICB9XFxuICByZXR1cm4gb2Zmc2V0ICsgNFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XFxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXFxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWVcXG4gIH0gZWxzZSB7XFxuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxcbiAgfVxcbiAgcmV0dXJuIG9mZnNldCArIDRcXG59XFxuXFxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxcbn1cXG5cXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcXG4gIGlmICghbm9Bc3NlcnQpIHtcXG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXFxuICB9XFxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcXG4gIHJldHVybiBvZmZzZXQgKyA0XFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxcbn1cXG5cXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XFxuICBpZiAoIW5vQXNzZXJ0KSB7XFxuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXFxuICB9XFxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcXG4gIHJldHVybiBvZmZzZXQgKyA4XFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxcbn1cXG5cXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXFxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxcblxcbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXFxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxcblxcbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXFxuICB9XFxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXFxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcXG5cXG4gIC8vIEFyZSB3ZSBvb2I/XFxuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcXG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcXG4gIH1cXG5cXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxcbiAgdmFyIGlcXG5cXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcXG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxcbiAgICB9XFxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XFxuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgdGFyZ2V0Ll9zZXQodGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLCB0YXJnZXRTdGFydClcXG4gIH1cXG5cXG4gIHJldHVybiBsZW5cXG59XFxuXFxuLy8gZmlsbCh2YWx1ZSwgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXFxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcXG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXFxuICBpZiAoIWVuZCkgZW5kID0gdGhpcy5sZW5ndGhcXG5cXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuZCA8IHN0YXJ0JylcXG5cXG4gIC8vIEZpbGwgMCBieXRlczsgd2UncmUgZG9uZVxcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cXG5cXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzdGFydCBvdXQgb2YgYm91bmRzJylcXG4gIGlmIChlbmQgPCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5kIG91dCBvZiBib3VuZHMnKVxcblxcbiAgdmFyIGlcXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XFxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcXG4gICAgICB0aGlzW2ldID0gdmFsdWVcXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgdmFyIGJ5dGVzID0gdXRmOFRvQnl0ZXModmFsdWUudG9TdHJpbmcoKSlcXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XFxuICAgICAgdGhpc1tpXSA9IGJ5dGVzW2kgJSBsZW5dXFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiB0aGlzXFxufVxcblxcbi8qKlxcbiAqIENyZWF0ZXMgYSBuZXcgYEFycmF5QnVmZmVyYCB3aXRoIHRoZSAqY29waWVkKiBtZW1vcnkgb2YgdGhlIGJ1ZmZlciBpbnN0YW5jZS5cXG4gKiBBZGRlZCBpbiBOb2RlIDAuMTIuIE9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBBcnJheUJ1ZmZlci5cXG4gKi9cXG5CdWZmZXIucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiB0b0FycmF5QnVmZmVyICgpIHtcXG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XFxuICAgICAgcmV0dXJuIChuZXcgQnVmZmVyKHRoaXMpKS5idWZmZXJcXG4gICAgfSBlbHNlIHtcXG4gICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpXFxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gYnVmLmJ1ZmZlclxcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCdWZmZXIudG9BcnJheUJ1ZmZlciBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpXFxuICB9XFxufVxcblxcbi8vIEhFTFBFUiBGVU5DVElPTlNcXG4vLyA9PT09PT09PT09PT09PT09XFxuXFxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxcblxcbi8qKlxcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcXG4gKi9cXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiBfYXVnbWVudCAoYXJyKSB7XFxuICBhcnIuY29uc3RydWN0b3IgPSBCdWZmZXJcXG4gIGFyci5faXNCdWZmZXIgPSB0cnVlXFxuXFxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IHNldCBtZXRob2QgYmVmb3JlIG92ZXJ3cml0aW5nXFxuICBhcnIuX3NldCA9IGFyci5zZXRcXG5cXG4gIC8vIGRlcHJlY2F0ZWRcXG4gIGFyci5nZXQgPSBCUC5nZXRcXG4gIGFyci5zZXQgPSBCUC5zZXRcXG5cXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXFxuICBhcnIudG9TdHJpbmcgPSBCUC50b1N0cmluZ1xcbiAgYXJyLnRvTG9jYWxlU3RyaW5nID0gQlAudG9TdHJpbmdcXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cXG4gIGFyci5lcXVhbHMgPSBCUC5lcXVhbHNcXG4gIGFyci5jb21wYXJlID0gQlAuY29tcGFyZVxcbiAgYXJyLmluZGV4T2YgPSBCUC5pbmRleE9mXFxuICBhcnIuY29weSA9IEJQLmNvcHlcXG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXFxuICBhcnIucmVhZFVJbnRMRSA9IEJQLnJlYWRVSW50TEVcXG4gIGFyci5yZWFkVUludEJFID0gQlAucmVhZFVJbnRCRVxcbiAgYXJyLnJlYWRVSW50OCA9IEJQLnJlYWRVSW50OFxcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxcbiAgYXJyLnJlYWRVSW50MTZCRSA9IEJQLnJlYWRVSW50MTZCRVxcbiAgYXJyLnJlYWRVSW50MzJMRSA9IEJQLnJlYWRVSW50MzJMRVxcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxcbiAgYXJyLnJlYWRJbnRMRSA9IEJQLnJlYWRJbnRMRVxcbiAgYXJyLnJlYWRJbnRCRSA9IEJQLnJlYWRJbnRCRVxcbiAgYXJyLnJlYWRJbnQ4ID0gQlAucmVhZEludDhcXG4gIGFyci5yZWFkSW50MTZMRSA9IEJQLnJlYWRJbnQxNkxFXFxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxcbiAgYXJyLnJlYWRJbnQzMkxFID0gQlAucmVhZEludDMyTEVcXG4gIGFyci5yZWFkSW50MzJCRSA9IEJQLnJlYWRJbnQzMkJFXFxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxcbiAgYXJyLnJlYWRGbG9hdEJFID0gQlAucmVhZEZsb2F0QkVcXG4gIGFyci5yZWFkRG91YmxlTEUgPSBCUC5yZWFkRG91YmxlTEVcXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcXG4gIGFyci53cml0ZVVJbnQ4ID0gQlAud3JpdGVVSW50OFxcbiAgYXJyLndyaXRlVUludExFID0gQlAud3JpdGVVSW50TEVcXG4gIGFyci53cml0ZVVJbnRCRSA9IEJQLndyaXRlVUludEJFXFxuICBhcnIud3JpdGVVSW50MTZMRSA9IEJQLndyaXRlVUludDE2TEVcXG4gIGFyci53cml0ZVVJbnQxNkJFID0gQlAud3JpdGVVSW50MTZCRVxcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXFxuICBhcnIud3JpdGVVSW50MzJCRSA9IEJQLndyaXRlVUludDMyQkVcXG4gIGFyci53cml0ZUludExFID0gQlAud3JpdGVJbnRMRVxcbiAgYXJyLndyaXRlSW50QkUgPSBCUC53cml0ZUludEJFXFxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XFxuICBhcnIud3JpdGVJbnQxNkxFID0gQlAud3JpdGVJbnQxNkxFXFxuICBhcnIud3JpdGVJbnQxNkJFID0gQlAud3JpdGVJbnQxNkJFXFxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXFxuICBhcnIud3JpdGVJbnQzMkJFID0gQlAud3JpdGVJbnQzMkJFXFxuICBhcnIud3JpdGVGbG9hdExFID0gQlAud3JpdGVGbG9hdExFXFxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXFxuICBhcnIud3JpdGVEb3VibGVMRSA9IEJQLndyaXRlRG91YmxlTEVcXG4gIGFyci53cml0ZURvdWJsZUJFID0gQlAud3JpdGVEb3VibGVCRVxcbiAgYXJyLmZpbGwgPSBCUC5maWxsXFxuICBhcnIuaW5zcGVjdCA9IEJQLmluc3BlY3RcXG4gIGFyci50b0FycmF5QnVmZmVyID0gQlAudG9BcnJheUJ1ZmZlclxcblxcbiAgcmV0dXJuIGFyclxcbn1cXG5cXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFxcXC8wLTlBLVphLXotX10vZ1xcblxcbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXFxcbiBhbmQgXFxcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcXG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXFxuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcXG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xcbiAgICBzdHIgPSBzdHIgKyAnPSdcXG4gIH1cXG4gIHJldHVybiBzdHJcXG59XFxuXFxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XFxuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXFxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXFxccyt8XFxcXHMrJC9nLCAnJylcXG59XFxuXFxuZnVuY3Rpb24gdG9IZXggKG4pIHtcXG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXFxufVxcblxcbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XFxuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XFxuICB2YXIgY29kZVBvaW50XFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXFxuICB2YXIgYnl0ZXMgPSBbXVxcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxcblxcbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XFxuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcXG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XFxuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXFxuICAgICAgICAgIGNvbnRpbnVlXFxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcXG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcXG4gICAgICAgICAgY29udGludWVcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcXG5cXG4gICAgICAgIGNvbnRpbnVlXFxuICAgICAgfVxcblxcbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcXG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XFxuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcXG4gICAgICAgIGNvbnRpbnVlXFxuICAgICAgfVxcblxcbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXFxuICAgICAgY29kZVBvaW50ID0gbGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCB8IDB4MTAwMDBcXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XFxuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxcbiAgICB9XFxuXFxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXFxuXFxuICAgIC8vIGVuY29kZSB1dGY4XFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XFxuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXFxuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXFxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcXG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcXG4gICAgICBieXRlcy5wdXNoKFxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxcbiAgICAgIClcXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXFxuICAgICAgYnl0ZXMucHVzaChcXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcXG4gICAgICApXFxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcXG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcXG4gICAgICBieXRlcy5wdXNoKFxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcXG4gICAgICApXFxuICAgIH0gZWxzZSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gYnl0ZXNcXG59XFxuXFxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcXG4gIHZhciBieXRlQXJyYXkgPSBbXVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcXG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXFxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcXG4gIH1cXG4gIHJldHVybiBieXRlQXJyYXlcXG59XFxuXFxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcXG4gIHZhciBjLCBoaSwgbG9cXG4gIHZhciBieXRlQXJyYXkgPSBbXVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcXG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXFxuXFxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxcbiAgICBoaSA9IGMgPj4gOFxcbiAgICBsbyA9IGMgJSAyNTZcXG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXFxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxcbiAgfVxcblxcbiAgcmV0dXJuIGJ5dGVBcnJheVxcbn1cXG5cXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcXG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcXG59XFxuXFxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XFxuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXFxuICB9XFxuICByZXR1cm4gaVxcbn1cXG5cXG59LHtcXFwiYmFzZTY0LWpzXFxcIjo0NCxcXFwiaWVlZTc1NFxcXCI6NDUsXFxcImlzLWFycmF5XFxcIjo0Nn1dLDQ0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG52YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xcblxcbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcXG5cXHQndXNlIHN0cmljdCc7XFxuXFxuICB2YXIgQXJyID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJylcXG4gICAgPyBVaW50OEFycmF5XFxuICAgIDogQXJyYXlcXG5cXG5cXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcXG5cXHR2YXIgU0xBU0ggID0gJy8nLmNoYXJDb2RlQXQoMClcXG5cXHR2YXIgTlVNQkVSID0gJzAnLmNoYXJDb2RlQXQoMClcXG5cXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcXG5cXHR2YXIgVVBQRVIgID0gJ0EnLmNoYXJDb2RlQXQoMClcXG5cXHR2YXIgUExVU19VUkxfU0FGRSA9ICctJy5jaGFyQ29kZUF0KDApXFxuXFx0dmFyIFNMQVNIX1VSTF9TQUZFID0gJ18nLmNoYXJDb2RlQXQoMClcXG5cXG5cXHRmdW5jdGlvbiBkZWNvZGUgKGVsdCkge1xcblxcdFxcdHZhciBjb2RlID0gZWx0LmNoYXJDb2RlQXQoMClcXG5cXHRcXHRpZiAoY29kZSA9PT0gUExVUyB8fFxcblxcdFxcdCAgICBjb2RlID09PSBQTFVTX1VSTF9TQUZFKVxcblxcdFxcdFxcdHJldHVybiA2MiAvLyAnKydcXG5cXHRcXHRpZiAoY29kZSA9PT0gU0xBU0ggfHxcXG5cXHRcXHQgICAgY29kZSA9PT0gU0xBU0hfVVJMX1NBRkUpXFxuXFx0XFx0XFx0cmV0dXJuIDYzIC8vICcvJ1xcblxcdFxcdGlmIChjb2RlIDwgTlVNQkVSKVxcblxcdFxcdFxcdHJldHVybiAtMSAvL25vIG1hdGNoXFxuXFx0XFx0aWYgKGNvZGUgPCBOVU1CRVIgKyAxMClcXG5cXHRcXHRcXHRyZXR1cm4gY29kZSAtIE5VTUJFUiArIDI2ICsgMjZcXG5cXHRcXHRpZiAoY29kZSA8IFVQUEVSICsgMjYpXFxuXFx0XFx0XFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxcblxcdFxcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcXG5cXHRcXHRcXHRyZXR1cm4gY29kZSAtIExPV0VSICsgMjZcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xcblxcdFxcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXFxuXFxuXFx0XFx0aWYgKGI2NC5sZW5ndGggJSA0ID4gMCkge1xcblxcdFxcdFxcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXFxuXFx0XFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxcblxcdFxcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxcblxcdFxcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xcblxcdFxcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcXG5cXHRcXHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxcblxcdFxcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxcblxcblxcdFxcdC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxcblxcdFxcdGFyciA9IG5ldyBBcnIoYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxcblxcblxcdFxcdC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcXG5cXHRcXHRsID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSA0IDogYjY0Lmxlbmd0aFxcblxcblxcdFxcdHZhciBMID0gMFxcblxcblxcdFxcdGZ1bmN0aW9uIHB1c2ggKHYpIHtcXG5cXHRcXHRcXHRhcnJbTCsrXSA9IHZcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xcblxcdFxcdFxcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTgpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgMTIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPDwgNikgfCBkZWNvZGUoYjY0LmNoYXJBdChpICsgMykpXFxuXFx0XFx0XFx0cHVzaCgodG1wICYgMHhGRjAwMDApID4+IDE2KVxcblxcdFxcdFxcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcXG5cXHRcXHRcXHRwdXNoKHRtcCAmIDB4RkYpXFxuXFx0XFx0fVxcblxcblxcdFxcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcXG5cXHRcXHRcXHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcXG5cXHRcXHRcXHRwdXNoKHRtcCAmIDB4RkYpXFxuXFx0XFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcXG5cXHRcXHRcXHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDEwKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDQpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPj4gMilcXG5cXHRcXHRcXHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxcblxcdFxcdFxcdHB1c2godG1wICYgMHhGRilcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGFyclxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0ICh1aW50OCkge1xcblxcdFxcdHZhciBpLFxcblxcdFxcdFxcdGV4dHJhQnl0ZXMgPSB1aW50OC5sZW5ndGggJSAzLCAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xcblxcdFxcdFxcdG91dHB1dCA9IFxcXCJcXFwiLFxcblxcdFxcdFxcdHRlbXAsIGxlbmd0aFxcblxcblxcdFxcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGxvb2t1cC5jaGFyQXQobnVtKVxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xcblxcdFxcdFxcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXFxuXFx0XFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XFxuXFx0XFx0XFx0dGVtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcXG5cXHRcXHRcXHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcXG5cXHRcXHRzd2l0Y2ggKGV4dHJhQnl0ZXMpIHtcXG5cXHRcXHRcXHRjYXNlIDE6XFxuXFx0XFx0XFx0XFx0dGVtcCA9IHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdXFxuXFx0XFx0XFx0XFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXFxuXFx0XFx0XFx0XFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCA0KSAmIDB4M0YpXFxuXFx0XFx0XFx0XFx0b3V0cHV0ICs9ICc9PSdcXG5cXHRcXHRcXHRcXHRicmVha1xcblxcdFxcdFxcdGNhc2UgMjpcXG5cXHRcXHRcXHRcXHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxcblxcdFxcdFxcdFxcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAxMClcXG5cXHRcXHRcXHRcXHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wID4+IDQpICYgMHgzRilcXG5cXHRcXHRcXHRcXHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcXG5cXHRcXHRcXHRcXHRvdXRwdXQgKz0gJz0nXFxuXFx0XFx0XFx0XFx0YnJlYWtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIG91dHB1dFxcblxcdH1cXG5cXG5cXHRleHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXlcXG5cXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XFxufSh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyAodGhpcy5iYXNlNjRqcyA9IHt9KSA6IGV4cG9ydHMpKVxcblxcbn0se31dLDQ1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xcbiAgdmFyIGUsIG1cXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXFxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXFxuICB2YXIgbkJpdHMgPSAtN1xcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXFxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxcblxcbiAgaSArPSBkXFxuXFxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxcbiAgcyA+Pj0gKC1uQml0cylcXG4gIG5CaXRzICs9IGVMZW5cXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XFxuXFxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxcbiAgZSA+Pj0gKC1uQml0cylcXG4gIG5CaXRzICs9IG1MZW5cXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XFxuXFxuICBpZiAoZSA9PT0gMCkge1xcbiAgICBlID0gMSAtIGVCaWFzXFxuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcXG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXFxuICB9IGVsc2Uge1xcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXFxuICAgIGUgPSBlIC0gZUJpYXNcXG4gIH1cXG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXFxufVxcblxcbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcXG4gIHZhciBlLCBtLCBjXFxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXFxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxcblxcbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcXG5cXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XFxuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxcbiAgICBlID0gZU1heFxcbiAgfSBlbHNlIHtcXG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXFxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcXG4gICAgICBlLS1cXG4gICAgICBjICo9IDJcXG4gICAgfVxcbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcXG4gICAgICB2YWx1ZSArPSBydCAvIGNcXG4gICAgfSBlbHNlIHtcXG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcXG4gICAgfVxcbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcXG4gICAgICBlKytcXG4gICAgICBjIC89IDJcXG4gICAgfVxcblxcbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcXG4gICAgICBtID0gMFxcbiAgICAgIGUgPSBlTWF4XFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcXG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcXG4gICAgICBlID0gZSArIGVCaWFzXFxuICAgIH0gZWxzZSB7XFxuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXFxuICAgICAgZSA9IDBcXG4gICAgfVxcbiAgfVxcblxcbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cXG5cXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cXG4gIGVMZW4gKz0gbUxlblxcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxcblxcbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XFxufVxcblxcbn0se31dLDQ2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5cXG4vKipcXG4gKiBpc0FycmF5XFxuICovXFxuXFxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xcblxcbi8qKlxcbiAqIHRvU3RyaW5nXFxuICovXFxuXFxudmFyIHN0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XFxuXFxuLyoqXFxuICogV2hldGhlciBvciBub3QgdGhlIGdpdmVuIGB2YWxgXFxuICogaXMgYW4gYXJyYXkuXFxuICpcXG4gKiBleGFtcGxlOlxcbiAqXFxuICogICAgICAgIGlzQXJyYXkoW10pO1xcbiAqICAgICAgICAvLyA+IHRydWVcXG4gKiAgICAgICAgaXNBcnJheShhcmd1bWVudHMpO1xcbiAqICAgICAgICAvLyA+IGZhbHNlXFxuICogICAgICAgIGlzQXJyYXkoJycpO1xcbiAqICAgICAgICAvLyA+IGZhbHNlXFxuICpcXG4gKiBAcGFyYW0ge21peGVkfSB2YWxcXG4gKiBAcmV0dXJuIHtib29sfVxcbiAqL1xcblxcbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheSB8fCBmdW5jdGlvbiAodmFsKSB7XFxuICByZXR1cm4gISEgdmFsICYmICdbb2JqZWN0IEFycmF5XScgPT0gc3RyLmNhbGwodmFsKTtcXG59O1xcblxcbn0se31dLDQ3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXFxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxcbi8vIFxcXCJTb2Z0d2FyZVxcXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcXFwiQVMgSVNcXFwiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXFxuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXFxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cXG5cXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XFxuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XFxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xcbn1cXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcXG5cXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XFxuXFxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXFxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xcblxcbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xcbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcXG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcXG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XFxuXFxuICBpZiAoIXRoaXMuX2V2ZW50cylcXG4gICAgdGhpcy5fZXZlbnRzID0ge307XFxuXFxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXFxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XFxuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XFxuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcXG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxcbiAgICAgIH1cXG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcXFwiZXJyb3JcXFwiIGV2ZW50LicpO1xcbiAgICB9XFxuICB9XFxuXFxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xcblxcbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxcbiAgICByZXR1cm4gZmFsc2U7XFxuXFxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgICAvLyBmYXN0IGNhc2VzXFxuICAgICAgY2FzZSAxOlxcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSAyOlxcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlIDM6XFxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgLy8gc2xvd2VyXFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XFxuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxcbiAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcXG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XFxuICAgIH1cXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcXG4gICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcXG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcXG4gICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xcblxcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XFxuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XFxuICB9XFxuXFxuICByZXR1cm4gdHJ1ZTtcXG59O1xcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xcbiAgdmFyIG07XFxuXFxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xcblxcbiAgaWYgKCF0aGlzLl9ldmVudHMpXFxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xcblxcbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXFxcIm5ld0xpc3RlbmVyXFxcIiEgQmVmb3JlXFxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcXFwibmV3TGlzdGVuZXJcXFwiLlxcbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XFxuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcXG5cXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XFxuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXFxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcXG4gIGVsc2VcXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXFxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcXG5cXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXFxuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xcbiAgICB2YXIgbTtcXG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XFxuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcXG4gICAgfSBlbHNlIHtcXG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XFxuICAgIH1cXG5cXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcXG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcXG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcXG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXFxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XFxuXFxuICB2YXIgZmlyZWQgPSBmYWxzZTtcXG5cXG4gIGZ1bmN0aW9uIGcoKSB7XFxuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XFxuXFxuICAgIGlmICghZmlyZWQpIHtcXG4gICAgICBmaXJlZCA9IHRydWU7XFxuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xcbiAgdGhpcy5vbih0eXBlLCBnKTtcXG5cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcXG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xcblxcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcXG5cXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXFxuICAgIHJldHVybiB0aGlzO1xcblxcbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcXG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xcbiAgcG9zaXRpb24gPSAtMTtcXG5cXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XFxuXFxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XFxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcXG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcXG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XFxuICAgICAgICBwb3NpdGlvbiA9IGk7XFxuICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcXG4gICAgICByZXR1cm4gdGhpcztcXG5cXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XFxuICAgICAgbGlzdC5sZW5ndGggPSAwO1xcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XFxuICAgIH0gZWxzZSB7XFxuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xcbiAgICB9XFxuXFxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXFxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcXG4gIH1cXG5cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XFxuICB2YXIga2V5LCBsaXN0ZW5lcnM7XFxuXFxuICBpZiAoIXRoaXMuX2V2ZW50cylcXG4gICAgcmV0dXJuIHRoaXM7XFxuXFxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcXG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcblxcbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcXG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcXG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xcbiAgICB9XFxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuXFxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XFxuXFxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XFxuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcXG4gIH0gZWxzZSB7XFxuICAgIC8vIExJRk8gb3JkZXJcXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXFxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcXG4gIH1cXG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XFxuXFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xcbiAgdmFyIHJldDtcXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXFxuICAgIHJldCA9IFtdO1xcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcXG4gIGVsc2VcXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XFxuICByZXR1cm4gcmV0O1xcbn07XFxuXFxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XFxuICB2YXIgcmV0O1xcbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1t0eXBlXSlcXG4gICAgcmV0ID0gMDtcXG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24oZW1pdHRlci5fZXZlbnRzW3R5cGVdKSlcXG4gICAgcmV0ID0gMTtcXG4gIGVsc2VcXG4gICAgcmV0ID0gZW1pdHRlci5fZXZlbnRzW3R5cGVdLmxlbmd0aDtcXG4gIHJldHVybiByZXQ7XFxufTtcXG5cXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XFxufVxcblxcbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xcbn1cXG5cXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XFxufVxcblxcbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xcbn1cXG5cXG59LHt9XSw0ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XFxuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcXG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcXG4gICAgICBjb25zdHJ1Y3Rvcjoge1xcbiAgICAgICAgdmFsdWU6IGN0b3IsXFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXFxuICAgICAgfVxcbiAgICB9KTtcXG4gIH07XFxufSBlbHNlIHtcXG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXFxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxcbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXFxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXFxuICB9XFxufVxcblxcbn0se31dLDQ5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XFxufTtcXG5cXG59LHt9XSw1MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuZXhwb3J0cy5lbmRpYW5uZXNzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0xFJyB9O1xcblxcbmV4cG9ydHMuaG9zdG5hbWUgPSBmdW5jdGlvbiAoKSB7XFxuICAgIGlmICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICByZXR1cm4gbG9jYXRpb24uaG9zdG5hbWVcXG4gICAgfVxcbiAgICBlbHNlIHJldHVybiAnJztcXG59O1xcblxcbmV4cG9ydHMubG9hZGF2ZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdIH07XFxuXFxuZXhwb3J0cy51cHRpbWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwIH07XFxuXFxuZXhwb3J0cy5mcmVlbWVtID0gZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcXG59O1xcblxcbmV4cG9ydHMudG90YWxtZW0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xcbn07XFxuXFxuZXhwb3J0cy5jcHVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW10gfTtcXG5cXG5leHBvcnRzLnR5cGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnQnJvd3NlcicgfTtcXG5cXG5leHBvcnRzLnJlbGVhc2UgPSBmdW5jdGlvbiAoKSB7XFxuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5hcHBWZXJzaW9uO1xcbiAgICB9XFxuICAgIHJldHVybiAnJztcXG59O1xcblxcbmV4cG9ydHMubmV0d29ya0ludGVyZmFjZXNcXG49IGV4cG9ydHMuZ2V0TmV0d29ya0ludGVyZmFjZXNcXG49IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHt9IH07XFxuXFxuZXhwb3J0cy5hcmNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ2phdmFzY3JpcHQnIH07XFxuXFxuZXhwb3J0cy5wbGF0Zm9ybSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdicm93c2VyJyB9O1xcblxcbmV4cG9ydHMudG1wZGlyID0gZXhwb3J0cy50bXBEaXIgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiAnL3RtcCc7XFxufTtcXG5cXG5leHBvcnRzLkVPTCA9ICdcXFxcbic7XFxuXFxufSx7fV0sNTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxcblxcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcXG52YXIgcXVldWUgPSBbXTtcXG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcXG52YXIgY3VycmVudFF1ZXVlO1xcbnZhciBxdWV1ZUluZGV4ID0gLTE7XFxuXFxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcXG4gICAgfVxcbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XFxuICAgICAgICBkcmFpblF1ZXVlKCk7XFxuICAgIH1cXG59XFxuXFxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcXG4gICAgaWYgKGRyYWluaW5nKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XFxuICAgIGRyYWluaW5nID0gdHJ1ZTtcXG5cXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcXG4gICAgd2hpbGUobGVuKSB7XFxuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcXG4gICAgICAgIHF1ZXVlID0gW107XFxuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XFxuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xcbiAgICB9XFxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XFxuICAgIGRyYWluaW5nID0gZmFsc2U7XFxuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcXG59XFxuXFxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcXG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcXG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcXG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XFxuICAgIH1cXG59O1xcblxcbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcXG4gICAgdGhpcy5mdW4gPSBmdW47XFxuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcXG59XFxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcXG59O1xcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XFxucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcXG5wcm9jZXNzLmVudiA9IHt9O1xcbnByb2Nlc3MuYXJndiA9IFtdO1xcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcXG5cXG5mdW5jdGlvbiBub29wKCkge31cXG5cXG5wcm9jZXNzLm9uID0gbm9vcDtcXG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcXG5wcm9jZXNzLm9uY2UgPSBub29wO1xcbnByb2Nlc3Mub2ZmID0gbm9vcDtcXG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcXG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XFxucHJvY2Vzcy5lbWl0ID0gbm9vcDtcXG5cXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XFxufTtcXG5cXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XFxufTtcXG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xcblxcbn0se31dLDUyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXFxcIi4vbGliL19zdHJlYW1fZHVwbGV4LmpzXFxcIilcXG5cXG59LHtcXFwiLi9saWIvX3N0cmVhbV9kdXBsZXguanNcXFwiOjUzfV0sNTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcXG4vLyBcXFwiU29mdHdhcmVcXFwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXFxuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcXG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXFxcIkFTIElTXFxcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xcbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXFxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXFxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXFxuXFxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xcbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cXG4vLyBXcml0YWJsZS5cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xcbiAgdmFyIGtleXMgPSBbXTtcXG4gIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xcbiAgcmV0dXJuIGtleXM7XFxufVxcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcXG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcXG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcXG5cXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xcblxcbmZvckVhY2gob2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpLCBmdW5jdGlvbihtZXRob2QpIHtcXG4gIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKVxcbiAgICBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcXG59KTtcXG5cXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpXFxuICAgIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xcblxcbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcXG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XFxuXFxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSlcXG4gICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xcblxcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpXFxuICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcXG5cXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XFxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKVxcbiAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcXG5cXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xcbn1cXG5cXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXFxuZnVuY3Rpb24gb25lbmQoKSB7XFxuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZClcXG4gICAgcmV0dXJuO1xcblxcbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxcbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXFxuICBwcm9jZXNzLm5leHRUaWNrKHRoaXMuZW5kLmJpbmQodGhpcykpO1xcbn1cXG5cXG5mdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgZih4c1tpXSwgaSk7XFxuICB9XFxufVxcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCIuL19zdHJlYW1fcmVhZGFibGVcXFwiOjU1LFxcXCIuL19zdHJlYW1fd3JpdGFibGVcXFwiOjU3LFxcXCJfcHJvY2Vzc1xcXCI6NTEsXFxcImNvcmUtdXRpbC1pc1xcXCI6NTgsXFxcImluaGVyaXRzXFxcIjo0OH1dLDU0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXFxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxcbi8vIFxcXCJTb2Z0d2FyZVxcXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcXFwiQVMgSVNcXFwiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXFxuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXFxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cXG5cXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxcblxcbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XFxuXFxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XFxudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcXG5cXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XFxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKVxcbiAgICByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xcblxcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XFxufVxcblxcblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xcbiAgY2IobnVsbCwgY2h1bmspO1xcbn07XFxuXFxufSx7XFxcIi4vX3N0cmVhbV90cmFuc2Zvcm1cXFwiOjU2LFxcXCJjb3JlLXV0aWwtaXNcXFwiOjU4LFxcXCJpbmhlcml0c1xcXCI6NDh9XSw1NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXFxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxcbi8vIFxcXCJTb2Z0d2FyZVxcXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcXFwiQVMgSVNcXFwiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXFxuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXFxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xcblxcbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbmlmICghRUUubGlzdGVuZXJDb3VudCkgRUUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcXG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XFxufTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbnZhciBTdHJpbmdEZWNvZGVyO1xcblxcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIGRlYnVnID0gcmVxdWlyZSgndXRpbCcpO1xcbmlmIChkZWJ1ZyAmJiBkZWJ1Zy5kZWJ1Z2xvZykge1xcbiAgZGVidWcgPSBkZWJ1Zy5kZWJ1Z2xvZygnc3RyZWFtJyk7XFxufSBlbHNlIHtcXG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XFxufVxcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcblxcbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XFxuXFxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcXG4gIHZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XFxuXFxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG5cXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXFxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFxcXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXFxcIlxcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcXG4gIHZhciBkZWZhdWx0SHdtID0gb3B0aW9ucy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XFxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiBkZWZhdWx0SHdtO1xcblxcbiAgLy8gY2FzdCB0byBpbnRzLlxcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XFxuXFxuICB0aGlzLmJ1ZmZlciA9IFtdO1xcbiAgdGhpcy5sZW5ndGggPSAwO1xcbiAgdGhpcy5waXBlcyA9IG51bGw7XFxuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcXG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XFxuXFxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XFxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcXFwibGF0ZXJcXFwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xcbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXFxuICB0aGlzLnN5bmMgPSB0cnVlO1xcblxcbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcXG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxcbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcXG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XFxuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XFxuXFxuXFxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xcbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xcblxcbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleClcXG4gICAgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XFxuXFxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXFxuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXFxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXFxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcXG5cXG4gIC8vIHdoZW4gcGlwaW5nLCB3ZSBvbmx5IGNhcmUgYWJvdXQgJ3JlYWRhYmxlJyBldmVudHMgdGhhdCBoYXBwZW5cXG4gIC8vIGFmdGVyIHJlYWQoKWluZyBhbGwgdGhlIGJ5dGVzIGFuZCBub3QgZ2V0dGluZyBhbnkgcHVzaGJhY2suXFxuICB0aGlzLnJhbk91dCA9IGZhbHNlO1xcblxcbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XFxuXFxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XFxuXFxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XFxuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpXFxuICAgICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XFxuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xcbiAgdmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcXG5cXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpXFxuICAgIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XFxuXFxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XFxuXFxuICAvLyBsZWdhY3lcXG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xcblxcbiAgU3RyZWFtLmNhbGwodGhpcyk7XFxufVxcblxcbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxcbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZykge1xcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcXG5cXG4gIGlmICh1dGlsLmlzU3RyaW5nKGNodW5rKSAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xcbiAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcXG4gICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xcbiAgICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xcbiAgICAgIGVuY29kaW5nID0gJyc7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlKTtcXG59O1xcblxcbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXFxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbihjaHVuaykge1xcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgJycsIHRydWUpO1xcbn07XFxuXFxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQpIHtcXG4gIHZhciBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xcbiAgaWYgKGVyKSB7XFxuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcXG4gIH0gZWxzZSBpZiAodXRpbC5pc051bGxPclVuZGVmaW5lZChjaHVuaykpIHtcXG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xcbiAgICBpZiAoIXN0YXRlLmVuZGVkKVxcbiAgICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XFxuICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xcbiAgICBpZiAoc3RhdGUuZW5kZWQgJiYgIWFkZFRvRnJvbnQpIHtcXG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcXG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcXG4gICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRFbWl0dGVkICYmIGFkZFRvRnJvbnQpIHtcXG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcXG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhYWRkVG9Gcm9udCAmJiAhZW5jb2RpbmcpXFxuICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xcblxcbiAgICAgIGlmICghYWRkVG9Gcm9udClcXG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcXG5cXG4gICAgICAvLyBpZiB3ZSB3YW50IHRoZSBkYXRhIG5vdywganVzdCBlbWl0IGl0LlxcbiAgICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XFxuICAgICAgICBzdHJlYW0ucmVhZCgwKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cXG4gICAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcXG4gICAgICAgIGlmIChhZGRUb0Zyb250KVxcbiAgICAgICAgICBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7XFxuICAgICAgICBlbHNlXFxuICAgICAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcXG5cXG4gICAgICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpXFxuICAgICAgICAgIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xcbiAgICB9XFxuICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XFxuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcXG4gIH1cXG5cXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xcbn1cXG5cXG5cXG5cXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxcbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXFxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcXG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXFxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XFxuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmXFxuICAgICAgICAgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fFxcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8XFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9PT0gMCk7XFxufVxcblxcbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxcblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uKGVuYykge1xcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKVxcbiAgICBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XFxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gMTI4TUJcXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xcbmZ1bmN0aW9uIHJvdW5kVXBUb05leHRQb3dlck9mMihuKSB7XFxuICBpZiAobiA+PSBNQVhfSFdNKSB7XFxuICAgIG4gPSBNQVhfSFdNO1xcbiAgfSBlbHNlIHtcXG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMlxcbiAgICBuLS07XFxuICAgIGZvciAodmFyIHAgPSAxOyBwIDwgMzI7IHAgPDw9IDEpIG4gfD0gbiA+PiBwO1xcbiAgICBuKys7XFxuICB9XFxuICByZXR1cm4gbjtcXG59XFxuXFxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZClcXG4gICAgcmV0dXJuIDA7XFxuXFxuICBpZiAoc3RhdGUub2JqZWN0TW9kZSlcXG4gICAgcmV0dXJuIG4gPT09IDAgPyAwIDogMTtcXG5cXG4gIGlmIChpc05hTihuKSB8fCB1dGlsLmlzTnVsbChuKSkge1xcbiAgICAvLyBvbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUuYnVmZmVyLmxlbmd0aClcXG4gICAgICByZXR1cm4gc3RhdGUuYnVmZmVyWzBdLmxlbmd0aDtcXG4gICAgZWxzZVxcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XFxuICB9XFxuXFxuICBpZiAobiA8PSAwKVxcbiAgICByZXR1cm4gMDtcXG5cXG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSB0YXJnZXQgYnVmZmVyIGxldmVsLFxcbiAgLy8gdGhlbiByYWlzZSB0aGUgd2F0ZXIgbWFyay4gIEJ1bXAgdXAgdG8gdGhlIG5leHQgaGlnaGVzdFxcbiAgLy8gcG93ZXIgb2YgMiwgdG8gcHJldmVudCBpbmNyZWFzaW5nIGl0IGV4Y2Vzc2l2ZWx5IGluIHRpbnlcXG4gIC8vIGFtb3VudHMuXFxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspXFxuICAgIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSByb3VuZFVwVG9OZXh0UG93ZXJPZjIobik7XFxuXFxuICAvLyBkb24ndCBoYXZlIHRoYXQgbXVjaC4gIHJldHVybiBudWxsLCB1bmxlc3Mgd2UndmUgZW5kZWQuXFxuICBpZiAobiA+IHN0YXRlLmxlbmd0aCkge1xcbiAgICBpZiAoIXN0YXRlLmVuZGVkKSB7XFxuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcXG4gICAgICByZXR1cm4gMDtcXG4gICAgfSBlbHNlXFxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcXG4gIH1cXG5cXG4gIHJldHVybiBuO1xcbn1cXG5cXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxcblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24obikge1xcbiAgZGVidWcoJ3JlYWQnLCBuKTtcXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XFxuICB2YXIgbk9yaWcgPSBuO1xcblxcbiAgaWYgKCF1dGlsLmlzTnVtYmVyKG4pIHx8IG4gPiAwKVxcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcXG5cXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxcbiAgaWYgKG4gPT09IDAgJiZcXG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgJiZcXG4gICAgICAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XFxuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZClcXG4gICAgICBlbmRSZWFkYWJsZSh0aGlzKTtcXG4gICAgZWxzZVxcbiAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcXG4gICAgcmV0dXJuIG51bGw7XFxuICB9XFxuXFxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XFxuXFxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXFxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKVxcbiAgICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xcbiAgICByZXR1cm4gbnVsbDtcXG4gIH1cXG5cXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxcbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxcbiAgLy9cXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xcbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cXG4gIC8vXFxuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxcbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXFxuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXFxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcXG4gIC8vICdyZWFkYWJsZScgZXRjLlxcbiAgLy9cXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cXG5cXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XFxuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XFxuXFxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcXG4gICAgZG9SZWFkID0gdHJ1ZTtcXG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcXG4gIH1cXG5cXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XFxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXFxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xcbiAgICBkb1JlYWQgPSBmYWxzZTtcXG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xcbiAgfVxcblxcbiAgaWYgKGRvUmVhZCkge1xcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcXG4gICAgc3RhdGUuc3luYyA9IHRydWU7XFxuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXFxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApXFxuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcXG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XFxuICB9XFxuXFxuICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxcbiAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxcbiAgaWYgKGRvUmVhZCAmJiAhc3RhdGUucmVhZGluZylcXG4gICAgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcXG5cXG4gIHZhciByZXQ7XFxuICBpZiAobiA+IDApXFxuICAgIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtcXG4gIGVsc2VcXG4gICAgcmV0ID0gbnVsbDtcXG5cXG4gIGlmICh1dGlsLmlzTnVsbChyZXQpKSB7XFxuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XFxuICAgIG4gPSAwO1xcbiAgfVxcblxcbiAgc3RhdGUubGVuZ3RoIC09IG47XFxuXFxuICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcXG4gIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLmVuZGVkKVxcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xcblxcbiAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxcbiAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMClcXG4gICAgZW5kUmVhZGFibGUodGhpcyk7XFxuXFxuICBpZiAoIXV0aWwuaXNOdWxsKHJldCkpXFxuICAgIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XFxuXFxuICByZXR1cm4gcmV0O1xcbn07XFxuXFxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xcbiAgdmFyIGVyID0gbnVsbDtcXG4gIGlmICghdXRpbC5pc0J1ZmZlcihjaHVuaykgJiZcXG4gICAgICAhdXRpbC5pc1N0cmluZyhjaHVuaykgJiZcXG4gICAgICAhdXRpbC5pc051bGxPclVuZGVmaW5lZChjaHVuaykgJiZcXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcXG4gIH1cXG4gIHJldHVybiBlcjtcXG59XFxuXFxuXFxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XFxuICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcXG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcXG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcXG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XFxuICAgIH1cXG4gIH1cXG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcXG5cXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxcbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XFxufVxcblxcbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XFxuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XFxuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcXG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XFxuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcXG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcXG4gICAgaWYgKHN0YXRlLnN5bmMpXFxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcXG4gICAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcXG4gICAgICB9KTtcXG4gICAgZWxzZVxcbiAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcXG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XFxuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcXG4gIGZsb3coc3RyZWFtKTtcXG59XFxuXFxuXFxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcXG4vLyBpdCdzIGluIHByb2dyZXNzLlxcbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcXG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcXG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xcbiAgICAgIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpO1xcbiAgICB9KTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcXG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiZcXG4gICAgICAgICBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XFxuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xcbiAgICBzdHJlYW0ucmVhZCgwKTtcXG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXFxuICAgICAgYnJlYWs7XFxuICAgIGVsc2VcXG4gICAgICBsZW4gPSBzdGF0ZS5sZW5ndGg7XFxuICB9XFxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xcbn1cXG5cXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXFxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXFxcImxlbmd0aFxcXCIgaXMgc29tZXdoYXRcXG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXFxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24obikge1xcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xcbn07XFxuXFxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBwaXBlT3B0cykge1xcbiAgdmFyIHNyYyA9IHRoaXM7XFxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xcblxcbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XFxuICAgIGNhc2UgMDpcXG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XFxuICAgICAgYnJlYWs7XFxuICAgIGNhc2UgMTpcXG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XFxuICAgICAgYnJlYWs7XFxuICAgIGRlZmF1bHQ6XFxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcXG4gICAgICBicmVhaztcXG4gIH1cXG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcXG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XFxuXFxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmXFxuICAgICAgICAgICAgICBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJlxcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XFxuXFxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogY2xlYW51cDtcXG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKVxcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVuZEZuKTtcXG4gIGVsc2VcXG4gICAgc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcXG5cXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcXG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlKSB7XFxuICAgIGRlYnVnKCdvbnVucGlwZScpO1xcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xcbiAgICAgIGNsZWFudXAoKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gb25lbmQoKSB7XFxuICAgIGRlYnVnKCdvbmVuZCcpO1xcbiAgICBkZXN0LmVuZCgpO1xcbiAgfVxcblxcbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXFxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xcbiAgLy8gdG9vIHNsb3cuXFxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XFxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xcblxcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcXG4gICAgZGVidWcoJ2NsZWFudXAnKTtcXG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XFxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XFxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XFxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcXG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XFxuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XFxuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XFxuXFxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXFxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJlxcbiAgICAgICAgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSlcXG4gICAgICBvbmRyYWluKCk7XFxuICB9XFxuXFxuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XFxuICAgIGRlYnVnKCdvbmRhdGEnKTtcXG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xcbiAgICBpZiAoZmFsc2UgPT09IHJldCkge1xcbiAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLFxcbiAgICAgICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcXG4gICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xcbiAgICAgIHNyYy5wYXVzZSgpO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcXG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XFxuICAgIHVucGlwZSgpO1xcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMClcXG4gICAgICBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xcbiAgfVxcbiAgLy8gVGhpcyBpcyBhIGJydXRhbGx5IHVnbHkgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlclxcbiAgLy8gaXMgYXR0YWNoZWQgYmVmb3JlIGFueSB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy5cXG4gIGlmICghZGVzdC5fZXZlbnRzIHx8ICFkZXN0Ll9ldmVudHMuZXJyb3IpXFxuICAgIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XFxuICBlbHNlIGlmIChpc0FycmF5KGRlc3QuX2V2ZW50cy5lcnJvcikpXFxuICAgIGRlc3QuX2V2ZW50cy5lcnJvci51bnNoaWZ0KG9uZXJyb3IpO1xcbiAgZWxzZVxcbiAgICBkZXN0Ll9ldmVudHMuZXJyb3IgPSBbb25lcnJvciwgZGVzdC5fZXZlbnRzLmVycm9yXTtcXG5cXG5cXG5cXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXFxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XFxuICAgIHVucGlwZSgpO1xcbiAgfVxcbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XFxuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xcbiAgICB1bnBpcGUoKTtcXG4gIH1cXG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xcblxcbiAgZnVuY3Rpb24gdW5waXBlKCkge1xcbiAgICBkZWJ1ZygndW5waXBlJyk7XFxuICAgIHNyYy51bnBpcGUoZGVzdCk7XFxuICB9XFxuXFxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xcbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcXG5cXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcXG4gICAgc3JjLnJlc3VtZSgpO1xcbiAgfVxcblxcbiAgcmV0dXJuIGRlc3Q7XFxufTtcXG5cXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcXG4gIHJldHVybiBmdW5jdGlvbigpIHtcXG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pXFxuICAgICAgc3RhdGUuYXdhaXREcmFpbi0tO1xcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRS5saXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xcbiAgICAgIGZsb3coc3JjKTtcXG4gICAgfVxcbiAgfTtcXG59XFxuXFxuXFxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uKGRlc3QpIHtcXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XFxuXFxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXFxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMClcXG4gICAgcmV0dXJuIHRoaXM7XFxuXFxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXFxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpXFxuICAgICAgcmV0dXJuIHRoaXM7XFxuXFxuICAgIGlmICghZGVzdClcXG4gICAgICBkZXN0ID0gc3RhdGUucGlwZXM7XFxuXFxuICAgIC8vIGdvdCBhIG1hdGNoLlxcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XFxuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XFxuICAgIGlmIChkZXN0KVxcbiAgICAgIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcblxcbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cXG5cXG4gIGlmICghZGVzdCkge1xcbiAgICAvLyByZW1vdmUgYWxsLlxcbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcXG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XFxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcXG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XFxuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcXG5cXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcXG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuXFxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxcbiAgdmFyIGkgPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcXG4gIGlmIChpID09PSAtMSlcXG4gICAgcmV0dXJuIHRoaXM7XFxuXFxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaSwgMSk7XFxuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XFxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSlcXG4gICAgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcXG5cXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XFxuXFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3JcXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2LCBmbikge1xcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xcblxcbiAgLy8gSWYgbGlzdGVuaW5nIHRvIGRhdGEsIGFuZCBpdCBoYXMgbm90IGV4cGxpY2l0bHkgYmVlbiBwYXVzZWQsXFxuICAvLyB0aGVuIGNhbGwgcmVzdW1lIHRvIHN0YXJ0IHRoZSBmbG93IG9mIGRhdGEgb24gdGhlIG5leHQgdGljay5cXG4gIGlmIChldiA9PT0gJ2RhdGEnICYmIGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcXG4gICAgdGhpcy5yZXN1bWUoKTtcXG4gIH1cXG5cXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyAmJiB0aGlzLnJlYWRhYmxlKSB7XFxuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XFxuICAgIGlmICghc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcXG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRydWU7XFxuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XFxuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcXG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcXG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XFxuICAgICAgICAgIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcXG4gICAgICAgICAgc2VsZi5yZWFkKDApO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcXG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzLCBzdGF0ZSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gcmVzO1xcbn07XFxuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xcblxcbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXFxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xcbiAgICBkZWJ1ZygncmVzdW1lJyk7XFxuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xcbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcXG4gICAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xcbiAgICAgIHRoaXMucmVhZCgwKTtcXG4gICAgfVxcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xcbiAgfVxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcXG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcXG4gICAgICByZXN1bWVfKHN0cmVhbSwgc3RhdGUpO1xcbiAgICB9KTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XFxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcXG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcXG4gIGZsb3coc3RyZWFtKTtcXG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKVxcbiAgICBzdHJlYW0ucmVhZCgwKTtcXG59XFxuXFxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XFxuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcXG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XFxuICAgIGRlYnVnKCdwYXVzZScpO1xcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcXG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xcbiAgfVxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcXG4gIGlmIChzdGF0ZS5mbG93aW5nKSB7XFxuICAgIGRvIHtcXG4gICAgICB2YXIgY2h1bmsgPSBzdHJlYW0ucmVhZCgpO1xcbiAgICB9IHdoaWxlIChudWxsICE9PSBjaHVuayAmJiBzdGF0ZS5mbG93aW5nKTtcXG4gIH1cXG59XFxuXFxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXFxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXFxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbihzdHJlYW0pIHtcXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XFxuICB2YXIgcGF1c2VkID0gZmFsc2U7XFxuXFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcXG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XFxuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcXG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKVxcbiAgICAgICAgc2VsZi5wdXNoKGNodW5rKTtcXG4gICAgfVxcblxcbiAgICBzZWxmLnB1c2gobnVsbCk7XFxuICB9KTtcXG5cXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uKGNodW5rKSB7XFxuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcXG4gICAgaWYgKHN0YXRlLmRlY29kZXIpXFxuICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcXG4gICAgaWYgKCFjaHVuayB8fCAhc3RhdGUub2JqZWN0TW9kZSAmJiAhY2h1bmsubGVuZ3RoKVxcbiAgICAgIHJldHVybjtcXG5cXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XFxuICAgIGlmICghcmV0KSB7XFxuICAgICAgcGF1c2VkID0gdHJ1ZTtcXG4gICAgICBzdHJlYW0ucGF1c2UoKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXFxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XFxuICAgIGlmICh1dGlsLmlzRnVuY3Rpb24oc3RyZWFtW2ldKSAmJiB1dGlsLmlzVW5kZWZpbmVkKHRoaXNbaV0pKSB7XFxuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uKG1ldGhvZCkgeyByZXR1cm4gZnVuY3Rpb24oKSB7XFxuICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xcbiAgICAgIH19KGkpO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXFxuICB2YXIgZXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xcbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uKGV2KSB7XFxuICAgIHN0cmVhbS5vbihldiwgc2VsZi5lbWl0LmJpbmQoc2VsZiwgZXYpKTtcXG4gIH0pO1xcblxcbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXFxuICBzZWxmLl9yZWFkID0gZnVuY3Rpb24obikge1xcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xcbiAgICBpZiAocGF1c2VkKSB7XFxuICAgICAgcGF1c2VkID0gZmFsc2U7XFxuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xcbiAgICB9XFxuICB9O1xcblxcbiAgcmV0dXJuIHNlbGY7XFxufTtcXG5cXG5cXG5cXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXFxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XFxuXFxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxcbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXFxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcXG4gIHZhciBsaXN0ID0gc3RhdGUuYnVmZmVyO1xcbiAgdmFyIGxlbmd0aCA9IHN0YXRlLmxlbmd0aDtcXG4gIHZhciBzdHJpbmdNb2RlID0gISFzdGF0ZS5kZWNvZGVyO1xcbiAgdmFyIG9iamVjdE1vZGUgPSAhIXN0YXRlLm9iamVjdE1vZGU7XFxuICB2YXIgcmV0O1xcblxcbiAgLy8gbm90aGluZyBpbiB0aGUgbGlzdCwgZGVmaW5pdGVseSBlbXB0eS5cXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMClcXG4gICAgcmV0dXJuIG51bGw7XFxuXFxuICBpZiAobGVuZ3RoID09PSAwKVxcbiAgICByZXQgPSBudWxsO1xcbiAgZWxzZSBpZiAob2JqZWN0TW9kZSlcXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xcbiAgZWxzZSBpZiAoIW4gfHwgbiA+PSBsZW5ndGgpIHtcXG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBhcnJheS5cXG4gICAgaWYgKHN0cmluZ01vZGUpXFxuICAgICAgcmV0ID0gbGlzdC5qb2luKCcnKTtcXG4gICAgZWxzZVxcbiAgICAgIHJldCA9IEJ1ZmZlci5jb25jYXQobGlzdCwgbGVuZ3RoKTtcXG4gICAgbGlzdC5sZW5ndGggPSAwO1xcbiAgfSBlbHNlIHtcXG4gICAgLy8gcmVhZCBqdXN0IHNvbWUgb2YgaXQuXFxuICAgIGlmIChuIDwgbGlzdFswXS5sZW5ndGgpIHtcXG4gICAgICAvLyBqdXN0IHRha2UgYSBwYXJ0IG9mIHRoZSBmaXJzdCBsaXN0IGl0ZW0uXFxuICAgICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3MuXFxuICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XFxuICAgICAgcmV0ID0gYnVmLnNsaWNlKDAsIG4pO1xcbiAgICAgIGxpc3RbMF0gPSBidWYuc2xpY2Uobik7XFxuICAgIH0gZWxzZSBpZiAobiA9PT0gbGlzdFswXS5sZW5ndGgpIHtcXG4gICAgICAvLyBmaXJzdCBsaXN0IGlzIGEgcGVyZmVjdCBtYXRjaFxcbiAgICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBjb21wbGV4IGNhc2UuXFxuICAgICAgLy8gd2UgaGF2ZSBlbm91Z2ggdG8gY292ZXIgaXQsIGJ1dCBpdCBzcGFucyBwYXN0IHRoZSBmaXJzdCBidWZmZXIuXFxuICAgICAgaWYgKHN0cmluZ01vZGUpXFxuICAgICAgICByZXQgPSAnJztcXG4gICAgICBlbHNlXFxuICAgICAgICByZXQgPSBuZXcgQnVmZmVyKG4pO1xcblxcbiAgICAgIHZhciBjID0gMDtcXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbCAmJiBjIDwgbjsgaSsrKSB7XFxuICAgICAgICB2YXIgYnVmID0gbGlzdFswXTtcXG4gICAgICAgIHZhciBjcHkgPSBNYXRoLm1pbihuIC0gYywgYnVmLmxlbmd0aCk7XFxuXFxuICAgICAgICBpZiAoc3RyaW5nTW9kZSlcXG4gICAgICAgICAgcmV0ICs9IGJ1Zi5zbGljZSgwLCBjcHkpO1xcbiAgICAgICAgZWxzZVxcbiAgICAgICAgICBidWYuY29weShyZXQsIGMsIDAsIGNweSk7XFxuXFxuICAgICAgICBpZiAoY3B5IDwgYnVmLmxlbmd0aClcXG4gICAgICAgICAgbGlzdFswXSA9IGJ1Zi5zbGljZShjcHkpO1xcbiAgICAgICAgZWxzZVxcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XFxuXFxuICAgICAgICBjICs9IGNweTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiByZXQ7XFxufVxcblxcbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xcblxcbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxcbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApXFxuICAgIHRocm93IG5ldyBFcnJvcignZW5kUmVhZGFibGUgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcXG5cXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XFxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XFxuICAgICAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXFxuICAgICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XFxuICAgICAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcXG4gICAgICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgZih4c1tpXSwgaSk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGluZGV4T2YgKHhzLCB4KSB7XFxuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xcbiAgfVxcbiAgcmV0dXJuIC0xO1xcbn1cXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiLi9fc3RyZWFtX2R1cGxleFxcXCI6NTMsXFxcIl9wcm9jZXNzXFxcIjo1MSxcXFwiYnVmZmVyXFxcIjo0MyxcXFwiY29yZS11dGlsLWlzXFxcIjo1OCxcXFwiZXZlbnRzXFxcIjo0NyxcXFwiaW5oZXJpdHNcXFwiOjQ4LFxcXCJpc2FycmF5XFxcIjo0OSxcXFwic3RyZWFtXFxcIjo2MyxcXFwic3RyaW5nX2RlY29kZXIvXFxcIjo2NCxcXFwidXRpbFxcXCI6NDJ9XSw1NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcXG4vLyBcXFwiU29mdHdhcmVcXFwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXFxuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcXG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXFxcIkFTIElTXFxcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xcbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXFxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXFxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXFxuXFxuXFxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xcbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXFxcImZpbHRlclxcXCIsXFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxcbi8vXFxuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxcbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cXG4vL1xcbi8vIEhlcmUncyBob3cgdGhpcyB3b3JrczpcXG4vL1xcbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXFxuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cXG4vL1xcbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXFxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xcbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cXG4vL1xcbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcXG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXFxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxcbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cXG4vL1xcbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XFxuXFxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XFxudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XFxuXFxuXFxuZnVuY3Rpb24gVHJhbnNmb3JtU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XFxuICB0aGlzLmFmdGVyVHJhbnNmb3JtID0gZnVuY3Rpb24oZXIsIGRhdGEpIHtcXG4gICAgcmV0dXJuIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpO1xcbiAgfTtcXG5cXG4gIHRoaXMubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xcbiAgdGhpcy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XFxuICB0aGlzLndyaXRlY2h1bmsgPSBudWxsO1xcbn1cXG5cXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKSB7XFxuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XFxuXFxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xcblxcbiAgaWYgKCFjYilcXG4gICAgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm8gd3JpdGVjYiBpbiBUcmFuc2Zvcm0gY2xhc3MnKSk7XFxuXFxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcXG4gIHRzLndyaXRlY2IgPSBudWxsO1xcblxcbiAgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGRhdGEpKVxcbiAgICBzdHJlYW0ucHVzaChkYXRhKTtcXG5cXG4gIGlmIChjYilcXG4gICAgY2IoZXIpO1xcblxcbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XFxuICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcXG4gIH1cXG59XFxuXFxuXFxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKVxcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcXG5cXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xcblxcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUob3B0aW9ucywgdGhpcyk7XFxuXFxuICAvLyB3aGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXFxuICB2YXIgc3RyZWFtID0gdGhpcztcXG5cXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xcblxcbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXFxuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXFxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXFxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcXG5cXG4gIHRoaXMub25jZSgncHJlZmluaXNoJywgZnVuY3Rpb24oKSB7XFxuICAgIGlmICh1dGlsLmlzRnVuY3Rpb24odGhpcy5fZmx1c2gpKVxcbiAgICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uKGVyKSB7XFxuICAgICAgICBkb25lKHN0cmVhbSwgZXIpO1xcbiAgICAgIH0pO1xcbiAgICBlbHNlXFxuICAgICAgZG9uZShzdHJlYW0pO1xcbiAgfSk7XFxufVxcblxcblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZykge1xcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XFxufTtcXG5cXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXFxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cXG4vL1xcbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXFxuLy9cXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xcbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3VcXG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxcblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcXG4gIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XFxufTtcXG5cXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcXG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xcbiAgdHMud3JpdGVjYiA9IGNiO1xcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcXG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcXG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHxcXG4gICAgICAgIHJzLm5lZWRSZWFkYWJsZSB8fFxcbiAgICAgICAgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaylcXG4gICAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xcbiAgfVxcbn07XFxuXFxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxcbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXFxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcXG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xcblxcbiAgaWYgKCF1dGlsLmlzTnVsbCh0cy53cml0ZWNodW5rKSAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcXG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcXG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcXG4gIH0gZWxzZSB7XFxuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXFxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xcbiAgfVxcbn07XFxuXFxuXFxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyKSB7XFxuICBpZiAoZXIpXFxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XFxuXFxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXFxuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcXG4gIHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcXG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XFxuXFxuICBpZiAod3MubGVuZ3RoKVxcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xcblxcbiAgaWYgKHRzLnRyYW5zZm9ybWluZylcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XFxuXFxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XFxufVxcblxcbn0se1xcXCIuL19zdHJlYW1fZHVwbGV4XFxcIjo1MyxcXFwiY29yZS11dGlsLWlzXFxcIjo1OCxcXFwiaW5oZXJpdHNcXFwiOjQ4fV0sNTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcXG4vLyBcXFwiU29mdHdhcmVcXFwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXFxuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcXG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXFxcIkFTIElTXFxcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xcbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXFxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXFxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXFxuXFxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXFxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcXG5cXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XFxudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xcblxcbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XFxuXFxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xcbn1cXG5cXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xcbiAgdmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcXG5cXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcblxcbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XFxuICB2YXIgZGVmYXVsdEh3bSA9IG9wdGlvbnMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gKGh3bSB8fCBod20gPT09IDApID8gaHdtIDogZGVmYXVsdEh3bTtcXG5cXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxcbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XFxuXFxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KVxcbiAgICB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcXG5cXG4gIC8vIGNhc3QgdG8gaW50cy5cXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH5+dGhpcy5oaWdoV2F0ZXJNYXJrO1xcblxcbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcXG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXFxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XFxuXFxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cXG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XFxuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XFxuXFxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXFxuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXFxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXFxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcXG5cXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXFxuICAvLyBzb2NrZXQgb3IgZmlsZS5cXG4gIHRoaXMubGVuZ3RoID0gMDtcXG5cXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXFxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcXG5cXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcXG4gIHRoaXMuY29ya2VkID0gMDtcXG5cXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcXG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFxcXCJsYXRlclxcXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXFxuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cXG4gIHRoaXMuc3luYyA9IHRydWU7XFxuXFxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXFxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcXG5cXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uKGVyKSB7XFxuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XFxuICB9O1xcblxcbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXFxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xcblxcbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxcbiAgdGhpcy53cml0ZWxlbiA9IDA7XFxuXFxuICB0aGlzLmJ1ZmZlciA9IFtdO1xcblxcbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xcblxcbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcXG5cXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXFxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xcbn1cXG5cXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XFxuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xcblxcbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0aG91Z2ggdGhleSdyZSBub3RcXG4gIC8vIGluc3RhbmNlb2YgV3JpdGFibGUsIHRoZXkncmUgaW5zdGFuY2VvZiBSZWFkYWJsZS5cXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXcml0YWJsZSkgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSlcXG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcXG5cXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcXG5cXG4gIC8vIGxlZ2FjeS5cXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xcblxcbiAgU3RyZWFtLmNhbGwodGhpcyk7XFxufVxcblxcbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKCkge1xcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUuIE5vdCByZWFkYWJsZS4nKSk7XFxufTtcXG5cXG5cXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgc3RhdGUsIGNiKSB7XFxuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcXG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XFxuICAgIGNiKGVyKTtcXG4gIH0pO1xcbn1cXG5cXG4vLyBJZiB3ZSBnZXQgc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgYnVmZmVyLCBzdHJpbmcsIG51bGwsIG9yIHVuZGVmaW5lZCxcXG4vLyBhbmQgd2UncmUgbm90IGluIG9iamVjdE1vZGUsIHRoZW4gdGhhdCdzIGFuIGVycm9yLlxcbi8vIE90aGVyd2lzZSBzdHJlYW0gY2h1bmtzIGFyZSBhbGwgY29uc2lkZXJlZCB0byBiZSBvZiBsZW5ndGg9MSwgYW5kIHRoZVxcbi8vIHdhdGVybWFya3MgZGV0ZXJtaW5lIGhvdyBtYW55IG9iamVjdHMgdG8ga2VlcCBpbiB0aGUgYnVmZmVyLCByYXRoZXIgdGhhblxcbi8vIGhvdyBtYW55IGJ5dGVzIG9yIGNoYXJhY3RlcnMuXFxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcXG4gIHZhciB2YWxpZCA9IHRydWU7XFxuICBpZiAoIXV0aWwuaXNCdWZmZXIoY2h1bmspICYmXFxuICAgICAgIXV0aWwuaXNTdHJpbmcoY2h1bmspICYmXFxuICAgICAgIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspICYmXFxuICAgICAgIXN0YXRlLm9iamVjdE1vZGUpIHtcXG4gICAgdmFyIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XFxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XFxuICAgICAgY2IoZXIpO1xcbiAgICB9KTtcXG4gICAgdmFsaWQgPSBmYWxzZTtcXG4gIH1cXG4gIHJldHVybiB2YWxpZDtcXG59XFxuXFxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcXG4gIHZhciByZXQgPSBmYWxzZTtcXG5cXG4gIGlmICh1dGlsLmlzRnVuY3Rpb24oZW5jb2RpbmcpKSB7XFxuICAgIGNiID0gZW5jb2Rpbmc7XFxuICAgIGVuY29kaW5nID0gbnVsbDtcXG4gIH1cXG5cXG4gIGlmICh1dGlsLmlzQnVmZmVyKGNodW5rKSlcXG4gICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcXG4gIGVsc2UgaWYgKCFlbmNvZGluZylcXG4gICAgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XFxuXFxuICBpZiAoIXV0aWwuaXNGdW5jdGlvbihjYikpXFxuICAgIGNiID0gZnVuY3Rpb24oKSB7fTtcXG5cXG4gIGlmIChzdGF0ZS5lbmRlZClcXG4gICAgd3JpdGVBZnRlckVuZCh0aGlzLCBzdGF0ZSwgY2IpO1xcbiAgZWxzZSBpZiAodmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcXG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYik7XFxuICB9XFxuXFxuICByZXR1cm4gcmV0O1xcbn07XFxuXFxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbigpIHtcXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XFxuXFxuICBzdGF0ZS5jb3JrZWQrKztcXG59O1xcblxcbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbigpIHtcXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XFxuXFxuICBpZiAoc3RhdGUuY29ya2VkKSB7XFxuICAgIHN0YXRlLmNvcmtlZC0tO1xcblxcbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiZcXG4gICAgICAgICFzdGF0ZS5jb3JrZWQgJiZcXG4gICAgICAgICFzdGF0ZS5maW5pc2hlZCAmJlxcbiAgICAgICAgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiZcXG4gICAgICAgIHN0YXRlLmJ1ZmZlci5sZW5ndGgpXFxuICAgICAgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xcbiAgfVxcbn07XFxuXFxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmXFxuICAgICAgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiZcXG4gICAgICB1dGlsLmlzU3RyaW5nKGNodW5rKSkge1xcbiAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssIGVuY29kaW5nKTtcXG4gIH1cXG4gIHJldHVybiBjaHVuaztcXG59XFxuXFxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXFxuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxcbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYikge1xcbiAgY2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcXG4gIGlmICh1dGlsLmlzQnVmZmVyKGNodW5rKSlcXG4gICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcXG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcXG5cXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XFxuXFxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcXG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxcbiAgaWYgKCFyZXQpXFxuICAgIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XFxuXFxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpXFxuICAgIHN0YXRlLmJ1ZmZlci5wdXNoKG5ldyBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSk7XFxuICBlbHNlXFxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XFxuXFxuICByZXR1cm4gcmV0O1xcbn1cXG5cXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XFxuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcXG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcXG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xcbiAgc3RhdGUuc3luYyA9IHRydWU7XFxuICBpZiAod3JpdGV2KVxcbiAgICBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7XFxuICBlbHNlXFxuICAgIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcXG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcXG59XFxuXFxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xcbiAgaWYgKHN5bmMpXFxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XFxuICAgICAgc3RhdGUucGVuZGluZ2NiLS07XFxuICAgICAgY2IoZXIpO1xcbiAgICB9KTtcXG4gIGVsc2Uge1xcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcXG4gICAgY2IoZXIpO1xcbiAgfVxcblxcbiAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XFxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XFxufVxcblxcbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XFxuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XFxuICBzdGF0ZS53cml0ZWxlbiA9IDA7XFxufVxcblxcbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcXG5cXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XFxuXFxuICBpZiAoZXIpXFxuICAgIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO1xcbiAgZWxzZSB7XFxuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSk7XFxuXFxuICAgIGlmICghZmluaXNoZWQgJiZcXG4gICAgICAgICFzdGF0ZS5jb3JrZWQgJiZcXG4gICAgICAgICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmXFxuICAgICAgICBzdGF0ZS5idWZmZXIubGVuZ3RoKSB7XFxuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHN5bmMpIHtcXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xcbiAgICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xcbiAgICAgIH0pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xcbiAgaWYgKCFmaW5pc2hlZClcXG4gICAgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xcbiAgc3RhdGUucGVuZGluZ2NiLS07XFxuICBjYigpO1xcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XFxufVxcblxcbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxcbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXFxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XFxuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcXG4gIH1cXG59XFxuXFxuXFxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcXG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XFxuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcXG5cXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBzdGF0ZS5idWZmZXIubGVuZ3RoID4gMSkge1xcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXFxuICAgIHZhciBjYnMgPSBbXTtcXG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBzdGF0ZS5idWZmZXIubGVuZ3RoOyBjKyspXFxuICAgICAgY2JzLnB1c2goc3RhdGUuYnVmZmVyW2NdLmNhbGxiYWNrKTtcXG5cXG4gICAgLy8gY291bnQgdGhlIG9uZSB3ZSBhcmUgYWRkaW5nLCBhcyB3ZWxsLlxcbiAgICAvLyBUT0RPKGlzYWFjcykgY2xlYW4gdGhpcyB1cFxcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmJ1ZmZlciwgJycsIGZ1bmN0aW9uKGVycikge1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcXG4gICAgICAgIGNic1tpXShlcnIpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuXFxuICAgIC8vIENsZWFyIGJ1ZmZlclxcbiAgICBzdGF0ZS5idWZmZXIgPSBbXTtcXG4gIH0gZWxzZSB7XFxuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcXG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBzdGF0ZS5idWZmZXIubGVuZ3RoOyBjKyspIHtcXG4gICAgICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJbY107XFxuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XFxuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XFxuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XFxuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xcblxcbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XFxuXFxuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxcbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcXG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xcbiAgICAgICAgYysrO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aClcXG4gICAgICBzdGF0ZS5idWZmZXIgPSBzdGF0ZS5idWZmZXIuc2xpY2UoYyk7XFxuICAgIGVsc2VcXG4gICAgICBzdGF0ZS5idWZmZXIubGVuZ3RoID0gMDtcXG4gIH1cXG5cXG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcXG59XFxuXFxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcXG4gIGNiKG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xcblxcbn07XFxuXFxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xcblxcbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XFxuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xcblxcbiAgaWYgKHV0aWwuaXNGdW5jdGlvbihjaHVuaykpIHtcXG4gICAgY2IgPSBjaHVuaztcXG4gICAgY2h1bmsgPSBudWxsO1xcbiAgICBlbmNvZGluZyA9IG51bGw7XFxuICB9IGVsc2UgaWYgKHV0aWwuaXNGdW5jdGlvbihlbmNvZGluZykpIHtcXG4gICAgY2IgPSBlbmNvZGluZztcXG4gICAgZW5jb2RpbmcgPSBudWxsO1xcbiAgfVxcblxcbiAgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGNodW5rKSlcXG4gICAgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xcblxcbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcXG4gICAgc3RhdGUuY29ya2VkID0gMTtcXG4gICAgdGhpcy51bmNvcmsoKTtcXG4gIH1cXG5cXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZClcXG4gICAgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcXG59O1xcblxcblxcbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xcbiAgcmV0dXJuIChzdGF0ZS5lbmRpbmcgJiZcXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID09PSAwICYmXFxuICAgICAgICAgICFzdGF0ZS5maW5pc2hlZCAmJlxcbiAgICAgICAgICAhc3RhdGUud3JpdGluZyk7XFxufVxcblxcbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XFxuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkKSB7XFxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcXG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XFxuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSk7XFxuICBpZiAobmVlZCkge1xcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XFxuICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcXG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XFxuICAgIH0gZWxzZVxcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcXG4gIH1cXG4gIHJldHVybiBuZWVkO1xcbn1cXG5cXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcXG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xcbiAgaWYgKGNiKSB7XFxuICAgIGlmIChzdGF0ZS5maW5pc2hlZClcXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNiKTtcXG4gICAgZWxzZVxcbiAgICAgIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XFxuICB9XFxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XFxufVxcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCIuL19zdHJlYW1fZHVwbGV4XFxcIjo1MyxcXFwiX3Byb2Nlc3NcXFwiOjUxLFxcXCJidWZmZXJcXFwiOjQzLFxcXCJjb3JlLXV0aWwtaXNcXFwiOjU4LFxcXCJpbmhlcml0c1xcXCI6NDgsXFxcInN0cmVhbVxcXCI6NjN9XSw1ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChCdWZmZXIpe1xcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXFxuLy8gXFxcIlNvZnR3YXJlXFxcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXFxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXFxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxcbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxcblxcbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxcbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcXG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcXG59XFxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcXG5cXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xcbn1cXG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcXG5cXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XFxuICByZXR1cm4gYXJnID09PSBudWxsO1xcbn1cXG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcXG5cXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcXG4gIHJldHVybiBhcmcgPT0gbnVsbDtcXG59XFxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xcblxcbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xcbn1cXG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XFxuXFxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XFxufVxcbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcXG5cXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcXG59XFxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xcblxcbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xcbn1cXG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XFxuXFxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcXG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcXG59XFxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xcblxcbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcXG59XFxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xcblxcbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XFxuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcXG59XFxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XFxuXFxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XFxuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcXG59XFxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcXG5cXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XFxufVxcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XFxuXFxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XFxuICByZXR1cm4gYXJnID09PSBudWxsIHx8XFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XFxufVxcbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcXG5cXG5mdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcXG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoYXJnKTtcXG59XFxuZXhwb3J0cy5pc0J1ZmZlciA9IGlzQnVmZmVyO1xcblxcbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcXG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XFxufVxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFxcXCJidWZmZXJcXFwiKS5CdWZmZXIpXFxufSx7XFxcImJ1ZmZlclxcXCI6NDN9XSw1OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFxcXCIuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzXFxcIilcXG5cXG59LHtcXFwiLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qc1xcXCI6NTR9XSw2MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xcbmV4cG9ydHMuU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XFxuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XFxuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcXG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XFxuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XFxuXFxufSx7XFxcIi4vbGliL19zdHJlYW1fZHVwbGV4LmpzXFxcIjo1MyxcXFwiLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qc1xcXCI6NTQsXFxcIi4vbGliL19zdHJlYW1fcmVhZGFibGUuanNcXFwiOjU1LFxcXCIuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qc1xcXCI6NTYsXFxcIi4vbGliL19zdHJlYW1fd3JpdGFibGUuanNcXFwiOjU3LFxcXCJzdHJlYW1cXFwiOjYzfV0sNjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcXFwiLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanNcXFwiKVxcblxcbn0se1xcXCIuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qc1xcXCI6NTZ9XSw2MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFxcXCIuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzXFxcIilcXG5cXG59LHtcXFwiLi9saWIvX3N0cmVhbV93cml0YWJsZS5qc1xcXCI6NTd9XSw2MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcXG4vLyBcXFwiU29mdHdhcmVcXFwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXFxuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcXG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXFxcIkFTIElTXFxcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xcbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXFxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXFxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XFxuXFxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XFxuXFxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XFxuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XFxuU3RyZWFtLldyaXRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzJyk7XFxuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMnKTtcXG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xcblN0cmVhbS5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcycpO1xcblxcbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcXG5cXG5cXG5cXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cXG5cXG5mdW5jdGlvbiBTdHJlYW0oKSB7XFxuICBFRS5jYWxsKHRoaXMpO1xcbn1cXG5cXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XFxuICB2YXIgc291cmNlID0gdGhpcztcXG5cXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xcbiAgICBpZiAoZGVzdC53cml0YWJsZSkge1xcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XFxuICAgICAgICBzb3VyY2UucGF1c2UoKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XFxuXFxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcXG4gICAgICBzb3VyY2UucmVzdW1lKCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XFxuXFxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXFxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcXG4gICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xcbiAgfVxcblxcbiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XFxuICBmdW5jdGlvbiBvbmVuZCgpIHtcXG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XFxuICAgIGRpZE9uRW5kID0gdHJ1ZTtcXG5cXG4gICAgZGVzdC5lbmQoKTtcXG4gIH1cXG5cXG5cXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XFxuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xcbiAgICBkaWRPbkVuZCA9IHRydWU7XFxuXFxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcXG4gIH1cXG5cXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcXG4gICAgY2xlYW51cCgpO1xcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXFxuICAgIH1cXG4gIH1cXG5cXG4gIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcXG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XFxuXFxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcXG5cXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XFxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcXG5cXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xcblxcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XFxuXFxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XFxuICB9XFxuXFxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xcblxcbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcXG5cXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XFxuXFxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxcbiAgcmV0dXJuIGRlc3Q7XFxufTtcXG5cXG59LHtcXFwiZXZlbnRzXFxcIjo0NyxcXFwiaW5oZXJpdHNcXFwiOjQ4LFxcXCJyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzXFxcIjo1MixcXFwicmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzXFxcIjo1OSxcXFwicmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzXFxcIjo2MCxcXFwicmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qc1xcXCI6NjEsXFxcInJlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qc1xcXCI6NjJ9XSw2NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcXG4vLyBcXFwiU29mdHdhcmVcXFwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXFxuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcXG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXFxcIkFTIElTXFxcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xcbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXFxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXFxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXFxuXFxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcXG5cXG52YXIgaXNCdWZmZXJFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nXFxuICB8fCBmdW5jdGlvbihlbmNvZGluZykge1xcbiAgICAgICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcXG4gICAgICAgICBjYXNlICdoZXgnOiBjYXNlICd1dGY4JzogY2FzZSAndXRmLTgnOiBjYXNlICdhc2NpaSc6IGNhc2UgJ2JpbmFyeSc6IGNhc2UgJ2Jhc2U2NCc6IGNhc2UgJ3VjczInOiBjYXNlICd1Y3MtMic6IGNhc2UgJ3V0ZjE2bGUnOiBjYXNlICd1dGYtMTZsZSc6IGNhc2UgJ3Jhdyc6IHJldHVybiB0cnVlO1xcbiAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcXG4gICAgICAgfVxcbiAgICAgfVxcblxcblxcbmZ1bmN0aW9uIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKSB7XFxuICBpZiAoZW5jb2RpbmcgJiYgIWlzQnVmZmVyRW5jb2RpbmcoZW5jb2RpbmcpKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcXG4gIH1cXG59XFxuXFxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxcbi8vIGNoYXJhY3RlcnMuIENFU1UtOCBpcyBoYW5kbGVkIGFzIHBhcnQgb2YgdGhlIFVURi04IGVuY29kaW5nLlxcbi8vXFxuLy8gQFRPRE8gSGFuZGxpbmcgYWxsIGVuY29kaW5ncyBpbnNpZGUgYSBzaW5nbGUgb2JqZWN0IG1ha2VzIGl0IHZlcnkgZGlmZmljdWx0XFxuLy8gdG8gcmVhc29uIGFib3V0IHRoaXMgY29kZSwgc28gaXQgc2hvdWxkIGJlIHNwbGl0IHVwIGluIHRoZSBmdXR1cmUuXFxuLy8gQFRPRE8gVGhlcmUgc2hvdWxkIGJlIGEgdXRmOC1zdHJpY3QgZW5jb2RpbmcgdGhhdCByZWplY3RzIGludmFsaWQgVVRGLTggY29kZVxcbi8vIHBvaW50cyBhcyB1c2VkIGJ5IENFU1UtOC5cXG52YXIgU3RyaW5nRGVjb2RlciA9IGV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XFxuICB0aGlzLmVuY29kaW5nID0gKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bLV9dLywgJycpO1xcbiAgYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpO1xcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XFxuICAgIGNhc2UgJ3V0ZjgnOlxcbiAgICAgIC8vIENFU1UtOCByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMy1ieXRlc1xcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XFxuICAgICAgYnJlYWs7XFxuICAgIGNhc2UgJ3VjczInOlxcbiAgICBjYXNlICd1dGYxNmxlJzpcXG4gICAgICAvLyBVVEYtMTYgcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDItYnl0ZXNcXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAyO1xcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyO1xcbiAgICAgIGJyZWFrO1xcbiAgICBjYXNlICdiYXNlNjQnOlxcbiAgICAgIC8vIEJhc2UtNjQgc3RvcmVzIDMgYnl0ZXMgaW4gNCBjaGFycywgYW5kIHBhZHMgdGhlIHJlbWFpbmRlci5cXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcjtcXG4gICAgICBicmVhaztcXG4gICAgZGVmYXVsdDpcXG4gICAgICB0aGlzLndyaXRlID0gcGFzc1Rocm91Z2hXcml0ZTtcXG4gICAgICByZXR1cm47XFxuICB9XFxuXFxuICAvLyBFbm91Z2ggc3BhY2UgdG8gc3RvcmUgYWxsIGJ5dGVzIG9mIGEgc2luZ2xlIGNoYXJhY3Rlci4gVVRGLTggbmVlZHMgNFxcbiAgLy8gYnl0ZXMsIGJ1dCBDRVNVLTggbWF5IHJlcXVpcmUgdXAgdG8gNiAoMyBieXRlcyBwZXIgc3Vycm9nYXRlKS5cXG4gIHRoaXMuY2hhckJ1ZmZlciA9IG5ldyBCdWZmZXIoNik7XFxuICAvLyBOdW1iZXIgb2YgYnl0ZXMgcmVjZWl2ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXFxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IDA7XFxuICAvLyBOdW1iZXIgb2YgYnl0ZXMgZXhwZWN0ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXFxuICB0aGlzLmNoYXJMZW5ndGggPSAwO1xcbn07XFxuXFxuXFxuLy8gd3JpdGUgZGVjb2RlcyB0aGUgZ2l2ZW4gYnVmZmVyIGFuZCByZXR1cm5zIGl0IGFzIEpTIHN0cmluZyB0aGF0IGlzXFxuLy8gZ3VhcmFudGVlZCB0byBub3QgY29udGFpbiBhbnkgcGFydGlhbCBtdWx0aS1ieXRlIGNoYXJhY3RlcnMuIEFueSBwYXJ0aWFsXFxuLy8gY2hhcmFjdGVyIGZvdW5kIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBpcyBidWZmZXJlZCB1cCwgYW5kIHdpbGwgYmVcXG4vLyByZXR1cm5lZCB3aGVuIGNhbGxpbmcgd3JpdGUgYWdhaW4gd2l0aCB0aGUgcmVtYWluaW5nIGJ5dGVzLlxcbi8vXFxuLy8gTm90ZTogQ29udmVydGluZyBhIEJ1ZmZlciBjb250YWluaW5nIGFuIG9ycGhhbiBzdXJyb2dhdGUgdG8gYSBTdHJpbmdcXG4vLyBjdXJyZW50bHkgd29ya3MsIGJ1dCBjb252ZXJ0aW5nIGEgU3RyaW5nIHRvIGEgQnVmZmVyICh2aWEgYG5ldyBCdWZmZXJgLCBvclxcbi8vIEJ1ZmZlciN3cml0ZSkgd2lsbCByZXBsYWNlIGluY29tcGxldGUgc3Vycm9nYXRlcyB3aXRoIHRoZSB1bmljb2RlXFxuLy8gcmVwbGFjZW1lbnQgY2hhcmFjdGVyLiBTZWUgaHR0cHM6Ly9jb2RlcmV2aWV3LmNocm9taXVtLm9yZy8xMjExNzMwMDkvIC5cXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xcbiAgdmFyIGNoYXJTdHIgPSAnJztcXG4gIC8vIGlmIG91ciBsYXN0IHdyaXRlIGVuZGVkIHdpdGggYW4gaW5jb21wbGV0ZSBtdWx0aWJ5dGUgY2hhcmFjdGVyXFxuICB3aGlsZSAodGhpcy5jaGFyTGVuZ3RoKSB7XFxuICAgIC8vIGRldGVybWluZSBob3cgbWFueSByZW1haW5pbmcgYnl0ZXMgdGhpcyBidWZmZXIgaGFzIHRvIG9mZmVyIGZvciB0aGlzIGNoYXJcXG4gICAgdmFyIGF2YWlsYWJsZSA9IChidWZmZXIubGVuZ3RoID49IHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkKSA/XFxuICAgICAgICB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCA6XFxuICAgICAgICBidWZmZXIubGVuZ3RoO1xcblxcbiAgICAvLyBhZGQgdGhlIG5ldyBieXRlcyB0byB0aGUgY2hhciBidWZmZXJcXG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCB0aGlzLmNoYXJSZWNlaXZlZCwgMCwgYXZhaWxhYmxlKTtcXG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gYXZhaWxhYmxlO1xcblxcbiAgICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQgPCB0aGlzLmNoYXJMZW5ndGgpIHtcXG4gICAgICAvLyBzdGlsbCBub3QgZW5vdWdoIGNoYXJzIGluIHRoaXMgYnVmZmVyPyB3YWl0IGZvciBtb3JlIC4uLlxcbiAgICAgIHJldHVybiAnJztcXG4gICAgfVxcblxcbiAgICAvLyByZW1vdmUgYnl0ZXMgYmVsb25naW5nIHRvIHRoZSBjdXJyZW50IGNoYXJhY3RlciBmcm9tIHRoZSBidWZmZXJcXG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGF2YWlsYWJsZSwgYnVmZmVyLmxlbmd0aCk7XFxuXFxuICAgIC8vIGdldCB0aGUgY2hhcmFjdGVyIHRoYXQgd2FzIHNwbGl0XFxuICAgIGNoYXJTdHIgPSB0aGlzLmNoYXJCdWZmZXIuc2xpY2UoMCwgdGhpcy5jaGFyTGVuZ3RoKS50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcXG5cXG4gICAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxcbiAgICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoY2hhclN0ci5sZW5ndGggLSAxKTtcXG4gICAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcXG4gICAgICB0aGlzLmNoYXJMZW5ndGggKz0gdGhpcy5zdXJyb2dhdGVTaXplO1xcbiAgICAgIGNoYXJTdHIgPSAnJztcXG4gICAgICBjb250aW51ZTtcXG4gICAgfVxcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCA9IHRoaXMuY2hhckxlbmd0aCA9IDA7XFxuXFxuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBtb3JlIGJ5dGVzIGluIHRoaXMgYnVmZmVyLCBqdXN0IGVtaXQgb3VyIGNoYXJcXG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcXG4gICAgICByZXR1cm4gY2hhclN0cjtcXG4gICAgfVxcbiAgICBicmVhaztcXG4gIH1cXG5cXG4gIC8vIGRldGVybWluZSBhbmQgc2V0IGNoYXJMZW5ndGggLyBjaGFyUmVjZWl2ZWRcXG4gIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKTtcXG5cXG4gIHZhciBlbmQgPSBidWZmZXIubGVuZ3RoO1xcbiAgaWYgKHRoaXMuY2hhckxlbmd0aCkge1xcbiAgICAvLyBidWZmZXIgdGhlIGluY29tcGxldGUgY2hhcmFjdGVyIGJ5dGVzIHdlIGdvdFxcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCwgZW5kKTtcXG4gICAgZW5kIC09IHRoaXMuY2hhclJlY2VpdmVkO1xcbiAgfVxcblxcbiAgY2hhclN0ciArPSBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgZW5kKTtcXG5cXG4gIHZhciBlbmQgPSBjaGFyU3RyLmxlbmd0aCAtIDE7XFxuICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoZW5kKTtcXG4gIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcXG4gIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XFxuICAgIHZhciBzaXplID0gdGhpcy5zdXJyb2dhdGVTaXplO1xcbiAgICB0aGlzLmNoYXJMZW5ndGggKz0gc2l6ZTtcXG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gc2l6ZTtcXG4gICAgdGhpcy5jaGFyQnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCBzaXplLCAwLCBzaXplKTtcXG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCAwLCBzaXplKTtcXG4gICAgcmV0dXJuIGNoYXJTdHIuc3Vic3RyaW5nKDAsIGVuZCk7XFxuICB9XFxuXFxuICAvLyBvciBqdXN0IGVtaXQgdGhlIGNoYXJTdHJcXG4gIHJldHVybiBjaGFyU3RyO1xcbn07XFxuXFxuLy8gZGV0ZWN0SW5jb21wbGV0ZUNoYXIgZGV0ZXJtaW5lcyBpZiB0aGVyZSBpcyBhbiBpbmNvbXBsZXRlIFVURi04IGNoYXJhY3RlciBhdFxcbi8vIHRoZSBlbmQgb2YgdGhlIGdpdmVuIGJ1ZmZlci4gSWYgc28sIGl0IHNldHMgdGhpcy5jaGFyTGVuZ3RoIHRvIHRoZSBieXRlXFxuLy8gbGVuZ3RoIHRoYXQgY2hhcmFjdGVyLCBhbmQgc2V0cyB0aGlzLmNoYXJSZWNlaXZlZCB0byB0aGUgbnVtYmVyIG9mIGJ5dGVzXFxuLy8gdGhhdCBhcmUgYXZhaWxhYmxlIGZvciB0aGlzIGNoYXJhY3Rlci5cXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xcbiAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IGJ5dGVzIHdlIGhhdmUgdG8gY2hlY2sgYXQgdGhlIGVuZCBvZiB0aGlzIGJ1ZmZlclxcbiAgdmFyIGkgPSAoYnVmZmVyLmxlbmd0aCA+PSAzKSA/IDMgOiBidWZmZXIubGVuZ3RoO1xcblxcbiAgLy8gRmlndXJlIG91dCBpZiBvbmUgb2YgdGhlIGxhc3QgaSBieXRlcyBvZiBvdXIgYnVmZmVyIGFubm91bmNlcyBhblxcbiAgLy8gaW5jb21wbGV0ZSBjaGFyLlxcbiAgZm9yICg7IGkgPiAwOyBpLS0pIHtcXG4gICAgdmFyIGMgPSBidWZmZXJbYnVmZmVyLmxlbmd0aCAtIGldO1xcblxcbiAgICAvLyBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtOCNEZXNjcmlwdGlvblxcblxcbiAgICAvLyAxMTBYWFhYWFxcbiAgICBpZiAoaSA9PSAxICYmIGMgPj4gNSA9PSAweDA2KSB7XFxuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMjtcXG4gICAgICBicmVhaztcXG4gICAgfVxcblxcbiAgICAvLyAxMTEwWFhYWFxcbiAgICBpZiAoaSA8PSAyICYmIGMgPj4gNCA9PSAweDBFKSB7XFxuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMztcXG4gICAgICBicmVhaztcXG4gICAgfVxcblxcbiAgICAvLyAxMTExMFhYWFxcbiAgICBpZiAoaSA8PSAzICYmIGMgPj4gMyA9PSAweDFFKSB7XFxuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gNDtcXG4gICAgICBicmVhaztcXG4gICAgfVxcbiAgfVxcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBpO1xcbn07XFxuXFxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oYnVmZmVyKSB7XFxuICB2YXIgcmVzID0gJyc7XFxuICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGgpXFxuICAgIHJlcyA9IHRoaXMud3JpdGUoYnVmZmVyKTtcXG5cXG4gIGlmICh0aGlzLmNoYXJSZWNlaXZlZCkge1xcbiAgICB2YXIgY3IgPSB0aGlzLmNoYXJSZWNlaXZlZDtcXG4gICAgdmFyIGJ1ZiA9IHRoaXMuY2hhckJ1ZmZlcjtcXG4gICAgdmFyIGVuYyA9IHRoaXMuZW5jb2Rpbmc7XFxuICAgIHJlcyArPSBidWYuc2xpY2UoMCwgY3IpLnRvU3RyaW5nKGVuYyk7XFxuICB9XFxuXFxuICByZXR1cm4gcmVzO1xcbn07XFxuXFxuZnVuY3Rpb24gcGFzc1Rocm91Z2hXcml0ZShidWZmZXIpIHtcXG4gIHJldHVybiBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XFxufVxcblxcbmZ1bmN0aW9uIHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XFxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAyO1xcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAyIDogMDtcXG59XFxuXFxuZnVuY3Rpb24gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XFxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAzO1xcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAzIDogMDtcXG59XFxuXFxufSx7XFxcImJ1ZmZlclxcXCI6NDN9XSw2NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcXG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXFxuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcXG59XFxufSx7fV0sNjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXFxuLy8gXFxcIlNvZnR3YXJlXFxcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXFxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXFxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxcbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxcblxcbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xcbiAgICB9XFxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcXG4gIH1cXG5cXG4gIHZhciBpID0gMTtcXG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcXG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcXG4gICAgc3dpdGNoICh4KSB7XFxuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XFxuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XFxuICAgICAgY2FzZSAnJWonOlxcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XFxuICAgICAgICB9IGNhdGNoIChfKSB7XFxuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XFxuICAgICAgICB9XFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIHJldHVybiB4O1xcbiAgICB9XFxuICB9KTtcXG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XFxuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XFxuICAgICAgc3RyICs9ICcgJyArIHg7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBzdHI7XFxufTtcXG5cXG5cXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxcbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXFxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcXG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXFxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XFxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcXG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgfTtcXG4gIH1cXG5cXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcXG4gICAgcmV0dXJuIGZuO1xcbiAgfVxcblxcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcXG4gICAgaWYgKCF3YXJuZWQpIHtcXG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcXG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XFxuICAgICAgfVxcbiAgICAgIHdhcm5lZCA9IHRydWU7XFxuICAgIH1cXG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICB9XFxuXFxuICByZXR1cm4gZGVwcmVjYXRlZDtcXG59O1xcblxcblxcbnZhciBkZWJ1Z3MgPSB7fTtcXG52YXIgZGVidWdFbnZpcm9uO1xcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcXG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XFxuICBpZiAoIWRlYnVnc1tzZXRdKSB7XFxuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcXFxcXGInICsgc2V0ICsgJ1xcXFxcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XFxuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XFxuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xcbiAgICAgIH07XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gZGVidWdzW3NldF07XFxufTtcXG5cXG5cXG4vKipcXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXFxuICpcXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXFxuICovXFxuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xcbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XFxuICAvLyBkZWZhdWx0IG9wdGlvbnNcXG4gIHZhciBjdHggPSB7XFxuICAgIHNlZW46IFtdLFxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxcbiAgfTtcXG4gIC8vIGxlZ2FjeS4uLlxcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcXG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcXG4gICAgLy8gbGVnYWN5Li4uXFxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcXG4gIH0gZWxzZSBpZiAob3B0cykge1xcbiAgICAvLyBnb3QgYW4gXFxcIm9wdGlvbnNcXFwiIG9iamVjdFxcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcXG4gIH1cXG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XFxuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcXG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcXG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcXG59XFxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcXG5cXG5cXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3NcXG5pbnNwZWN0LmNvbG9ycyA9IHtcXG4gICdib2xkJyA6IFsxLCAyMl0sXFxuICAnaXRhbGljJyA6IFszLCAyM10sXFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXFxuICAnYmxhY2snIDogWzMwLCAzOV0sXFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcXG4gICdjeWFuJyA6IFszNiwgMzldLFxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXFxuICAncmVkJyA6IFszMSwgMzldLFxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxcbn07XFxuXFxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXFxuaW5zcGVjdC5zdHlsZXMgPSB7XFxuICAnc3BlY2lhbCc6ICdjeWFuJyxcXG4gICdudW1iZXInOiAneWVsbG93JyxcXG4gICdib29sZWFuJzogJ3llbGxvdycsXFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxcbiAgJ251bGwnOiAnYm9sZCcsXFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcXG4gICdkYXRlJzogJ21hZ2VudGEnLFxcbiAgLy8gXFxcIm5hbWVcXFwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXFxuICAncmVnZXhwJzogJ3JlZCdcXG59O1xcblxcblxcbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcXG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XFxuXFxuICBpZiAoc3R5bGUpIHtcXG4gICAgcmV0dXJuICdcXFxcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXFxuICAgICAgICAgICAnXFxcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gc3RyO1xcbiAgfVxcbn1cXG5cXG5cXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xcbiAgcmV0dXJuIHN0cjtcXG59XFxuXFxuXFxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcXG4gIHZhciBoYXNoID0ge307XFxuXFxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XFxuICAgIGhhc2hbdmFsXSA9IHRydWU7XFxuICB9KTtcXG5cXG4gIHJldHVybiBoYXNoO1xcbn1cXG5cXG5cXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcXG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXFxuICAgICAgdmFsdWUgJiZcXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXFxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXFxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXFxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XFxuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xcbiAgICB9XFxuICAgIHJldHVybiByZXQ7XFxuICB9XFxuXFxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcXG4gIGlmIChwcmltaXRpdmUpIHtcXG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcXG4gIH1cXG5cXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XFxuXFxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcXG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcXG4gIH1cXG5cXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcXG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcXG4gIH1cXG5cXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcXG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XFxuICAgIH1cXG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XFxuICAgIH1cXG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcXG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XFxuICAgIH1cXG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XFxuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcXG5cXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcXG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xcbiAgICBhcnJheSA9IHRydWU7XFxuICAgIGJyYWNlcyA9IFsnWycsICddJ107XFxuICB9XFxuXFxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcXG4gIH1cXG5cXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXFxuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XFxuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xcbiAgfVxcblxcbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXFxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XFxuICB9XFxuXFxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXFxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcXG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcXG4gIH1cXG5cXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcXG4gIH1cXG5cXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XFxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcXG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xcbiAgICB9XFxuICB9XFxuXFxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcXG5cXG4gIHZhciBvdXRwdXQ7XFxuICBpZiAoYXJyYXkpIHtcXG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XFxuICB9IGVsc2Uge1xcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcXG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgY3R4LnNlZW4ucG9wKCk7XFxuXFxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xcbn1cXG5cXG5cXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XFxuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XFxuICAgIHZhciBzaW1wbGUgPSAnXFxcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cXFwifFxcXCIkL2csICcnKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFxcXCJcXFxcXFxcXCdcXFwiKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXFxcXFxcXCIvZywgJ1xcXCInKSArICdcXFxcJyc7XFxuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcXG4gIH1cXG4gIGlmIChpc051bWJlcih2YWx1ZSkpXFxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XFxuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XFxuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXFxcIm9iamVjdFxcXCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxcbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXFxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XFxufVxcblxcblxcbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XFxuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xcbn1cXG5cXG5cXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XFxuICB2YXIgb3V0cHV0ID0gW107XFxuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcXG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBvdXRwdXQucHVzaCgnJyk7XFxuICAgIH1cXG4gIH1cXG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcXG4gICAgaWYgKCFrZXkubWF0Y2goL15cXFxcZCskLykpIHtcXG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxcbiAgICAgICAgICBrZXksIHRydWUpKTtcXG4gICAgfVxcbiAgfSk7XFxuICByZXR1cm4gb3V0cHV0O1xcbn1cXG5cXG5cXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XFxuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xcbiAgaWYgKGRlc2MuZ2V0KSB7XFxuICAgIGlmIChkZXNjLnNldCkge1xcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIGlmIChkZXNjLnNldCkge1xcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XFxuICAgIH1cXG4gIH1cXG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcXG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcXG4gIH1cXG4gIGlmICghc3RyKSB7XFxuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcXG4gICAgICB9XFxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXFxcbicpID4gLTEpIHtcXG4gICAgICAgIGlmIChhcnJheSkge1xcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcXG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XFxuICAgICAgICAgIH0pLmpvaW4oJ1xcXFxuJykuc3Vic3RyKDIpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgc3RyID0gJ1xcXFxuJyArIHN0ci5zcGxpdCgnXFxcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XFxuICAgICAgICAgIH0pLmpvaW4oJ1xcXFxuJyk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcXG4gICAgfVxcbiAgfVxcbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XFxuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXFxcZCskLykpIHtcXG4gICAgICByZXR1cm4gc3RyO1xcbiAgICB9XFxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XFxuICAgIGlmIChuYW1lLm1hdGNoKC9eXFxcIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVxcXCIkLykpIHtcXG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcXG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFxcXCJcXFxcXFxcXCdcXFwiKVxcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcXFxcXFxcIi9nLCAnXFxcIicpXFxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cXFwifFxcXCIkKS9nLCBcXFwiJ1xcXCIpO1xcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcXG59XFxuXFxuXFxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcXG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XFxuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcXG4gICAgbnVtTGluZXNFc3QrKztcXG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXFxcbicpID49IDApIG51bUxpbmVzRXN0Kys7XFxuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcXFx1MDAxYlxcXFxbXFxcXGRcXFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xcbiAgfSwgMCk7XFxuXFxuICBpZiAobGVuZ3RoID4gNjApIHtcXG4gICAgcmV0dXJuIGJyYWNlc1swXSArXFxuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxcXG4gJykgK1xcbiAgICAgICAgICAgJyAnICtcXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxcXG4gICcpICtcXG4gICAgICAgICAgICcgJyArXFxuICAgICAgICAgICBicmFjZXNbMV07XFxuICB9XFxuXFxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xcbn1cXG5cXG5cXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XFxuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XFxufVxcbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XFxuXFxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcXG59XFxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XFxuXFxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcXG59XFxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XFxuXFxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XFxuICByZXR1cm4gYXJnID09IG51bGw7XFxufVxcbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcXG5cXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcXG59XFxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xcblxcbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xcbn1cXG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XFxuXFxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XFxufVxcbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcXG5cXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcXG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcXG59XFxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xcblxcbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XFxuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XFxufVxcbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcXG5cXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XFxufVxcbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcXG5cXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XFxufVxcbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xcblxcbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXFxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XFxufVxcbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XFxuXFxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xcbn1cXG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xcblxcbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xcbn1cXG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XFxuXFxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xcblxcbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcXG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XFxufVxcblxcblxcbmZ1bmN0aW9uIHBhZChuKSB7XFxuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcXG59XFxuXFxuXFxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XFxuXFxuLy8gMjYgRmViIDE2OjE5OjM0XFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcXG59XFxuXFxuXFxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XFxuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcXG59O1xcblxcblxcbi8qKlxcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cXG4gKlxcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxcbiAqXFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxcbiAqICAgICBwcm90b3R5cGUuXFxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXFxuICovXFxuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XFxuXFxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcXG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcXG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xcblxcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcXG4gIHdoaWxlIChpLS0pIHtcXG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xcbiAgfVxcbiAgcmV0dXJuIG9yaWdpbjtcXG59O1xcblxcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xcbn1cXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHdpbmRvdyA6IHt9KVxcbn0se1xcXCIuL3N1cHBvcnQvaXNCdWZmZXJcXFwiOjY1LFxcXCJfcHJvY2Vzc1xcXCI6NTEsXFxcImluaGVyaXRzXFxcIjo0OH1dLDY3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vKiBTZWUgTElDRU5TRSBmaWxlIGZvciB0ZXJtcyBvZiB1c2UgKi9cXG5cXG4vKlxcbiAqIFRleHQgZGlmZiBpbXBsZW1lbnRhdGlvbi5cXG4gKlxcbiAqIFRoaXMgbGlicmFyeSBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIEFQSVM6XFxuICogSnNEaWZmLmRpZmZDaGFyczogQ2hhcmFjdGVyIGJ5IGNoYXJhY3RlciBkaWZmXFxuICogSnNEaWZmLmRpZmZXb3JkczogV29yZCAoYXMgZGVmaW5lZCBieSBcXFxcYiByZWdleCkgZGlmZiB3aGljaCBpZ25vcmVzIHdoaXRlc3BhY2VcXG4gKiBKc0RpZmYuZGlmZkxpbmVzOiBMaW5lIGJhc2VkIGRpZmZcXG4gKlxcbiAqIEpzRGlmZi5kaWZmQ3NzOiBEaWZmIHRhcmdldGVkIGF0IENTUyBjb250ZW50XFxuICpcXG4gKiBUaGVzZSBtZXRob2RzIGFyZSBiYXNlZCBvbiB0aGUgaW1wbGVtZW50YXRpb24gcHJvcG9zZWQgaW5cXG4gKiBcXFwiQW4gTyhORCkgRGlmZmVyZW5jZSBBbGdvcml0aG0gYW5kIGl0cyBWYXJpYXRpb25zXFxcIiAoTXllcnMsIDE5ODYpLlxcbiAqIGh0dHA6Ly9jaXRlc2VlcnguaXN0LnBzdS5lZHUvdmlld2RvYy9zdW1tYXJ5P2RvaT0xMC4xLjEuNC42OTI3XFxuICovXFxuKGZ1bmN0aW9uKGdsb2JhbCwgdW5kZWZpbmVkKSB7XFxuICB2YXIgb2JqZWN0UHJvdG90eXBlVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xcblxcbiAgLyppc3RhbmJ1bCBpZ25vcmUgbmV4dCovXFxuICBmdW5jdGlvbiBtYXAoYXJyLCBtYXBwZXIsIHRoYXQpIHtcXG4gICAgaWYgKEFycmF5LnByb3RvdHlwZS5tYXApIHtcXG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKGFyciwgbWFwcGVyLCB0aGF0KTtcXG4gICAgfVxcblxcbiAgICB2YXIgb3RoZXIgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XFxuXFxuICAgIGZvciAodmFyIGkgPSAwLCBuID0gYXJyLmxlbmd0aDsgaSA8IG47IGkrKykge1xcbiAgICAgIG90aGVyW2ldID0gbWFwcGVyLmNhbGwodGhhdCwgYXJyW2ldLCBpLCBhcnIpO1xcbiAgICB9XFxuICAgIHJldHVybiBvdGhlcjtcXG4gIH1cXG4gIGZ1bmN0aW9uIGNsb25lUGF0aChwYXRoKSB7XFxuICAgIHJldHVybiB7IG5ld1BvczogcGF0aC5uZXdQb3MsIGNvbXBvbmVudHM6IHBhdGguY29tcG9uZW50cy5zbGljZSgwKSB9O1xcbiAgfVxcbiAgZnVuY3Rpb24gcmVtb3ZlRW1wdHkoYXJyYXkpIHtcXG4gICAgdmFyIHJldCA9IFtdO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XFxuICAgICAgaWYgKGFycmF5W2ldKSB7XFxuICAgICAgICByZXQucHVzaChhcnJheVtpXSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiByZXQ7XFxuICB9XFxuICBmdW5jdGlvbiBlc2NhcGVIVE1MKHMpIHtcXG4gICAgdmFyIG4gPSBzO1xcbiAgICBuID0gbi5yZXBsYWNlKC8mL2csICcmYW1wOycpO1xcbiAgICBuID0gbi5yZXBsYWNlKC88L2csICcmbHQ7Jyk7XFxuICAgIG4gPSBuLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcXG4gICAgbiA9IG4ucmVwbGFjZSgvXFxcIi9nLCAnJnF1b3Q7Jyk7XFxuXFxuICAgIHJldHVybiBuO1xcbiAgfVxcblxcbiAgLy8gVGhpcyBmdW5jdGlvbiBoYW5kbGVzIHRoZSBwcmVzZW5jZSBvZiBjaXJjdWxhciByZWZlcmVuY2VzIGJ5IGJhaWxpbmcgb3V0IHdoZW4gZW5jb3VudGVyaW5nIGFuXFxuICAvLyBvYmplY3QgdGhhdCBpcyBhbHJlYWR5IG9uIHRoZSBcXFwic3RhY2tcXFwiIG9mIGl0ZW1zIGJlaW5nIHByb2Nlc3NlZC5cXG4gIGZ1bmN0aW9uIGNhbm9uaWNhbGl6ZShvYmosIHN0YWNrLCByZXBsYWNlbWVudFN0YWNrKSB7XFxuICAgIHN0YWNrID0gc3RhY2sgfHwgW107XFxuICAgIHJlcGxhY2VtZW50U3RhY2sgPSByZXBsYWNlbWVudFN0YWNrIHx8IFtdO1xcblxcbiAgICB2YXIgaTtcXG5cXG4gICAgZm9yIChpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgICAgaWYgKHN0YWNrW2ldID09PSBvYmopIHtcXG4gICAgICAgIHJldHVybiByZXBsYWNlbWVudFN0YWNrW2ldO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICB2YXIgY2Fub25pY2FsaXplZE9iajtcXG5cXG4gICAgaWYgKCdbb2JqZWN0IEFycmF5XScgPT09IG9iamVjdFByb3RvdHlwZVRvU3RyaW5nLmNhbGwob2JqKSkge1xcbiAgICAgIHN0YWNrLnB1c2gob2JqKTtcXG4gICAgICBjYW5vbmljYWxpemVkT2JqID0gbmV3IEFycmF5KG9iai5sZW5ndGgpO1xcbiAgICAgIHJlcGxhY2VtZW50U3RhY2sucHVzaChjYW5vbmljYWxpemVkT2JqKTtcXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgICAgICBjYW5vbmljYWxpemVkT2JqW2ldID0gY2Fub25pY2FsaXplKG9ialtpXSwgc3RhY2ssIHJlcGxhY2VtZW50U3RhY2spO1xcbiAgICAgIH1cXG4gICAgICBzdGFjay5wb3AoKTtcXG4gICAgICByZXBsYWNlbWVudFN0YWNrLnBvcCgpO1xcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkge1xcbiAgICAgIHN0YWNrLnB1c2gob2JqKTtcXG4gICAgICBjYW5vbmljYWxpemVkT2JqID0ge307XFxuICAgICAgcmVwbGFjZW1lbnRTdGFjay5wdXNoKGNhbm9uaWNhbGl6ZWRPYmopO1xcbiAgICAgIHZhciBzb3J0ZWRLZXlzID0gW10sXFxuICAgICAgICAgIGtleTtcXG4gICAgICBmb3IgKGtleSBpbiBvYmopIHtcXG4gICAgICAgIHNvcnRlZEtleXMucHVzaChrZXkpO1xcbiAgICAgIH1cXG4gICAgICBzb3J0ZWRLZXlzLnNvcnQoKTtcXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc29ydGVkS2V5cy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgICAga2V5ID0gc29ydGVkS2V5c1tpXTtcXG4gICAgICAgIGNhbm9uaWNhbGl6ZWRPYmpba2V5XSA9IGNhbm9uaWNhbGl6ZShvYmpba2V5XSwgc3RhY2ssIHJlcGxhY2VtZW50U3RhY2spO1xcbiAgICAgIH1cXG4gICAgICBzdGFjay5wb3AoKTtcXG4gICAgICByZXBsYWNlbWVudFN0YWNrLnBvcCgpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSBvYmo7XFxuICAgIH1cXG4gICAgcmV0dXJuIGNhbm9uaWNhbGl6ZWRPYmo7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBidWlsZFZhbHVlcyhjb21wb25lbnRzLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgdXNlTG9uZ2VzdFRva2VuKSB7XFxuICAgIHZhciBjb21wb25lbnRQb3MgPSAwLFxcbiAgICAgICAgY29tcG9uZW50TGVuID0gY29tcG9uZW50cy5sZW5ndGgsXFxuICAgICAgICBuZXdQb3MgPSAwLFxcbiAgICAgICAgb2xkUG9zID0gMDtcXG5cXG4gICAgZm9yICg7IGNvbXBvbmVudFBvcyA8IGNvbXBvbmVudExlbjsgY29tcG9uZW50UG9zKyspIHtcXG4gICAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50c1tjb21wb25lbnRQb3NdO1xcbiAgICAgIGlmICghY29tcG9uZW50LnJlbW92ZWQpIHtcXG4gICAgICAgIGlmICghY29tcG9uZW50LmFkZGVkICYmIHVzZUxvbmdlc3RUb2tlbikge1xcbiAgICAgICAgICB2YXIgdmFsdWUgPSBuZXdTdHJpbmcuc2xpY2UobmV3UG9zLCBuZXdQb3MgKyBjb21wb25lbnQuY291bnQpO1xcbiAgICAgICAgICB2YWx1ZSA9IG1hcCh2YWx1ZSwgZnVuY3Rpb24odmFsdWUsIGkpIHtcXG4gICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSBvbGRTdHJpbmdbb2xkUG9zICsgaV07XFxuICAgICAgICAgICAgcmV0dXJuIG9sZFZhbHVlLmxlbmd0aCA+IHZhbHVlLmxlbmd0aCA/IG9sZFZhbHVlIDogdmFsdWU7XFxuICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICBjb21wb25lbnQudmFsdWUgPSB2YWx1ZS5qb2luKCcnKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGNvbXBvbmVudC52YWx1ZSA9IG5ld1N0cmluZy5zbGljZShuZXdQb3MsIG5ld1BvcyArIGNvbXBvbmVudC5jb3VudCkuam9pbignJyk7XFxuICAgICAgICB9XFxuICAgICAgICBuZXdQb3MgKz0gY29tcG9uZW50LmNvdW50O1xcblxcbiAgICAgICAgLy8gQ29tbW9uIGNhc2VcXG4gICAgICAgIGlmICghY29tcG9uZW50LmFkZGVkKSB7XFxuICAgICAgICAgIG9sZFBvcyArPSBjb21wb25lbnQuY291bnQ7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGNvbXBvbmVudC52YWx1ZSA9IG9sZFN0cmluZy5zbGljZShvbGRQb3MsIG9sZFBvcyArIGNvbXBvbmVudC5jb3VudCkuam9pbignJyk7XFxuICAgICAgICBvbGRQb3MgKz0gY29tcG9uZW50LmNvdW50O1xcblxcbiAgICAgICAgLy8gUmV2ZXJzZSBhZGQgYW5kIHJlbW92ZSBzbyByZW1vdmVzIGFyZSBvdXRwdXQgZmlyc3QgdG8gbWF0Y2ggY29tbW9uIGNvbnZlbnRpb25cXG4gICAgICAgIC8vIFRoZSBkaWZmaW5nIGFsZ29yaXRobSBpcyB0aWVkIHRvIGFkZCB0aGVuIHJlbW92ZSBvdXRwdXQgYW5kIHRoaXMgaXMgdGhlIHNpbXBsZXN0XFxuICAgICAgICAvLyByb3V0ZSB0byBnZXQgdGhlIGRlc2lyZWQgb3V0cHV0IHdpdGggbWluaW1hbCBvdmVyaGVhZC5cXG4gICAgICAgIGlmIChjb21wb25lbnRQb3MgJiYgY29tcG9uZW50c1tjb21wb25lbnRQb3MgLSAxXS5hZGRlZCkge1xcbiAgICAgICAgICB2YXIgdG1wID0gY29tcG9uZW50c1tjb21wb25lbnRQb3MgLSAxXTtcXG4gICAgICAgICAgY29tcG9uZW50c1tjb21wb25lbnRQb3MgLSAxXSA9IGNvbXBvbmVudHNbY29tcG9uZW50UG9zXTtcXG4gICAgICAgICAgY29tcG9uZW50c1tjb21wb25lbnRQb3NdID0gdG1wO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gY29tcG9uZW50cztcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIERpZmYoaWdub3JlV2hpdGVzcGFjZSkge1xcbiAgICB0aGlzLmlnbm9yZVdoaXRlc3BhY2UgPSBpZ25vcmVXaGl0ZXNwYWNlO1xcbiAgfVxcbiAgRGlmZi5wcm90b3R5cGUgPSB7XFxuICAgIGRpZmY6IGZ1bmN0aW9uKG9sZFN0cmluZywgbmV3U3RyaW5nLCBjYWxsYmFjaykge1xcbiAgICAgIHZhciBzZWxmID0gdGhpcztcXG5cXG4gICAgICBmdW5jdGlvbiBkb25lKHZhbHVlKSB7XFxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2sodW5kZWZpbmVkLCB2YWx1ZSk7IH0sIDApO1xcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgLy8gSGFuZGxlIHRoZSBpZGVudGl0eSBjYXNlICh0aGlzIGlzIGR1ZSB0byB1bnJvbGxpbmcgZWRpdExlbmd0aCA9PSAwXFxuICAgICAgaWYgKG5ld1N0cmluZyA9PT0gb2xkU3RyaW5nKSB7XFxuICAgICAgICByZXR1cm4gZG9uZShbeyB2YWx1ZTogbmV3U3RyaW5nIH1dKTtcXG4gICAgICB9XFxuICAgICAgaWYgKCFuZXdTdHJpbmcpIHtcXG4gICAgICAgIHJldHVybiBkb25lKFt7IHZhbHVlOiBvbGRTdHJpbmcsIHJlbW92ZWQ6IHRydWUgfV0pO1xcbiAgICAgIH1cXG4gICAgICBpZiAoIW9sZFN0cmluZykge1xcbiAgICAgICAgcmV0dXJuIGRvbmUoW3sgdmFsdWU6IG5ld1N0cmluZywgYWRkZWQ6IHRydWUgfV0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBuZXdTdHJpbmcgPSB0aGlzLnRva2VuaXplKG5ld1N0cmluZyk7XFxuICAgICAgb2xkU3RyaW5nID0gdGhpcy50b2tlbml6ZShvbGRTdHJpbmcpO1xcblxcbiAgICAgIHZhciBuZXdMZW4gPSBuZXdTdHJpbmcubGVuZ3RoLCBvbGRMZW4gPSBvbGRTdHJpbmcubGVuZ3RoO1xcbiAgICAgIHZhciBlZGl0TGVuZ3RoID0gMTtcXG4gICAgICB2YXIgbWF4RWRpdExlbmd0aCA9IG5ld0xlbiArIG9sZExlbjtcXG4gICAgICB2YXIgYmVzdFBhdGggPSBbeyBuZXdQb3M6IC0xLCBjb21wb25lbnRzOiBbXSB9XTtcXG5cXG4gICAgICAvLyBTZWVkIGVkaXRMZW5ndGggPSAwLCBpLmUuIHRoZSBjb250ZW50IHN0YXJ0cyB3aXRoIHRoZSBzYW1lIHZhbHVlc1xcbiAgICAgIHZhciBvbGRQb3MgPSB0aGlzLmV4dHJhY3RDb21tb24oYmVzdFBhdGhbMF0sIG5ld1N0cmluZywgb2xkU3RyaW5nLCAwKTtcXG4gICAgICBpZiAoYmVzdFBhdGhbMF0ubmV3UG9zICsgMSA+PSBuZXdMZW4gJiYgb2xkUG9zICsgMSA+PSBvbGRMZW4pIHtcXG4gICAgICAgIC8vIElkZW50aXR5IHBlciB0aGUgZXF1YWxpdHkgYW5kIHRva2VuaXplclxcbiAgICAgICAgcmV0dXJuIGRvbmUoW3t2YWx1ZTogbmV3U3RyaW5nLmpvaW4oJycpfV0pO1xcbiAgICAgIH1cXG5cXG4gICAgICAvLyBNYWluIHdvcmtlciBtZXRob2QuIGNoZWNrcyBhbGwgcGVybXV0YXRpb25zIG9mIGEgZ2l2ZW4gZWRpdCBsZW5ndGggZm9yIGFjY2VwdGFuY2UuXFxuICAgICAgZnVuY3Rpb24gZXhlY0VkaXRMZW5ndGgoKSB7XFxuICAgICAgICBmb3IgKHZhciBkaWFnb25hbFBhdGggPSAtMSAqIGVkaXRMZW5ndGg7IGRpYWdvbmFsUGF0aCA8PSBlZGl0TGVuZ3RoOyBkaWFnb25hbFBhdGggKz0gMikge1xcbiAgICAgICAgICB2YXIgYmFzZVBhdGg7XFxuICAgICAgICAgIHZhciBhZGRQYXRoID0gYmVzdFBhdGhbZGlhZ29uYWxQYXRoIC0gMV0sXFxuICAgICAgICAgICAgICByZW1vdmVQYXRoID0gYmVzdFBhdGhbZGlhZ29uYWxQYXRoICsgMV0sXFxuICAgICAgICAgICAgICBvbGRQb3MgPSAocmVtb3ZlUGF0aCA/IHJlbW92ZVBhdGgubmV3UG9zIDogMCkgLSBkaWFnb25hbFBhdGg7XFxuICAgICAgICAgIGlmIChhZGRQYXRoKSB7XFxuICAgICAgICAgICAgLy8gTm8gb25lIGVsc2UgaXMgZ29pbmcgdG8gYXR0ZW1wdCB0byB1c2UgdGhpcyB2YWx1ZSwgY2xlYXIgaXRcXG4gICAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGggLSAxXSA9IHVuZGVmaW5lZDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB2YXIgY2FuQWRkID0gYWRkUGF0aCAmJiBhZGRQYXRoLm5ld1BvcyArIDEgPCBuZXdMZW4sXFxuICAgICAgICAgICAgICBjYW5SZW1vdmUgPSByZW1vdmVQYXRoICYmIDAgPD0gb2xkUG9zICYmIG9sZFBvcyA8IG9sZExlbjtcXG4gICAgICAgICAgaWYgKCFjYW5BZGQgJiYgIWNhblJlbW92ZSkge1xcbiAgICAgICAgICAgIC8vIElmIHRoaXMgcGF0aCBpcyBhIHRlcm1pbmFsIHRoZW4gcHJ1bmVcXG4gICAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGhdID0gdW5kZWZpbmVkO1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIC8vIFNlbGVjdCB0aGUgZGlhZ29uYWwgdGhhdCB3ZSB3YW50IHRvIGJyYW5jaCBmcm9tLiBXZSBzZWxlY3QgdGhlIHByaW9yXFxuICAgICAgICAgIC8vIHBhdGggd2hvc2UgcG9zaXRpb24gaW4gdGhlIG5ldyBzdHJpbmcgaXMgdGhlIGZhcnRoZXN0IGZyb20gdGhlIG9yaWdpblxcbiAgICAgICAgICAvLyBhbmQgZG9lcyBub3QgcGFzcyB0aGUgYm91bmRzIG9mIHRoZSBkaWZmIGdyYXBoXFxuICAgICAgICAgIGlmICghY2FuQWRkIHx8IChjYW5SZW1vdmUgJiYgYWRkUGF0aC5uZXdQb3MgPCByZW1vdmVQYXRoLm5ld1BvcykpIHtcXG4gICAgICAgICAgICBiYXNlUGF0aCA9IGNsb25lUGF0aChyZW1vdmVQYXRoKTtcXG4gICAgICAgICAgICBzZWxmLnB1c2hDb21wb25lbnQoYmFzZVBhdGguY29tcG9uZW50cywgdW5kZWZpbmVkLCB0cnVlKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBiYXNlUGF0aCA9IGFkZFBhdGg7ICAgLy8gTm8gbmVlZCB0byBjbG9uZSwgd2UndmUgcHVsbGVkIGl0IGZyb20gdGhlIGxpc3RcXG4gICAgICAgICAgICBiYXNlUGF0aC5uZXdQb3MrKztcXG4gICAgICAgICAgICBzZWxmLnB1c2hDb21wb25lbnQoYmFzZVBhdGguY29tcG9uZW50cywgdHJ1ZSwgdW5kZWZpbmVkKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBvbGRQb3MgPSBzZWxmLmV4dHJhY3RDb21tb24oYmFzZVBhdGgsIG5ld1N0cmluZywgb2xkU3RyaW5nLCBkaWFnb25hbFBhdGgpO1xcblxcbiAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGhpdCB0aGUgZW5kIG9mIGJvdGggc3RyaW5ncywgdGhlbiB3ZSBhcmUgZG9uZVxcbiAgICAgICAgICBpZiAoYmFzZVBhdGgubmV3UG9zICsgMSA+PSBuZXdMZW4gJiYgb2xkUG9zICsgMSA+PSBvbGRMZW4pIHtcXG4gICAgICAgICAgICByZXR1cm4gZG9uZShidWlsZFZhbHVlcyhiYXNlUGF0aC5jb21wb25lbnRzLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgc2VsZi51c2VMb25nZXN0VG9rZW4pKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgdHJhY2sgdGhpcyBwYXRoIGFzIGEgcG90ZW50aWFsIGNhbmRpZGF0ZSBhbmQgY29udGludWUuXFxuICAgICAgICAgICAgYmVzdFBhdGhbZGlhZ29uYWxQYXRoXSA9IGJhc2VQYXRoO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBlZGl0TGVuZ3RoKys7XFxuICAgICAgfVxcblxcbiAgICAgIC8vIFBlcmZvcm1zIHRoZSBsZW5ndGggb2YgZWRpdCBpdGVyYXRpb24uIElzIGEgYml0IGZ1Z2x5IGFzIHRoaXMgaGFzIHRvIHN1cHBvcnQgdGhlXFxuICAgICAgLy8gc3luYyBhbmQgYXN5bmMgbW9kZSB3aGljaCBpcyBuZXZlciBmdW4uIExvb3BzIG92ZXIgZXhlY0VkaXRMZW5ndGggdW50aWwgYSB2YWx1ZVxcbiAgICAgIC8vIGlzIHByb2R1Y2VkLlxcbiAgICAgIGlmIChjYWxsYmFjaykge1xcbiAgICAgICAgKGZ1bmN0aW9uIGV4ZWMoKSB7XFxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbm90IGhhcHBlbiwgYnV0IHdlIHdhbnQgdG8gYmUgc2FmZS5cXG4gICAgICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXFxuICAgICAgICAgICAgaWYgKGVkaXRMZW5ndGggPiBtYXhFZGl0TGVuZ3RoKSB7XFxuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKCFleGVjRWRpdExlbmd0aCgpKSB7XFxuICAgICAgICAgICAgICBleGVjKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9LCAwKTtcXG4gICAgICAgIH0oKSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHdoaWxlIChlZGl0TGVuZ3RoIDw9IG1heEVkaXRMZW5ndGgpIHtcXG4gICAgICAgICAgdmFyIHJldCA9IGV4ZWNFZGl0TGVuZ3RoKCk7XFxuICAgICAgICAgIGlmIChyZXQpIHtcXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICBwdXNoQ29tcG9uZW50OiBmdW5jdGlvbihjb21wb25lbnRzLCBhZGRlZCwgcmVtb3ZlZCkge1xcbiAgICAgIHZhciBsYXN0ID0gY29tcG9uZW50c1tjb21wb25lbnRzLmxlbmd0aCAtIDFdO1xcbiAgICAgIGlmIChsYXN0ICYmIGxhc3QuYWRkZWQgPT09IGFkZGVkICYmIGxhc3QucmVtb3ZlZCA9PT0gcmVtb3ZlZCkge1xcbiAgICAgICAgLy8gV2UgbmVlZCB0byBjbG9uZSBoZXJlIGFzIHRoZSBjb21wb25lbnQgY2xvbmUgb3BlcmF0aW9uIGlzIGp1c3RcXG4gICAgICAgIC8vIGFzIHNoYWxsb3cgYXJyYXkgY2xvbmVcXG4gICAgICAgIGNvbXBvbmVudHNbY29tcG9uZW50cy5sZW5ndGggLSAxXSA9IHtjb3VudDogbGFzdC5jb3VudCArIDEsIGFkZGVkOiBhZGRlZCwgcmVtb3ZlZDogcmVtb3ZlZCB9O1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBjb21wb25lbnRzLnB1c2goe2NvdW50OiAxLCBhZGRlZDogYWRkZWQsIHJlbW92ZWQ6IHJlbW92ZWQgfSk7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBleHRyYWN0Q29tbW9uOiBmdW5jdGlvbihiYXNlUGF0aCwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIGRpYWdvbmFsUGF0aCkge1xcbiAgICAgIHZhciBuZXdMZW4gPSBuZXdTdHJpbmcubGVuZ3RoLFxcbiAgICAgICAgICBvbGRMZW4gPSBvbGRTdHJpbmcubGVuZ3RoLFxcbiAgICAgICAgICBuZXdQb3MgPSBiYXNlUGF0aC5uZXdQb3MsXFxuICAgICAgICAgIG9sZFBvcyA9IG5ld1BvcyAtIGRpYWdvbmFsUGF0aCxcXG5cXG4gICAgICAgICAgY29tbW9uQ291bnQgPSAwO1xcbiAgICAgIHdoaWxlIChuZXdQb3MgKyAxIDwgbmV3TGVuICYmIG9sZFBvcyArIDEgPCBvbGRMZW4gJiYgdGhpcy5lcXVhbHMobmV3U3RyaW5nW25ld1BvcyArIDFdLCBvbGRTdHJpbmdbb2xkUG9zICsgMV0pKSB7XFxuICAgICAgICBuZXdQb3MrKztcXG4gICAgICAgIG9sZFBvcysrO1xcbiAgICAgICAgY29tbW9uQ291bnQrKztcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGNvbW1vbkNvdW50KSB7XFxuICAgICAgICBiYXNlUGF0aC5jb21wb25lbnRzLnB1c2goe2NvdW50OiBjb21tb25Db3VudH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBiYXNlUGF0aC5uZXdQb3MgPSBuZXdQb3M7XFxuICAgICAgcmV0dXJuIG9sZFBvcztcXG4gICAgfSxcXG5cXG4gICAgZXF1YWxzOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xcbiAgICAgIHZhciByZVdoaXRlc3BhY2UgPSAvXFxcXFMvO1xcbiAgICAgIHJldHVybiBsZWZ0ID09PSByaWdodCB8fCAodGhpcy5pZ25vcmVXaGl0ZXNwYWNlICYmICFyZVdoaXRlc3BhY2UudGVzdChsZWZ0KSAmJiAhcmVXaGl0ZXNwYWNlLnRlc3QocmlnaHQpKTtcXG4gICAgfSxcXG4gICAgdG9rZW5pemU6IGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgICAgcmV0dXJuIHZhbHVlLnNwbGl0KCcnKTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIHZhciBDaGFyRGlmZiA9IG5ldyBEaWZmKCk7XFxuXFxuICB2YXIgV29yZERpZmYgPSBuZXcgRGlmZih0cnVlKTtcXG4gIHZhciBXb3JkV2l0aFNwYWNlRGlmZiA9IG5ldyBEaWZmKCk7XFxuICBXb3JkRGlmZi50b2tlbml6ZSA9IFdvcmRXaXRoU3BhY2VEaWZmLnRva2VuaXplID0gZnVuY3Rpb24odmFsdWUpIHtcXG4gICAgcmV0dXJuIHJlbW92ZUVtcHR5KHZhbHVlLnNwbGl0KC8oXFxcXHMrfFxcXFxiKS8pKTtcXG4gIH07XFxuXFxuICB2YXIgQ3NzRGlmZiA9IG5ldyBEaWZmKHRydWUpO1xcbiAgQ3NzRGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgIHJldHVybiByZW1vdmVFbXB0eSh2YWx1ZS5zcGxpdCgvKFt7fTo7LF18XFxcXHMrKS8pKTtcXG4gIH07XFxuXFxuICB2YXIgTGluZURpZmYgPSBuZXcgRGlmZigpO1xcblxcbiAgdmFyIFRyaW1tZWRMaW5lRGlmZiA9IG5ldyBEaWZmKCk7XFxuICBUcmltbWVkTGluZURpZmYuaWdub3JlVHJpbSA9IHRydWU7XFxuXFxuICBMaW5lRGlmZi50b2tlbml6ZSA9IFRyaW1tZWRMaW5lRGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgIHZhciByZXRMaW5lcyA9IFtdLFxcbiAgICAgICAgbGluZXMgPSB2YWx1ZS5zcGxpdCgvXi9tKTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciBsaW5lID0gbGluZXNbaV0sXFxuICAgICAgICAgIGxhc3RMaW5lID0gbGluZXNbaSAtIDFdLFxcbiAgICAgICAgICBsYXN0TGluZUxhc3RDaGFyID0gbGFzdExpbmUgJiYgbGFzdExpbmVbbGFzdExpbmUubGVuZ3RoIC0gMV07XFxuXFxuICAgICAgLy8gTWVyZ2UgbGluZXMgdGhhdCBtYXkgY29udGFpbiB3aW5kb3dzIG5ldyBsaW5lc1xcbiAgICAgIGlmIChsaW5lID09PSAnXFxcXG4nICYmIGxhc3RMaW5lTGFzdENoYXIgPT09ICdcXFxccicpIHtcXG4gICAgICAgICAgcmV0TGluZXNbcmV0TGluZXMubGVuZ3RoIC0gMV0gPSByZXRMaW5lc1tyZXRMaW5lcy5sZW5ndGggLSAxXS5zbGljZSgwLCAtMSkgKyAnXFxcXHJcXFxcbic7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGlmICh0aGlzLmlnbm9yZVRyaW0pIHtcXG4gICAgICAgICAgbGluZSA9IGxpbmUudHJpbSgpO1xcbiAgICAgICAgICAvLyBhZGQgYSBuZXdsaW5lIHVubGVzcyB0aGlzIGlzIHRoZSBsYXN0IGxpbmUuXFxuICAgICAgICAgIGlmIChpIDwgbGluZXMubGVuZ3RoIC0gMSkge1xcbiAgICAgICAgICAgIGxpbmUgKz0gJ1xcXFxuJztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcmV0TGluZXMucHVzaChsaW5lKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHJldExpbmVzO1xcbiAgfTtcXG5cXG4gIHZhciBQYXRjaERpZmYgPSBuZXcgRGlmZigpO1xcbiAgUGF0Y2hEaWZmLnRva2VuaXplID0gZnVuY3Rpb24odmFsdWUpIHtcXG4gICAgdmFyIHJldCA9IFtdLFxcbiAgICAgICAgbGluZXNBbmROZXdsaW5lcyA9IHZhbHVlLnNwbGl0KC8oXFxcXG58XFxcXHJcXFxcbikvKTtcXG5cXG4gICAgLy8gSWdub3JlIHRoZSBmaW5hbCBlbXB0eSB0b2tlbiB0aGF0IG9jY3VycyBpZiB0aGUgc3RyaW5nIGVuZHMgd2l0aCBhIG5ldyBsaW5lXFxuICAgIGlmICghbGluZXNBbmROZXdsaW5lc1tsaW5lc0FuZE5ld2xpbmVzLmxlbmd0aCAtIDFdKSB7XFxuICAgICAgbGluZXNBbmROZXdsaW5lcy5wb3AoKTtcXG4gICAgfVxcblxcbiAgICAvLyBNZXJnZSB0aGUgY29udGVudCBhbmQgbGluZSBzZXBhcmF0b3JzIGludG8gc2luZ2xlIHRva2Vuc1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzQW5kTmV3bGluZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICB2YXIgbGluZSA9IGxpbmVzQW5kTmV3bGluZXNbaV07XFxuXFxuICAgICAgaWYgKGkgJSAyKSB7XFxuICAgICAgICByZXRbcmV0Lmxlbmd0aCAtIDFdICs9IGxpbmU7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJldC5wdXNoKGxpbmUpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gcmV0O1xcbiAgfTtcXG5cXG4gIHZhciBTZW50ZW5jZURpZmYgPSBuZXcgRGlmZigpO1xcbiAgU2VudGVuY2VEaWZmLnRva2VuaXplID0gZnVuY3Rpb24odmFsdWUpIHtcXG4gICAgcmV0dXJuIHJlbW92ZUVtcHR5KHZhbHVlLnNwbGl0KC8oXFxcXFMuKz9bLiE/XSkoPz1cXFxccyt8JCkvKSk7XFxuICB9O1xcblxcbiAgdmFyIEpzb25EaWZmID0gbmV3IERpZmYoKTtcXG4gIC8vIERpc2NyaW1pbmF0ZSBiZXR3ZWVuIHR3byBsaW5lcyBvZiBwcmV0dHktcHJpbnRlZCwgc2VyaWFsaXplZCBKU09OIHdoZXJlIG9uZSBvZiB0aGVtIGhhcyBhXFxuICAvLyBkYW5nbGluZyBjb21tYSBhbmQgdGhlIG90aGVyIGRvZXNuJ3QuIFR1cm5zIG91dCBpbmNsdWRpbmcgdGhlIGRhbmdsaW5nIGNvbW1hIHlpZWxkcyB0aGUgbmljZXN0IG91dHB1dDpcXG4gIEpzb25EaWZmLnVzZUxvbmdlc3RUb2tlbiA9IHRydWU7XFxuICBKc29uRGlmZi50b2tlbml6ZSA9IExpbmVEaWZmLnRva2VuaXplO1xcbiAgSnNvbkRpZmYuZXF1YWxzID0gZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcXG4gICAgcmV0dXJuIExpbmVEaWZmLmVxdWFscyhsZWZ0LnJlcGxhY2UoLywoW1xcXFxyXFxcXG5dKS9nLCAnJDEnKSwgcmlnaHQucmVwbGFjZSgvLChbXFxcXHJcXFxcbl0pL2csICckMScpKTtcXG4gIH07XFxuXFxuICB2YXIgSnNEaWZmID0ge1xcbiAgICBEaWZmOiBEaWZmLFxcblxcbiAgICBkaWZmQ2hhcnM6IGZ1bmN0aW9uKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykgeyByZXR1cm4gQ2hhckRpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spOyB9LFxcbiAgICBkaWZmV29yZHM6IGZ1bmN0aW9uKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykgeyByZXR1cm4gV29yZERpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spOyB9LFxcbiAgICBkaWZmV29yZHNXaXRoU3BhY2U6IGZ1bmN0aW9uKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykgeyByZXR1cm4gV29yZFdpdGhTcGFjZURpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spOyB9LFxcbiAgICBkaWZmTGluZXM6IGZ1bmN0aW9uKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykgeyByZXR1cm4gTGluZURpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spOyB9LFxcbiAgICBkaWZmVHJpbW1lZExpbmVzOiBmdW5jdGlvbihvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spIHsgcmV0dXJuIFRyaW1tZWRMaW5lRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7IH0sXFxuXFxuICAgIGRpZmZTZW50ZW5jZXM6IGZ1bmN0aW9uKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykgeyByZXR1cm4gU2VudGVuY2VEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKTsgfSxcXG5cXG4gICAgZGlmZkNzczogZnVuY3Rpb24ob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7IHJldHVybiBDc3NEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKTsgfSxcXG4gICAgZGlmZkpzb246IGZ1bmN0aW9uKG9sZE9iaiwgbmV3T2JqLCBjYWxsYmFjaykge1xcbiAgICAgIHJldHVybiBKc29uRGlmZi5kaWZmKFxcbiAgICAgICAgdHlwZW9mIG9sZE9iaiA9PT0gJ3N0cmluZycgPyBvbGRPYmogOiBKU09OLnN0cmluZ2lmeShjYW5vbmljYWxpemUob2xkT2JqKSwgdW5kZWZpbmVkLCAnICAnKSxcXG4gICAgICAgIHR5cGVvZiBuZXdPYmogPT09ICdzdHJpbmcnID8gbmV3T2JqIDogSlNPTi5zdHJpbmdpZnkoY2Fub25pY2FsaXplKG5ld09iaiksIHVuZGVmaW5lZCwgJyAgJyksXFxuICAgICAgICBjYWxsYmFja1xcbiAgICAgICk7XFxuICAgIH0sXFxuXFxuICAgIGNyZWF0ZVR3b0ZpbGVzUGF0Y2g6IGZ1bmN0aW9uKG9sZEZpbGVOYW1lLCBuZXdGaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyKSB7XFxuICAgICAgdmFyIHJldCA9IFtdO1xcblxcbiAgICAgIGlmIChvbGRGaWxlTmFtZSA9PSBuZXdGaWxlTmFtZSkge1xcbiAgICAgICAgcmV0LnB1c2goJ0luZGV4OiAnICsgb2xkRmlsZU5hbWUpO1xcbiAgICAgIH1cXG4gICAgICByZXQucHVzaCgnPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PScpO1xcbiAgICAgIHJldC5wdXNoKCctLS0gJyArIG9sZEZpbGVOYW1lICsgKHR5cGVvZiBvbGRIZWFkZXIgPT09ICd1bmRlZmluZWQnID8gJycgOiAnXFxcXHQnICsgb2xkSGVhZGVyKSk7XFxuICAgICAgcmV0LnB1c2goJysrKyAnICsgbmV3RmlsZU5hbWUgKyAodHlwZW9mIG5ld0hlYWRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6ICdcXFxcdCcgKyBuZXdIZWFkZXIpKTtcXG5cXG4gICAgICB2YXIgZGlmZiA9IFBhdGNoRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyKTtcXG4gICAgICBkaWZmLnB1c2goe3ZhbHVlOiAnJywgbGluZXM6IFtdfSk7ICAgLy8gQXBwZW5kIGFuIGVtcHR5IHZhbHVlIHRvIG1ha2UgY2xlYW51cCBlYXNpZXJcXG5cXG4gICAgICAvLyBGb3JtYXRzIGEgZ2l2ZW4gc2V0IG9mIGxpbmVzIGZvciBwcmludGluZyBhcyBjb250ZXh0IGxpbmVzIGluIGEgcGF0Y2hcXG4gICAgICBmdW5jdGlvbiBjb250ZXh0TGluZXMobGluZXMpIHtcXG4gICAgICAgIHJldHVybiBtYXAobGluZXMsIGZ1bmN0aW9uKGVudHJ5KSB7IHJldHVybiAnICcgKyBlbnRyeTsgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIC8vIE91dHB1dHMgdGhlIG5vIG5ld2xpbmUgYXQgZW5kIG9mIGZpbGUgd2FybmluZyBpZiBuZWVkZWRcXG4gICAgICBmdW5jdGlvbiBlb2ZOTChjdXJSYW5nZSwgaSwgY3VycmVudCkge1xcbiAgICAgICAgdmFyIGxhc3QgPSBkaWZmW2RpZmYubGVuZ3RoIC0gMl0sXFxuICAgICAgICAgICAgaXNMYXN0ID0gaSA9PT0gZGlmZi5sZW5ndGggLSAyLFxcbiAgICAgICAgICAgIGlzTGFzdE9mVHlwZSA9IGkgPT09IGRpZmYubGVuZ3RoIC0gMyAmJiBjdXJyZW50LmFkZGVkICE9PSBsYXN0LmFkZGVkO1xcblxcbiAgICAgICAgLy8gRmlndXJlIG91dCBpZiB0aGlzIGlzIHRoZSBsYXN0IGxpbmUgZm9yIHRoZSBnaXZlbiBmaWxlIGFuZCBtaXNzaW5nIE5MXFxuICAgICAgICBpZiAoISgvXFxcXG4kLy50ZXN0KGN1cnJlbnQudmFsdWUpKSAmJiAoaXNMYXN0IHx8IGlzTGFzdE9mVHlwZSkpIHtcXG4gICAgICAgICAgY3VyUmFuZ2UucHVzaCgnXFxcXFxcXFwgTm8gbmV3bGluZSBhdCBlbmQgb2YgZmlsZScpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgb2xkUmFuZ2VTdGFydCA9IDAsIG5ld1JhbmdlU3RhcnQgPSAwLCBjdXJSYW5nZSA9IFtdLFxcbiAgICAgICAgICBvbGRMaW5lID0gMSwgbmV3TGluZSA9IDE7XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaWZmLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICB2YXIgY3VycmVudCA9IGRpZmZbaV0sXFxuICAgICAgICAgICAgbGluZXMgPSBjdXJyZW50LmxpbmVzIHx8IGN1cnJlbnQudmFsdWUucmVwbGFjZSgvXFxcXG4kLywgJycpLnNwbGl0KCdcXFxcbicpO1xcbiAgICAgICAgY3VycmVudC5saW5lcyA9IGxpbmVzO1xcblxcbiAgICAgICAgaWYgKGN1cnJlbnQuYWRkZWQgfHwgY3VycmVudC5yZW1vdmVkKSB7XFxuICAgICAgICAgIC8vIElmIHdlIGhhdmUgcHJldmlvdXMgY29udGV4dCwgc3RhcnQgd2l0aCB0aGF0XFxuICAgICAgICAgIGlmICghb2xkUmFuZ2VTdGFydCkge1xcbiAgICAgICAgICAgIHZhciBwcmV2ID0gZGlmZltpIC0gMV07XFxuICAgICAgICAgICAgb2xkUmFuZ2VTdGFydCA9IG9sZExpbmU7XFxuICAgICAgICAgICAgbmV3UmFuZ2VTdGFydCA9IG5ld0xpbmU7XFxuXFxuICAgICAgICAgICAgaWYgKHByZXYpIHtcXG4gICAgICAgICAgICAgIGN1clJhbmdlID0gY29udGV4dExpbmVzKHByZXYubGluZXMuc2xpY2UoLTQpKTtcXG4gICAgICAgICAgICAgIG9sZFJhbmdlU3RhcnQgLT0gY3VyUmFuZ2UubGVuZ3RoO1xcbiAgICAgICAgICAgICAgbmV3UmFuZ2VTdGFydCAtPSBjdXJSYW5nZS5sZW5ndGg7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIC8vIE91dHB1dCBvdXIgY2hhbmdlc1xcbiAgICAgICAgICBjdXJSYW5nZS5wdXNoLmFwcGx5KGN1clJhbmdlLCBtYXAobGluZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XFxuICAgICAgICAgICAgcmV0dXJuIChjdXJyZW50LmFkZGVkID8gJysnIDogJy0nKSArIGVudHJ5O1xcbiAgICAgICAgICB9KSk7XFxuICAgICAgICAgIGVvZk5MKGN1clJhbmdlLCBpLCBjdXJyZW50KTtcXG5cXG4gICAgICAgICAgLy8gVHJhY2sgdGhlIHVwZGF0ZWQgZmlsZSBwb3NpdGlvblxcbiAgICAgICAgICBpZiAoY3VycmVudC5hZGRlZCkge1xcbiAgICAgICAgICAgIG5ld0xpbmUgKz0gbGluZXMubGVuZ3RoO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIG9sZExpbmUgKz0gbGluZXMubGVuZ3RoO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAvLyBJZGVudGljYWwgY29udGV4dCBsaW5lcy4gVHJhY2sgbGluZSBjaGFuZ2VzXFxuICAgICAgICAgIGlmIChvbGRSYW5nZVN0YXJ0KSB7XFxuICAgICAgICAgICAgLy8gQ2xvc2Ugb3V0IGFueSBjaGFuZ2VzIHRoYXQgaGF2ZSBiZWVuIG91dHB1dCAob3Igam9pbiBvdmVybGFwcGluZylcXG4gICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoIDw9IDggJiYgaSA8IGRpZmYubGVuZ3RoIC0gMikge1xcbiAgICAgICAgICAgICAgLy8gT3ZlcmxhcHBpbmdcXG4gICAgICAgICAgICAgIGN1clJhbmdlLnB1c2guYXBwbHkoY3VyUmFuZ2UsIGNvbnRleHRMaW5lcyhsaW5lcykpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAvLyBlbmQgdGhlIHJhbmdlIGFuZCBvdXRwdXRcXG4gICAgICAgICAgICAgIHZhciBjb250ZXh0U2l6ZSA9IE1hdGgubWluKGxpbmVzLmxlbmd0aCwgNCk7XFxuICAgICAgICAgICAgICByZXQucHVzaChcXG4gICAgICAgICAgICAgICAgICAnQEAgLScgKyBvbGRSYW5nZVN0YXJ0ICsgJywnICsgKG9sZExpbmUgLSBvbGRSYW5nZVN0YXJ0ICsgY29udGV4dFNpemUpXFxuICAgICAgICAgICAgICAgICAgKyAnICsnICsgbmV3UmFuZ2VTdGFydCArICcsJyArIChuZXdMaW5lIC0gbmV3UmFuZ2VTdGFydCArIGNvbnRleHRTaXplKVxcbiAgICAgICAgICAgICAgICAgICsgJyBAQCcpO1xcbiAgICAgICAgICAgICAgcmV0LnB1c2guYXBwbHkocmV0LCBjdXJSYW5nZSk7XFxuICAgICAgICAgICAgICByZXQucHVzaC5hcHBseShyZXQsIGNvbnRleHRMaW5lcyhsaW5lcy5zbGljZSgwLCBjb250ZXh0U2l6ZSkpKTtcXG4gICAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPD0gNCkge1xcbiAgICAgICAgICAgICAgICBlb2ZOTChyZXQsIGksIGN1cnJlbnQpO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgb2xkUmFuZ2VTdGFydCA9IDA7XFxuICAgICAgICAgICAgICBuZXdSYW5nZVN0YXJ0ID0gMDtcXG4gICAgICAgICAgICAgIGN1clJhbmdlID0gW107XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIG9sZExpbmUgKz0gbGluZXMubGVuZ3RoO1xcbiAgICAgICAgICBuZXdMaW5lICs9IGxpbmVzLmxlbmd0aDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHJldC5qb2luKCdcXFxcbicpICsgJ1xcXFxuJztcXG4gICAgfSxcXG5cXG4gICAgY3JlYXRlUGF0Y2g6IGZ1bmN0aW9uKGZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIpIHtcXG4gICAgICByZXR1cm4gSnNEaWZmLmNyZWF0ZVR3b0ZpbGVzUGF0Y2goZmlsZU5hbWUsIGZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIpO1xcbiAgICB9LFxcblxcbiAgICBhcHBseVBhdGNoOiBmdW5jdGlvbihvbGRTdHIsIHVuaURpZmYpIHtcXG4gICAgICB2YXIgZGlmZnN0ciA9IHVuaURpZmYuc3BsaXQoJ1xcXFxuJyksXFxuICAgICAgICAgIGh1bmtzID0gW10sXFxuICAgICAgICAgIGkgPSAwLFxcbiAgICAgICAgICByZW1FT0ZOTCA9IGZhbHNlLFxcbiAgICAgICAgICBhZGRFT0ZOTCA9IGZhbHNlO1xcblxcbiAgICAgIC8vIFNraXAgdG8gdGhlIGZpcnN0IGNoYW5nZSBodW5rXFxuICAgICAgd2hpbGUgKGkgPCBkaWZmc3RyLmxlbmd0aCAmJiAhKC9eQEAvLnRlc3QoZGlmZnN0cltpXSkpKSB7XFxuICAgICAgICBpKys7XFxuICAgICAgfVxcblxcbiAgICAgIC8vIFBhcnNlIHRoZSB1bmlmaWVkIGRpZmZcXG4gICAgICBmb3IgKDsgaSA8IGRpZmZzdHIubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIGlmIChkaWZmc3RyW2ldWzBdID09PSAnQCcpIHtcXG4gICAgICAgICAgdmFyIGNobnVrSGVhZGVyID0gZGlmZnN0cltpXS5zcGxpdCgvQEAgLShcXFxcZCspLChcXFxcZCspIFxcXFwrKFxcXFxkKyksKFxcXFxkKykgQEAvKTtcXG4gICAgICAgICAgaHVua3MudW5zaGlmdCh7XFxuICAgICAgICAgICAgc3RhcnQ6IGNobnVrSGVhZGVyWzNdLFxcbiAgICAgICAgICAgIG9sZGxlbmd0aDogK2NobnVrSGVhZGVyWzJdLFxcbiAgICAgICAgICAgIHJlbW92ZWQ6IFtdLFxcbiAgICAgICAgICAgIG5ld2xlbmd0aDogY2hudWtIZWFkZXJbNF0sXFxuICAgICAgICAgICAgYWRkZWQ6IFtdXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfSBlbHNlIGlmIChkaWZmc3RyW2ldWzBdID09PSAnKycpIHtcXG4gICAgICAgICAgaHVua3NbMF0uYWRkZWQucHVzaChkaWZmc3RyW2ldLnN1YnN0cigxKSk7XFxuICAgICAgICB9IGVsc2UgaWYgKGRpZmZzdHJbaV1bMF0gPT09ICctJykge1xcbiAgICAgICAgICBodW5rc1swXS5yZW1vdmVkLnB1c2goZGlmZnN0cltpXS5zdWJzdHIoMSkpO1xcbiAgICAgICAgfSBlbHNlIGlmIChkaWZmc3RyW2ldWzBdID09PSAnICcpIHtcXG4gICAgICAgICAgaHVua3NbMF0uYWRkZWQucHVzaChkaWZmc3RyW2ldLnN1YnN0cigxKSk7XFxuICAgICAgICAgIGh1bmtzWzBdLnJlbW92ZWQucHVzaChkaWZmc3RyW2ldLnN1YnN0cigxKSk7XFxuICAgICAgICB9IGVsc2UgaWYgKGRpZmZzdHJbaV1bMF0gPT09ICdcXFxcXFxcXCcpIHtcXG4gICAgICAgICAgaWYgKGRpZmZzdHJbaSAtIDFdWzBdID09PSAnKycpIHtcXG4gICAgICAgICAgICByZW1FT0ZOTCA9IHRydWU7XFxuICAgICAgICAgIH0gZWxzZSBpZiAoZGlmZnN0cltpIC0gMV1bMF0gPT09ICctJykge1xcbiAgICAgICAgICAgIGFkZEVPRk5MID0gdHJ1ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICAvLyBBcHBseSB0aGUgZGlmZiB0byB0aGUgaW5wdXRcXG4gICAgICB2YXIgbGluZXMgPSBvbGRTdHIuc3BsaXQoJ1xcXFxuJyk7XFxuICAgICAgZm9yIChpID0gaHVua3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcXG4gICAgICAgIHZhciBodW5rID0gaHVua3NbaV07XFxuICAgICAgICAvLyBTYW5pdHkgY2hlY2sgdGhlIGlucHV0IHN0cmluZy4gQmFpbCBpZiB3ZSBkb24ndCBtYXRjaC5cXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaHVuay5vbGRsZW5ndGg7IGorKykge1xcbiAgICAgICAgICBpZiAobGluZXNbaHVuay5zdGFydCAtIDEgKyBqXSAhPT0gaHVuay5yZW1vdmVkW2pdKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmFwcGx5KGxpbmVzLCBbaHVuay5zdGFydCAtIDEsIGh1bmsub2xkbGVuZ3RoXS5jb25jYXQoaHVuay5hZGRlZCkpO1xcbiAgICAgIH1cXG5cXG4gICAgICAvLyBIYW5kbGUgRU9GTkwgaW5zZXJ0aW9uL3JlbW92YWxcXG4gICAgICBpZiAocmVtRU9GTkwpIHtcXG4gICAgICAgIHdoaWxlICghbGluZXNbbGluZXMubGVuZ3RoIC0gMV0pIHtcXG4gICAgICAgICAgbGluZXMucG9wKCk7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIGlmIChhZGRFT0ZOTCkge1xcbiAgICAgICAgbGluZXMucHVzaCgnJyk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBsaW5lcy5qb2luKCdcXFxcbicpO1xcbiAgICB9LFxcblxcbiAgICBjb252ZXJ0Q2hhbmdlc1RvWE1MOiBmdW5jdGlvbihjaGFuZ2VzKSB7XFxuICAgICAgdmFyIHJldCA9IFtdO1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNbaV07XFxuICAgICAgICBpZiAoY2hhbmdlLmFkZGVkKSB7XFxuICAgICAgICAgIHJldC5wdXNoKCc8aW5zPicpO1xcbiAgICAgICAgfSBlbHNlIGlmIChjaGFuZ2UucmVtb3ZlZCkge1xcbiAgICAgICAgICByZXQucHVzaCgnPGRlbD4nKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldC5wdXNoKGVzY2FwZUhUTUwoY2hhbmdlLnZhbHVlKSk7XFxuXFxuICAgICAgICBpZiAoY2hhbmdlLmFkZGVkKSB7XFxuICAgICAgICAgIHJldC5wdXNoKCc8L2lucz4nKTtcXG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbmdlLnJlbW92ZWQpIHtcXG4gICAgICAgICAgcmV0LnB1c2goJzwvZGVsPicpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gcmV0LmpvaW4oJycpO1xcbiAgICB9LFxcblxcbiAgICAvLyBTZWU6IGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9nb29nbGUtZGlmZi1tYXRjaC1wYXRjaC93aWtpL0FQSVxcbiAgICBjb252ZXJ0Q2hhbmdlc1RvRE1QOiBmdW5jdGlvbihjaGFuZ2VzKSB7XFxuICAgICAgdmFyIHJldCA9IFtdLFxcbiAgICAgICAgICBjaGFuZ2UsXFxuICAgICAgICAgIG9wZXJhdGlvbjtcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIGNoYW5nZSA9IGNoYW5nZXNbaV07XFxuICAgICAgICBpZiAoY2hhbmdlLmFkZGVkKSB7XFxuICAgICAgICAgIG9wZXJhdGlvbiA9IDE7XFxuICAgICAgICB9IGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XFxuICAgICAgICAgIG9wZXJhdGlvbiA9IC0xO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgb3BlcmF0aW9uID0gMDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldC5wdXNoKFtvcGVyYXRpb24sIGNoYW5nZS52YWx1ZV0pO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gcmV0O1xcbiAgICB9LFxcblxcbiAgICBjYW5vbmljYWxpemU6IGNhbm9uaWNhbGl6ZVxcbiAgfTtcXG5cXG4gIC8qaXN0YW5idWwgaWdub3JlIG5leHQgKi9cXG4gIC8qZ2xvYmFsIG1vZHVsZSAqL1xcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XFxuICAgIG1vZHVsZS5leHBvcnRzID0gSnNEaWZmO1xcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcXG4gICAgLypnbG9iYWwgZGVmaW5lICovXFxuICAgIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7IHJldHVybiBKc0RpZmY7IH0pO1xcbiAgfSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsLkpzRGlmZiA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgZ2xvYmFsLkpzRGlmZiA9IEpzRGlmZjtcXG4gIH1cXG59KHRoaXMpKTtcXG5cXG59LHt9XSw2ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbnZhciBtYXRjaE9wZXJhdG9yc1JlID0gL1t8XFxcXFxcXFx7fSgpW1xcXFxdXiQrKj8uXS9nO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cikge1xcblxcdGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xcblxcdFxcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nJyk7XFxuXFx0fVxcblxcblxcdHJldHVybiBzdHIucmVwbGFjZShtYXRjaE9wZXJhdG9yc1JlLCAgJ1xcXFxcXFxcJCYnKTtcXG59O1xcblxcbn0se31dLDY5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbi8vIEdyb3dsIC0gQ29weXJpZ2h0IFRKIEhvbG93YXljaHVrIDx0akB2aXNpb24tbWVkaWEuY2E+IChNSVQgTGljZW5zZWQpXFxuXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgZXhlYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjXFxuICAsIGZzID0gcmVxdWlyZSgnZnMnKVxcbiAgLCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXFxuICAsIGV4aXN0cyA9IGZzLmV4aXN0c1N5bmMgfHwgcGF0aC5leGlzdHNTeW5jXFxuICAsIG9zID0gcmVxdWlyZSgnb3MnKVxcbiAgLCBxdW90ZSA9IEpTT04uc3RyaW5naWZ5XFxuICAsIGNtZDtcXG5cXG5mdW5jdGlvbiB3aGljaChuYW1lKSB7XFxuICB2YXIgcGF0aHMgPSBwcm9jZXNzLmVudi5QQVRILnNwbGl0KCc6Jyk7XFxuICB2YXIgbG9jO1xcbiAgXFxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGF0aHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcXG4gICAgbG9jID0gcGF0aC5qb2luKHBhdGhzW2ldLCBuYW1lKTtcXG4gICAgaWYgKGV4aXN0cyhsb2MpKSByZXR1cm4gbG9jO1xcbiAgfVxcbn1cXG5cXG5zd2l0Y2gob3MudHlwZSgpKSB7XFxuICBjYXNlICdEYXJ3aW4nOlxcbiAgICBpZiAod2hpY2goJ3Rlcm1pbmFsLW5vdGlmaWVyJykpIHtcXG4gICAgICBjbWQgPSB7XFxuICAgICAgICAgIHR5cGU6IFxcXCJEYXJ3aW4tTm90aWZpY2F0aW9uQ2VudGVyXFxcIlxcbiAgICAgICAgLCBwa2c6IFxcXCJ0ZXJtaW5hbC1ub3RpZmllclxcXCJcXG4gICAgICAgICwgbXNnOiAnLW1lc3NhZ2UnXFxuICAgICAgICAsIHRpdGxlOiAnLXRpdGxlJ1xcbiAgICAgICAgLCBzdWJ0aXRsZTogJy1zdWJ0aXRsZSdcXG4gICAgICAgICwgcHJpb3JpdHk6IHtcXG4gICAgICAgICAgICAgIGNtZDogJy1leGVjdXRlJ1xcbiAgICAgICAgICAgICwgcmFuZ2U6IFtdXFxuICAgICAgICAgIH1cXG4gICAgICB9O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGNtZCA9IHtcXG4gICAgICAgICAgdHlwZTogXFxcIkRhcndpbi1Hcm93bFxcXCJcXG4gICAgICAgICwgcGtnOiBcXFwiZ3Jvd2xub3RpZnlcXFwiXFxuICAgICAgICAsIG1zZzogJy1tJ1xcbiAgICAgICAgLCBzdGlja3k6ICctLXN0aWNreSdcXG4gICAgICAgICwgcHJpb3JpdHk6IHtcXG4gICAgICAgICAgICAgIGNtZDogJy0tcHJpb3JpdHknXFxuICAgICAgICAgICAgLCByYW5nZTogW1xcbiAgICAgICAgICAgICAgICAtMlxcbiAgICAgICAgICAgICAgLCAtMVxcbiAgICAgICAgICAgICAgLCAwXFxuICAgICAgICAgICAgICAsIDFcXG4gICAgICAgICAgICAgICwgMlxcbiAgICAgICAgICAgICAgLCBcXFwiVmVyeSBMb3dcXFwiXFxuICAgICAgICAgICAgICAsIFxcXCJNb2RlcmF0ZVxcXCJcXG4gICAgICAgICAgICAgICwgXFxcIk5vcm1hbFxcXCJcXG4gICAgICAgICAgICAgICwgXFxcIkhpZ2hcXFwiXFxuICAgICAgICAgICAgICAsIFxcXCJFbWVyZ2VuY3lcXFwiXFxuICAgICAgICAgICAgXVxcbiAgICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgfVxcbiAgICBicmVhaztcXG4gIGNhc2UgJ0xpbnV4JzpcXG4gICAgY21kID0ge1xcbiAgICAgICAgdHlwZTogXFxcIkxpbnV4XFxcIlxcbiAgICAgICwgcGtnOiBcXFwibm90aWZ5LXNlbmRcXFwiXFxuICAgICAgLCBtc2c6ICcnXFxuICAgICAgLCBzdGlja3k6ICctdCAwJ1xcbiAgICAgICwgaWNvbjogJy1pJ1xcbiAgICAgICwgcHJpb3JpdHk6IHtcXG4gICAgICAgICAgY21kOiAnLXUnXFxuICAgICAgICAsIHJhbmdlOiBbXFxuICAgICAgICAgICAgXFxcImxvd1xcXCJcXG4gICAgICAgICAgLCBcXFwibm9ybWFsXFxcIlxcbiAgICAgICAgICAsIFxcXCJjcml0aWNhbFxcXCJcXG4gICAgICAgIF1cXG4gICAgICB9XFxuICAgIH07XFxuICAgIGJyZWFrO1xcbiAgY2FzZSAnV2luZG93c19OVCc6XFxuICAgIGNtZCA9IHtcXG4gICAgICAgIHR5cGU6IFxcXCJXaW5kb3dzXFxcIlxcbiAgICAgICwgcGtnOiBcXFwiZ3Jvd2xub3RpZnlcXFwiXFxuICAgICAgLCBtc2c6ICcnXFxuICAgICAgLCBzdGlja3k6ICcvczp0cnVlJ1xcbiAgICAgICwgdGl0bGU6ICcvdDonXFxuICAgICAgLCBpY29uOiAnL2k6J1xcbiAgICAgICwgcHJpb3JpdHk6IHtcXG4gICAgICAgICAgICBjbWQ6ICcvcDonXFxuICAgICAgICAgICwgcmFuZ2U6IFtcXG4gICAgICAgICAgICAgIC0yXFxuICAgICAgICAgICAgLCAtMVxcbiAgICAgICAgICAgICwgMFxcbiAgICAgICAgICAgICwgMVxcbiAgICAgICAgICAgICwgMlxcbiAgICAgICAgICBdXFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIGJyZWFrO1xcbn1cXG5cXG4vKipcXG4gKiBFeHBvc2UgYGdyb3dsYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBncm93bDtcXG5cXG4vKipcXG4gKiBOb2RlLWdyb3dsIHZlcnNpb24uXFxuICovXFxuXFxuZXhwb3J0cy52ZXJzaW9uID0gJzEuNC4xJ1xcblxcbi8qKlxcbiAqIFNlbmQgZ3Jvd2wgbm90aWZpY2F0aW9uIF9tc2dfIHdpdGggX29wdGlvbnNfLlxcbiAqXFxuICogT3B0aW9uczpcXG4gKlxcbiAqICAtIHRpdGxlICAgTm90aWZpY2F0aW9uIHRpdGxlXFxuICogIC0gc3RpY2t5ICBNYWtlIHRoZSBub3RpZmljYXRpb24gc3RpY2sgKGRlZmF1bHRzIHRvIGZhbHNlKVxcbiAqICAtIHByaW9yaXR5ICBTcGVjaWZ5IGFuIGludCBvciBuYW1lZCBrZXkgKGRlZmF1bHQgaXMgMClcXG4gKiAgLSBuYW1lICAgIEFwcGxpY2F0aW9uIG5hbWUgKGRlZmF1bHRzIHRvIGdyb3dsbm90aWZ5KVxcbiAqICAtIGltYWdlXFxuICogICAgLSBwYXRoIHRvIGFuIGljb24gc2V0cyAtLWljb25wYXRoXFxuICogICAgLSBwYXRoIHRvIGFuIGltYWdlIHNldHMgLS1pbWFnZVxcbiAqICAgIC0gY2FwaXRhbGl6ZWQgd29yZCBzZXRzIC0tYXBwSWNvblxcbiAqICAgIC0gZmlsZW5hbWUgdXNlcyBleHRuYW1lIGFzIC0taWNvblxcbiAqICAgIC0gb3RoZXJ3aXNlIHRyZWF0ZWQgYXMgLS1pY29uXFxuICpcXG4gKiBFeGFtcGxlczpcXG4gKlxcbiAqICAgZ3Jvd2woJ05ldyBlbWFpbCcpXFxuICogICBncm93bCgnNSBuZXcgZW1haWxzJywgeyB0aXRsZTogJ1RodW5kZXJiaXJkJyB9KVxcbiAqICAgZ3Jvd2woJ0VtYWlsIHNlbnQnLCBmdW5jdGlvbigpe1xcbiAqICAgICAvLyAuLi4gbm90aWZpY2F0aW9uIHNlbnRcXG4gKiAgIH0pXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gbXNnXFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmblxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuXFxuZnVuY3Rpb24gZ3Jvd2wobXNnLCBvcHRpb25zLCBmbikge1xcbiAgdmFyIGltYWdlXFxuICAgICwgYXJnc1xcbiAgICAsIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XFxuICAgICwgZm4gPSBmbiB8fCBmdW5jdGlvbigpe307XFxuXFxuICAvLyBub29wXFxuICBpZiAoIWNtZCkgcmV0dXJuIGZuKG5ldyBFcnJvcignZ3Jvd2wgbm90IHN1cHBvcnRlZCBvbiB0aGlzIHBsYXRmb3JtJykpO1xcbiAgYXJncyA9IFtjbWQucGtnXTtcXG5cXG4gIC8vIGltYWdlXFxuICBpZiAoaW1hZ2UgPSBvcHRpb25zLmltYWdlKSB7XFxuICAgIHN3aXRjaChjbWQudHlwZSkge1xcbiAgICAgIGNhc2UgJ0Rhcndpbi1Hcm93bCc6XFxuICAgICAgICB2YXIgZmxhZywgZXh0ID0gcGF0aC5leHRuYW1lKGltYWdlKS5zdWJzdHIoMSlcXG4gICAgICAgIGZsYWcgPSBmbGFnIHx8IGV4dCA9PSAnaWNucycgJiYgJ2ljb25wYXRoJ1xcbiAgICAgICAgZmxhZyA9IGZsYWcgfHwgL15bQS1aXS8udGVzdChpbWFnZSkgJiYgJ2FwcEljb24nXFxuICAgICAgICBmbGFnID0gZmxhZyB8fCAvXnBuZ3xnaWZ8anBlP2ckLy50ZXN0KGV4dCkgJiYgJ2ltYWdlJ1xcbiAgICAgICAgZmxhZyA9IGZsYWcgfHwgZXh0ICYmIChpbWFnZSA9IGV4dCkgJiYgJ2ljb24nXFxuICAgICAgICBmbGFnID0gZmxhZyB8fCAnaWNvbidcXG4gICAgICAgIGFyZ3MucHVzaCgnLS0nICsgZmxhZywgcXVvdGUoaW1hZ2UpKVxcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSAnTGludXgnOlxcbiAgICAgICAgYXJncy5wdXNoKGNtZC5pY29uLCBxdW90ZShpbWFnZSkpO1xcbiAgICAgICAgLy8gbGlibm90aWZ5IGRlZmF1bHRzIHRvIHN0aWNreSwgc2V0IGEgaGludCBmb3IgdHJhbnNpZW50IG5vdGlmaWNhdGlvbnNcXG4gICAgICAgIGlmICghb3B0aW9ucy5zdGlja3kpIGFyZ3MucHVzaCgnLS1oaW50PWludDp0cmFuc2llbnQ6MScpO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSAnV2luZG93cyc6XFxuICAgICAgICBhcmdzLnB1c2goY21kLmljb24gKyBxdW90ZShpbWFnZSkpO1xcbiAgICAgICAgYnJlYWs7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIHN0aWNreVxcbiAgaWYgKG9wdGlvbnMuc3RpY2t5KSBhcmdzLnB1c2goY21kLnN0aWNreSk7XFxuXFxuICAvLyBwcmlvcml0eVxcbiAgaWYgKG9wdGlvbnMucHJpb3JpdHkpIHtcXG4gICAgdmFyIHByaW9yaXR5ID0gb3B0aW9ucy5wcmlvcml0eSArICcnO1xcbiAgICB2YXIgY2hlY2tpbmRleE9mID0gY21kLnByaW9yaXR5LnJhbmdlLmluZGV4T2YocHJpb3JpdHkpO1xcbiAgICBpZiAofmNtZC5wcmlvcml0eS5yYW5nZS5pbmRleE9mKHByaW9yaXR5KSkge1xcbiAgICAgIGFyZ3MucHVzaChjbWQucHJpb3JpdHksIG9wdGlvbnMucHJpb3JpdHkpO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBuYW1lXFxuICBpZiAob3B0aW9ucy5uYW1lICYmIGNtZC50eXBlID09PSBcXFwiRGFyd2luLUdyb3dsXFxcIikge1xcbiAgICBhcmdzLnB1c2goJy0tbmFtZScsIG9wdGlvbnMubmFtZSk7XFxuICB9XFxuXFxuICBzd2l0Y2goY21kLnR5cGUpIHtcXG4gICAgY2FzZSAnRGFyd2luLUdyb3dsJzpcXG4gICAgICBhcmdzLnB1c2goY21kLm1zZyk7XFxuICAgICAgYXJncy5wdXNoKHF1b3RlKG1zZykpO1xcbiAgICAgIGlmIChvcHRpb25zLnRpdGxlKSBhcmdzLnB1c2gocXVvdGUob3B0aW9ucy50aXRsZSkpO1xcbiAgICAgIGJyZWFrO1xcbiAgICBjYXNlICdEYXJ3aW4tTm90aWZpY2F0aW9uQ2VudGVyJzpcXG4gICAgICBhcmdzLnB1c2goY21kLm1zZyk7XFxuICAgICAgYXJncy5wdXNoKHF1b3RlKG1zZykpO1xcbiAgICAgIGlmIChvcHRpb25zLnRpdGxlKSB7XFxuICAgICAgICBhcmdzLnB1c2goY21kLnRpdGxlKTtcXG4gICAgICAgIGFyZ3MucHVzaChxdW90ZShvcHRpb25zLnRpdGxlKSk7XFxuICAgICAgfVxcbiAgICAgIGlmIChvcHRpb25zLnN1YnRpdGxlKSB7XFxuICAgICAgICBhcmdzLnB1c2goY21kLnN1YnRpdGxlKTtcXG4gICAgICAgIGFyZ3MucHVzaChxdW90ZShvcHRpb25zLnN1YnRpdGxlKSk7XFxuICAgICAgfVxcbiAgICAgIGJyZWFrO1xcbiAgICBjYXNlICdEYXJ3aW4tR3Jvd2wnOlxcbiAgICAgIGFyZ3MucHVzaChjbWQubXNnKTtcXG4gICAgICBhcmdzLnB1c2gocXVvdGUobXNnKSk7XFxuICAgICAgaWYgKG9wdGlvbnMudGl0bGUpIGFyZ3MucHVzaChxdW90ZShvcHRpb25zLnRpdGxlKSk7XFxuICAgICAgYnJlYWs7XFxuICAgIGNhc2UgJ0xpbnV4JzpcXG4gICAgICBpZiAob3B0aW9ucy50aXRsZSkge1xcbiAgICAgICAgYXJncy5wdXNoKHF1b3RlKG9wdGlvbnMudGl0bGUpKTtcXG4gICAgICAgIGFyZ3MucHVzaChjbWQubXNnKTtcXG4gICAgICAgIGFyZ3MucHVzaChxdW90ZShtc2cpKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgYXJncy5wdXNoKHF1b3RlKG1zZykpO1xcbiAgICAgIH1cXG4gICAgICBicmVhaztcXG4gICAgY2FzZSAnV2luZG93cyc6XFxuICAgICAgYXJncy5wdXNoKHF1b3RlKG1zZykpO1xcbiAgICAgIGlmIChvcHRpb25zLnRpdGxlKSBhcmdzLnB1c2goY21kLnRpdGxlICsgcXVvdGUob3B0aW9ucy50aXRsZSkpO1xcbiAgICAgIGJyZWFrO1xcbiAgfVxcblxcbiAgLy8gZXhlY3V0ZVxcbiAgZXhlYyhhcmdzLmpvaW4oJyAnKSwgZm4pO1xcbn07XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIl9wcm9jZXNzXFxcIjo1MSxcXFwiY2hpbGRfcHJvY2Vzc1xcXCI6NDEsXFxcImZzXFxcIjo0MSxcXFwib3NcXFwiOjUwLFxcXCJwYXRoXFxcIjo0MX1dLDcwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XFxudmFyIF8wNzc3ID0gcGFyc2VJbnQoJzA3NzcnLCA4KTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IG1rZGlyUC5ta2RpcnAgPSBta2RpclAubWtkaXJQID0gbWtkaXJQO1xcblxcbmZ1bmN0aW9uIG1rZGlyUCAocCwgb3B0cywgZiwgbWFkZSkge1xcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIGYgPSBvcHRzO1xcbiAgICAgICAgb3B0cyA9IHt9O1xcbiAgICB9XFxuICAgIGVsc2UgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xcbiAgICAgICAgb3B0cyA9IHsgbW9kZTogb3B0cyB9O1xcbiAgICB9XFxuICAgIFxcbiAgICB2YXIgbW9kZSA9IG9wdHMubW9kZTtcXG4gICAgdmFyIHhmcyA9IG9wdHMuZnMgfHwgZnM7XFxuICAgIFxcbiAgICBpZiAobW9kZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICBtb2RlID0gXzA3NzcgJiAofnByb2Nlc3MudW1hc2soKSk7XFxuICAgIH1cXG4gICAgaWYgKCFtYWRlKSBtYWRlID0gbnVsbDtcXG4gICAgXFxuICAgIHZhciBjYiA9IGYgfHwgZnVuY3Rpb24gKCkge307XFxuICAgIHAgPSBwYXRoLnJlc29sdmUocCk7XFxuICAgIFxcbiAgICB4ZnMubWtkaXIocCwgbW9kZSwgZnVuY3Rpb24gKGVyKSB7XFxuICAgICAgICBpZiAoIWVyKSB7XFxuICAgICAgICAgICAgbWFkZSA9IG1hZGUgfHwgcDtcXG4gICAgICAgICAgICByZXR1cm4gY2IobnVsbCwgbWFkZSk7XFxuICAgICAgICB9XFxuICAgICAgICBzd2l0Y2ggKGVyLmNvZGUpIHtcXG4gICAgICAgICAgICBjYXNlICdFTk9FTlQnOlxcbiAgICAgICAgICAgICAgICBta2RpclAocGF0aC5kaXJuYW1lKHApLCBvcHRzLCBmdW5jdGlvbiAoZXIsIG1hZGUpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcikgY2IoZXIsIG1hZGUpO1xcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBta2RpclAocCwgb3B0cywgY2IsIG1hZGUpO1xcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgYW55IG90aGVyIGVycm9yLCBqdXN0IHNlZSBpZiB0aGVyZSdzIGEgZGlyXFxuICAgICAgICAgICAgLy8gdGhlcmUgYWxyZWFkeS4gIElmIHNvLCB0aGVuIGhvb3JheSEgIElmIG5vdCwgdGhlbiBzb21ldGhpbmdcXG4gICAgICAgICAgICAvLyBpcyBib3JrZWQuXFxuICAgICAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgICAgICAgeGZzLnN0YXQocCwgZnVuY3Rpb24gKGVyMiwgc3RhdCkge1xcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHN0YXQgZmFpbHMsIHRoZW4gdGhhdCdzIHN1cGVyIHdlaXJkLlxcbiAgICAgICAgICAgICAgICAgICAgLy8gbGV0IHRoZSBvcmlnaW5hbCBlcnJvciBiZSB0aGUgZmFpbHVyZSByZWFzb24uXFxuICAgICAgICAgICAgICAgICAgICBpZiAoZXIyIHx8ICFzdGF0LmlzRGlyZWN0b3J5KCkpIGNiKGVyLCBtYWRlKVxcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBjYihudWxsLCBtYWRlKTtcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICB9KTtcXG59XFxuXFxubWtkaXJQLnN5bmMgPSBmdW5jdGlvbiBzeW5jIChwLCBvcHRzLCBtYWRlKSB7XFxuICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcXG4gICAgICAgIG9wdHMgPSB7IG1vZGU6IG9wdHMgfTtcXG4gICAgfVxcbiAgICBcXG4gICAgdmFyIG1vZGUgPSBvcHRzLm1vZGU7XFxuICAgIHZhciB4ZnMgPSBvcHRzLmZzIHx8IGZzO1xcbiAgICBcXG4gICAgaWYgKG1vZGUgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgbW9kZSA9IF8wNzc3ICYgKH5wcm9jZXNzLnVtYXNrKCkpO1xcbiAgICB9XFxuICAgIGlmICghbWFkZSkgbWFkZSA9IG51bGw7XFxuXFxuICAgIHAgPSBwYXRoLnJlc29sdmUocCk7XFxuXFxuICAgIHRyeSB7XFxuICAgICAgICB4ZnMubWtkaXJTeW5jKHAsIG1vZGUpO1xcbiAgICAgICAgbWFkZSA9IG1hZGUgfHwgcDtcXG4gICAgfVxcbiAgICBjYXRjaCAoZXJyMCkge1xcbiAgICAgICAgc3dpdGNoIChlcnIwLmNvZGUpIHtcXG4gICAgICAgICAgICBjYXNlICdFTk9FTlQnIDpcXG4gICAgICAgICAgICAgICAgbWFkZSA9IHN5bmMocGF0aC5kaXJuYW1lKHApLCBvcHRzLCBtYWRlKTtcXG4gICAgICAgICAgICAgICAgc3luYyhwLCBvcHRzLCBtYWRlKTtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgYW55IG90aGVyIGVycm9yLCBqdXN0IHNlZSBpZiB0aGVyZSdzIGEgZGlyXFxuICAgICAgICAgICAgLy8gdGhlcmUgYWxyZWFkeS4gIElmIHNvLCB0aGVuIGhvb3JheSEgIElmIG5vdCwgdGhlbiBzb21ldGhpbmdcXG4gICAgICAgICAgICAvLyBpcyBib3JrZWQuXFxuICAgICAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgICAgICAgdmFyIHN0YXQ7XFxuICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICBzdGF0ID0geGZzLnN0YXRTeW5jKHApO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIxKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnIwO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmICghc3RhdC5pc0RpcmVjdG9yeSgpKSB0aHJvdyBlcnIwO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gbWFkZTtcXG59O1xcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCJfcHJvY2Vzc1xcXCI6NTEsXFxcImZzXFxcIjo0MSxcXFwicGF0aFxcXCI6NDF9XSw3MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XFxuLyoqXFxuICogU2hpbSBwcm9jZXNzLnN0ZG91dC5cXG4gKi9cXG5cXG5wcm9jZXNzLnN0ZG91dCA9IHJlcXVpcmUoJ2Jyb3dzZXItc3Rkb3V0JykoKTtcXG5cXG52YXIgTW9jaGEgPSByZXF1aXJlKCcuLi8nKTtcXG5cXG4vKipcXG4gKiBDcmVhdGUgYSBNb2NoYSBpbnN0YW5jZS5cXG4gKlxcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cXG4gKi9cXG5cXG52YXIgbW9jaGEgPSBuZXcgTW9jaGEoeyByZXBvcnRlcjogJ2h0bWwnIH0pO1xcblxcbi8qKlxcbiAqIFNhdmUgdGltZXIgcmVmZXJlbmNlcyB0byBhdm9pZCBTaW5vbiBpbnRlcmZlcmluZyAoc2VlIEdILTIzNykuXFxuICovXFxuXFxudmFyIERhdGUgPSBnbG9iYWwuRGF0ZTtcXG52YXIgc2V0VGltZW91dCA9IGdsb2JhbC5zZXRUaW1lb3V0O1xcbnZhciBzZXRJbnRlcnZhbCA9IGdsb2JhbC5zZXRJbnRlcnZhbDtcXG52YXIgY2xlYXJUaW1lb3V0ID0gZ2xvYmFsLmNsZWFyVGltZW91dDtcXG52YXIgY2xlYXJJbnRlcnZhbCA9IGdsb2JhbC5jbGVhckludGVydmFsO1xcblxcbnZhciB1bmNhdWdodEV4Y2VwdGlvbkhhbmRsZXJzID0gW107XFxuXFxudmFyIG9yaWdpbmFsT25lcnJvckhhbmRsZXIgPSBnbG9iYWwub25lcnJvcjtcXG5cXG4vKipcXG4gKiBSZW1vdmUgdW5jYXVnaHRFeGNlcHRpb24gbGlzdGVuZXIuXFxuICogUmV2ZXJ0IHRvIG9yaWdpbmFsIG9uZXJyb3IgaGFuZGxlciBpZiBwcmV2aW91c2x5IGRlZmluZWQuXFxuICovXFxuXFxucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGUsIGZuKXtcXG4gIGlmICgndW5jYXVnaHRFeGNlcHRpb24nID09IGUpIHtcXG4gICAgaWYgKG9yaWdpbmFsT25lcnJvckhhbmRsZXIpIHtcXG4gICAgICBnbG9iYWwub25lcnJvciA9IG9yaWdpbmFsT25lcnJvckhhbmRsZXI7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZ2xvYmFsLm9uZXJyb3IgPSBmdW5jdGlvbigpIHt9O1xcbiAgICB9XFxuICAgIHZhciBpID0gTW9jaGEudXRpbHMuaW5kZXhPZih1bmNhdWdodEV4Y2VwdGlvbkhhbmRsZXJzLCBmbik7XFxuICAgIGlmIChpICE9IC0xKSB7IHVuY2F1Z2h0RXhjZXB0aW9uSGFuZGxlcnMuc3BsaWNlKGksIDEpOyB9XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBJbXBsZW1lbnRzIHVuY2F1Z2h0RXhjZXB0aW9uIGxpc3RlbmVyLlxcbiAqL1xcblxcbnByb2Nlc3Mub24gPSBmdW5jdGlvbihlLCBmbil7XFxuICBpZiAoJ3VuY2F1Z2h0RXhjZXB0aW9uJyA9PSBlKSB7XFxuICAgIGdsb2JhbC5vbmVycm9yID0gZnVuY3Rpb24oZXJyLCB1cmwsIGxpbmUpe1xcbiAgICAgIGZuKG5ldyBFcnJvcihlcnIgKyAnICgnICsgdXJsICsgJzonICsgbGluZSArICcpJykpO1xcbiAgICAgIHJldHVybiAhbW9jaGEuYWxsb3dVbmNhdWdodDtcXG4gICAgfTtcXG4gICAgdW5jYXVnaHRFeGNlcHRpb25IYW5kbGVycy5wdXNoKGZuKTtcXG4gIH1cXG59O1xcblxcbi8vIFRoZSBCREQgVUkgaXMgcmVnaXN0ZXJlZCBieSBkZWZhdWx0LCBidXQgbm8gVUkgd2lsbCBiZSBmdW5jdGlvbmFsIGluIHRoZVxcbi8vIGJyb3dzZXIgd2l0aG91dCBhbiBleHBsaWNpdCBjYWxsIHRvIHRoZSBvdmVycmlkZGVuIGBtb2NoYS51aWAgKHNlZSBiZWxvdykuXFxuLy8gRW5zdXJlIHRoYXQgdGhpcyBkZWZhdWx0IFVJIGRvZXMgbm90IGV4cG9zZSBpdHMgbWV0aG9kcyB0byB0aGUgZ2xvYmFsIHNjb3BlLlxcbm1vY2hhLnN1aXRlLnJlbW92ZUFsbExpc3RlbmVycygncHJlLXJlcXVpcmUnKTtcXG5cXG52YXIgaW1tZWRpYXRlUXVldWUgPSBbXVxcbiAgLCBpbW1lZGlhdGVUaW1lb3V0O1xcblxcbmZ1bmN0aW9uIHRpbWVzbGljZSgpIHtcXG4gIHZhciBpbW1lZGlhdGVTdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xcbiAgd2hpbGUgKGltbWVkaWF0ZVF1ZXVlLmxlbmd0aCAmJiAobmV3IERhdGUoKS5nZXRUaW1lKCkgLSBpbW1lZGlhdGVTdGFydCkgPCAxMDApIHtcXG4gICAgaW1tZWRpYXRlUXVldWUuc2hpZnQoKSgpO1xcbiAgfVxcbiAgaWYgKGltbWVkaWF0ZVF1ZXVlLmxlbmd0aCkge1xcbiAgICBpbW1lZGlhdGVUaW1lb3V0ID0gc2V0VGltZW91dCh0aW1lc2xpY2UsIDApO1xcbiAgfSBlbHNlIHtcXG4gICAgaW1tZWRpYXRlVGltZW91dCA9IG51bGw7XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIEhpZ2gtcGVyZm9ybWFuY2Ugb3ZlcnJpZGUgb2YgUnVubmVyLmltbWVkaWF0ZWx5LlxcbiAqL1xcblxcbk1vY2hhLlJ1bm5lci5pbW1lZGlhdGVseSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XFxuICBpbW1lZGlhdGVRdWV1ZS5wdXNoKGNhbGxiYWNrKTtcXG4gIGlmICghaW1tZWRpYXRlVGltZW91dCkge1xcbiAgICBpbW1lZGlhdGVUaW1lb3V0ID0gc2V0VGltZW91dCh0aW1lc2xpY2UsIDApO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogRnVuY3Rpb24gdG8gYWxsb3cgYXNzZXJ0aW9uIGxpYnJhcmllcyB0byB0aHJvdyBlcnJvcnMgZGlyZWN0bHkgaW50byBtb2NoYS5cXG4gKiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHJ1bm5pbmcgdGVzdHMgaW4gYSBicm93c2VyIGJlY2F1c2Ugd2luZG93Lm9uZXJyb3Igd2lsbFxcbiAqIG9ubHkgcmVjZWl2ZSB0aGUgJ21lc3NhZ2UnIGF0dHJpYnV0ZSBvZiB0aGUgRXJyb3IuXFxuICovXFxubW9jaGEudGhyb3dFcnJvciA9IGZ1bmN0aW9uKGVycikge1xcbiAgTW9jaGEudXRpbHMuZm9yRWFjaCh1bmNhdWdodEV4Y2VwdGlvbkhhbmRsZXJzLCBmdW5jdGlvbiAoZm4pIHtcXG4gICAgZm4oZXJyKTtcXG4gIH0pO1xcbiAgdGhyb3cgZXJyO1xcbn07XFxuXFxuLyoqXFxuICogT3ZlcnJpZGUgdWkgdG8gZW5zdXJlIHRoYXQgdGhlIHVpIGZ1bmN0aW9ucyBhcmUgaW5pdGlhbGl6ZWQuXFxuICogTm9ybWFsbHkgdGhpcyB3b3VsZCBoYXBwZW4gaW4gTW9jaGEucHJvdG90eXBlLmxvYWRGaWxlcy5cXG4gKi9cXG5cXG5tb2NoYS51aSA9IGZ1bmN0aW9uKHVpKXtcXG4gIE1vY2hhLnByb3RvdHlwZS51aS5jYWxsKHRoaXMsIHVpKTtcXG4gIHRoaXMuc3VpdGUuZW1pdCgncHJlLXJlcXVpcmUnLCBnbG9iYWwsIG51bGwsIHRoaXMpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXR1cCBtb2NoYSB3aXRoIHRoZSBnaXZlbiBzZXR0aW5nIG9wdGlvbnMuXFxuICovXFxuXFxubW9jaGEuc2V0dXAgPSBmdW5jdGlvbihvcHRzKXtcXG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2Ygb3B0cykgb3B0cyA9IHsgdWk6IG9wdHMgfTtcXG4gIGZvciAodmFyIG9wdCBpbiBvcHRzKSB0aGlzW29wdF0ob3B0c1tvcHRdKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogUnVuIG1vY2hhLCByZXR1cm5pbmcgdGhlIFJ1bm5lci5cXG4gKi9cXG5cXG5tb2NoYS5ydW4gPSBmdW5jdGlvbihmbil7XFxuICB2YXIgb3B0aW9ucyA9IG1vY2hhLm9wdGlvbnM7XFxuICBtb2NoYS5nbG9iYWxzKCdsb2NhdGlvbicpO1xcblxcbiAgdmFyIHF1ZXJ5ID0gTW9jaGEudXRpbHMucGFyc2VRdWVyeShnbG9iYWwubG9jYXRpb24uc2VhcmNoIHx8ICcnKTtcXG4gIGlmIChxdWVyeS5ncmVwKSBtb2NoYS5ncmVwKG5ldyBSZWdFeHAocXVlcnkuZ3JlcCkpO1xcbiAgaWYgKHF1ZXJ5LmZncmVwKSBtb2NoYS5ncmVwKHF1ZXJ5LmZncmVwKTtcXG4gIGlmIChxdWVyeS5pbnZlcnQpIG1vY2hhLmludmVydCgpO1xcblxcbiAgcmV0dXJuIE1vY2hhLnByb3RvdHlwZS5ydW4uY2FsbChtb2NoYSwgZnVuY3Rpb24oZXJyKXtcXG4gICAgLy8gVGhlIERPTSBEb2N1bWVudCBpcyBub3QgYXZhaWxhYmxlIGluIFdlYiBXb3JrZXJzLlxcbiAgICB2YXIgZG9jdW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQ7XFxuICAgIGlmIChkb2N1bWVudCAmJiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9jaGEnKSAmJiBvcHRpb25zLm5vSGlnaGxpZ2h0aW5nICE9PSB0cnVlKSB7XFxuICAgICAgTW9jaGEudXRpbHMuaGlnaGxpZ2h0VGFncygnY29kZScpO1xcbiAgICB9XFxuICAgIGlmIChmbikgZm4oZXJyKTtcXG4gIH0pO1xcbn07XFxuXFxuLyoqXFxuICogRXhwb3NlIHRoZSBwcm9jZXNzIHNoaW0uXFxuICogaHR0cHM6Ly9naXRodWIuY29tL21vY2hhanMvbW9jaGEvcHVsbC85MTZcXG4gKi9cXG5cXG5Nb2NoYS5wcm9jZXNzID0gcHJvY2VzcztcXG5cXG4vKipcXG4gKiBFeHBvc2UgbW9jaGEuXFxuICovXFxuXFxuZ2xvYmFsLk1vY2hhID0gTW9jaGE7XFxuZ2xvYmFsLm1vY2hhID0gbW9jaGE7XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSlcXG59LHtcXFwiLi4vXFxcIjoxLFxcXCJfcHJvY2Vzc1xcXCI6NTEsXFxcImJyb3dzZXItc3Rkb3V0XFxcIjo0MH1dfSx7fSxbNzFdKTtcXG5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9yYXctbG9hZGVyIS4uL34vbW9jaGEvbW9jaGEuanNcbiAqKiBtb2R1bGUgaWQgPSA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xyXG5cdGRlbGV0ZSByZXF1aXJlLmNhY2hlW21vZHVsZS5pZF07XHJcblx0aWYodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubW9jaGFQaGFudG9tSlMpXHJcblx0XHRtb2NoYVBoYW50b21KUy5ydW4oKTtcclxuXHRlbHNlXHJcblx0XHRtb2NoYS5ydW4oKTtcclxufSk7XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9tb2NoYS1sb2FkZXIvc3RhcnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS9+L25vZGUtbGlicy1icm93c2VyL34vcHJvY2Vzcy9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=